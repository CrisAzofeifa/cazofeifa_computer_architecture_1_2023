<!doctype html>
<head>
<meta charset="utf-8">
<title>Byte Order and Byte Swapping in Simics</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<span></span>
</div>
<div class="path"></div>
<h1 id="byte-order-and-byte-swapping-in-simics"><a href="#byte-order-and-byte-swapping-in-simics">Byte Order and Byte Swapping in Simics</a></h1>
<h2 id="introduction">1 <a href="#introduction">Introduction</a></h2>
<p>This application note tells you how to model byte order, also known as endianness, and byte swapping in Simics. Its intended audience is developers modeling a system or part of a system. First this note will describe byte order and byte swapping, and what they mean in the context of Simics. The concepts are tightly tied to how Simics models devices, buses and memory transactions so this note will give a brief overview of this subject, but assumes you know DML and the basics of modeling a system in Simics. DML and system modeling is described in the <em>Model Builder User's Guide</em>.</p>
<p>The Simics abstraction level means that you only need to know as much about a system as someone who will write software to access its devices. This information is usually found in a <em>Programming Reference Manual</em> or similar document. This note is a complement to such documentation and shows you how to implement byte order and byte swapping in Simics.</p>
<p>Byte order describes the order you store a byte representation of a value which does not fit in one byte. You use endian conversion to convert between an integer and its byte array representation. In Simics this is often used when accessing memory and devices in the simulated machine (known as the target). Simics's model of memory is an array of slots, where each slot can contain one byte. Indexes into the array are called addresses. Low addresses comes before high addresses. To store a value which does not fit in a single slot you split the value into byte sized parts and store these parts in consecutive slots. In Simics there are two ways to store multi-byte values: big endian, and little endian. Big endian means that the parts are stored with the most significant byte in the slot with the lowest address, and little endian means the opposite, that the least significant byte of the value is stored first. </p>
<figure id="figure-endian">
<p><img alt="" src="endian.png"></p><figcaption>Figure 1.  The 4 digit value 4713 is stored into memory where each slot can hold a single digit. Both big endian and little endian encoding is shown. </figcaption><p></p>
</figure>
<p>Figure <a class="reference" href="#figure-endian">1</a> shows how a value is stored in a memory where each slot can hold a single digit. Simics memory works the same, except that each slot can hold a byte instead of a digit.</p>
<p>In a real system memory does not work as a simple array of byte sized slots. At the hardware level data is often addressed in larger parts than bytes. However, the model of memory presented to software running on the system is still an array of byte sized slots. This is an abstraction of the real hardware implementation, which is built from buses, or something akin to buses. When a device accesses a part of memory the access may need to travel over several buses. Each time the access crosses from one bus to another the order of bytes may change. This is called byte swapping. Simics models the memory spaces of a system with instances of the <code>memory-space</code> class. It is this model which models byte swapping in Simics. Its complete description can be found in the <em>Model Builder User's Guide</em> and the <em>Simics Reference Manual</em>. Here we are only interested in the pieces which control byte swapping: the <em>align-size</em> and <em>byte-swap</em> fields of the <code>map</code> attribute's entries.</p>
<p>In Simics memory accesses are modeled as transactions. Each transaction has three major parts: an array of slots where the data read or written by the transaction is stored, an address which is the first address in the memory space the transaction will access, and information about if the transaction is a read or write transaction. Each transaction accesses one or more consecutive slots in a memory space. To initiate a transaction you use methods in the <code>memory_space</code> interface. The memory space looks up which element in the map matches the transaction and uses the information in this element to forward the transaction to the target device. If the transaction is large enough to match more than one element it is first split into one transaction per element accessed. Before forwarding the transaction the memory space will modify it according to the <em>align-size</em> and <em>byte-swap</em> fields. When the transaction finally reaches a device it is handled by the device. For plain RAM or ROM devices, this is taken care of by <code>ram</code> or <code>rom</code> instances. Other devices handles transactions with the <code>io_memory</code> interface. This is handled by banks in DML.</p>
<figure id="figure-transaction-and-memory">
<p><img alt="" src="transaction-memory.png"></p><figcaption>Figure 2.  Copying between a transaction and memory. </figcaption><p></p>
</figure>
<p>Figure <a class="reference" href="#figure-transaction-and-memory">2</a> shows how data is copied between a transaction and a memory, i.e., a RAM or ROM, in Simics. No endian conversion is performed since both the transaction and memory works on bytes.</p>
<p>Now we have the required context for byte swapping and byte order modeling in Simics. The next sections describe how to handle byte order when writing device models and how to use byte swapping when modeling systems with buses which perform byte swapping. </p>
<h2 id="endian-conversion-in-dml">2 <a href="#endian-conversion-in-dml">Endian Conversion in DML</a></h2>
<p>This section will describe how to perform endian conversion and when to do it. It is focused on modeling this in DML. DML automates most of the endian conversion. As a developer of a model you only have to set the correct byte order for the registers and data structures you use. The concepts DML uses to describe the byte order of values in the target are <code>layout</code>s, which are used to describe the layout of memory buffers, and <code>register</code>s, which are used to describe the byte order of a device's own registers.</p>
<p>The byte order of registers is specified in the <code>byte_order</code> parameter on the bank containing the register. Allowed values for the parameter are <code>"little-endian"</code>, <code>"big-endian"</code> and <code>undefined</code>. All the registers in the bank will have this byte order. If all the banks in the device have the same byte order you can define the <code>byte_order</code> on the device instead. This value will be inherited by all the banks which do not set their own byte order. The byte order defines how to convert between the value of the register and bytes written to or read from it.</p>
<figure id="figure-layout">
<p><img alt="" src="layout.png"></p><figcaption>Figure 3.  How data moves between integer values and a transaction when using layouts. The layout does not store the data itself, it only provides an interpretation of the data in the buffer. BE means that the part of the layout is big endian and LE that it is little endian. The figure uses digit sized bytes. </figcaption><p></p>
</figure>
<p>A <code>layout</code> describes the layout of a piece of host memory. It is similar to a <code>struct</code> in DML or C, but can only contain members of type integer, layout, or bitfields (which is just a special kind of integer). Each layout type also specifies a byte order, which specifies the byte order to use for its integer and bitfields members. The allowed values for the byte order are <code>"little-endian"</code> and <code>"big-endian"</code>. This specifies which order the bytes of a member are used when interpreted as an integer. An overview of how layouts work and where they fit in is provided in figure <a class="reference" href="#figure-layout">3</a>. As layouts are intended to describe data structures in the simulated system's memory there is no implicit padding between the members or at the end of the layout.</p>
<p>To use a layout to access parts of a data structure in the simulated memory you use a memory transaction to move data between a host memory buffer and target memory. Use <code>SIM_get_mem_op_value_buf</code> and <code>SIM_set_mem_op_value_buf</code> to extract a buffer containing the transactions data or replace the data in the transaction with a buffer. For PCI devices you do not have to do this manually, as the PCI library provides methods to perform these tasks. More details about how to access target memory is described in the <em>Model Builder User's Guide</em>. Once you have the data in a buffer, cast the pointer to the buffer to a pointer to the wanted layout type. Then you can use the layout pointer to access the fields of the layout, just like you would access the fields of a struct. DML automatically maps between the bytes pointed to and values as specified in the layout declaration.</p>
<p>DML also allows you to access parts of integer values based on bit indexes. This feature, although it may appear related to byte order, is unrelated and will not be discussed further here. </p>
<h2 id="endian-conversion-in-c">3 <a href="#endian-conversion-in-c">Endian Conversion in C</a></h2>
<p>In C you have to handle the byte order manually. Simics provides some functions and macros to make this easier. The simplest way to handle byte order is to use <code>SIM_get_mem_op_value_le</code>, and <code>SIM_get_mem_op_value_be</code> to get values out of a memory transaction and <code>SIM_set_mem_op_value_le</code>, and <code>SIM_set_mem_op_value_be</code> to put values into a memory transaction. These functions only works on transaction sizes up to eight bytes, but this is often enough, at least when you implement registers. As you can see there are two versions of the getter and two versions of the setter. The functions with the <em>_le</em> suffix uses little endian byte order to convert between values and bytes, and the ones with the <em>_be</em> suffix uses big endian byte order.</p>
<p>If you need transactions larger than eight bytes to access data structure in memory with complex layout you must use a two stage process instead. You must move data between the transaction and a buffer in host memory and you must convert between values and bytes in the buffer.</p>
<p>To get values out of a transaction you first use <code>SIM_get_mem_op_value_buf</code> to get a buffer containing the data in the transaction. Then you can convert bytes in this buffer to integer values with the load macros. The load macros are provided for value sizes from one byte up to eight bytes in both load big endian and load little endian variants.</p>
<p>To put values into a transaction you first store the values into a buffer with the store macros, and then you put this buffer into the memory transaction with <code>SIM_set_mem_op_value_buf</code>. As with the load macros the store macros are provided for value sizes from one to eight bytes, and in both little endian and big endian variants.</p>
<p>To get access to the load and store macros, include <code>simics/util/swabber.h</code>: </p>
<pre><code>#include &lt;simics/util/swabber.h&gt;
</code></pre>
<p>The load macros are named <code>LOAD_{endian}{size}(p)</code>, where <em>{endian}</em> can be <code>BE</code> for big endian loads or <code>LE</code> for little endian ones, and <em>{size}</em> can be 8, 16, 32, or 64 and is the size in bits of the value to load. The macros take one argument: a pointer to the buffer where the value should be stored.</p>
<p>The store macros are named <code>STORE_{endian}{size}(p, x)</code>, where <em>{endian}</em> and <em>{size}</em> can have the same values as in the load macros. The macros take two arguments: a pointer to the buffer where the value should be stored, and the value to store.</p>
<p>The load and store macros should only be used for aligned pointers. If you need to load or store from unaligned pointers use the unaligned variants of the macros instead. They are named the same as the normal macros, but with an <code>UNALIGNED_</code> prefix, for example <code>UNALIGNED_LOAD_BE64</code>.</p>
<h2 id="byte-swapping">4 <a href="#byte-swapping">Byte Swapping</a></h2>
<p>Byte swapping in Simics models the byte swapping performed between adjacent buses. It is performed by memory spaces based on the <em>align-size</em>, and <em>byte-swap</em> fields. Both fields are parts of the <code>map</code> attribute's entries. This means that you can apply byte swapping for all devices mapped into a memory space, no matter if they are memory spaces, or any other kind of device you can add to a memory space. For information about the <code>memory-space</code> class and its <code>map</code> read the <em>Model Builder User's Guide</em> and the <em>Simics Reference Manual</em>.</p>
<p>Before byte swapping a transaction the memory space splits it into sub transactions based on the <em>align-size</em>. At each even multiple of the align size there is an alignment boundary. Any transaction which crosses such a boundary is split into two transactions. If a transaction crosses more than one boundary it is split at each boundary it crosses.</p>
<figure id="figure-byte-swap">
<p><img alt="" src="byte-swap.png"></p><figcaption>Figure 4.  The four byte swapping modes. Each transaction is shown as an address and an array of slots. The letters are the identities of the slots. </figcaption><p></p>
</figure>
<p>If the alignment size is 2, 4 or 8 you can enable byte swapping with the <em>byte-swap</em> field. Byte swapping is performed for each of the sub transactions individually. Byte swapping is based on the size of the transaction and the <em>align-size</em>. By default the byte swap mode is 0, which means that the memory space will not perform any byte swapping of transactions for the entry. If you set <em>byte-swap</em> to 1 then each alignment sized chunk will be reversed. This means that the address of a transaction may be changed. If you set <em>byte-swap</em> to 2 then each alignment sized chunk will be reversed and then the parts of the chunk accessed by the transaction will be reversed again. Finally you can set <em>byte-swap</em> to 3, which reverses the bytes in the transaction. Figure <a class="reference" href="#figure-byte-swap">4</a> compares the byte swap modes.</p>
<p>Byte swapping can be hard to understand. A couple of examples will make it clearer. Each example takes one transaction and describes what happens to it when it is split and byte swapped. Let us begin with something simple: a transaction of size 4 performing an aligned access with <em>align-size</em> 4. This transaction does not need to be split, so let us move on to what happens to it for the different byte swap modes. In the byte swap mode 0 the transaction is unchanged, since this mode never modifies any transactions. In byte swap mode 1 the slots in the transaction are reversed, since this mode reverses slots based on the align size and the transaction has the same size as the align size. In byte swap mode 2 the transaction is unchanged. The reason is that the slots are first reversed based on the align size and then reversed again based on the transaction size and the transaction is aligned and has the same size as the align size. In byte swap mode 3 the slots in the transaction are reversed, since the mode reverses the slots in the transaction.</p>
<figure id="figure-3-at-1-byte-swap">
<p><img alt="" src="3-at-1-byte-swap.png"></p><figcaption>Figure 5.  Byte swapping a transaction of size 3 with address 1 using align size 4. For all the modes the input and the result is shown, and for mode 2 the intermediate result, which is the same as with mode 1 is also shown inbetween the input and the result. </figcaption><p></p>
</figure>
<p>Let us work through a more complex example: a transaction of size 3 at address 1, but still accessing a device with align size 4. As always this transaction is unchanged if the device is mapped with byte swap mode 0. See figure <a class="reference" href="#figure-3-at-1-byte-swap">5</a> for a graphical representation of how the transaction is affected by the other byte swap modes. With byte swap mode 1 the slots from address 0 to address 3 are reversed, but this transaction only contains slots from address 1 to address 3; there is no slot at address 0. We still reverse as if there was a slot at address 0 and then we drop this pseudo slot. This means that the resulting transaction will be based at address 0 and contain the same slots it had from the beginning, but in reverse order. Byte swap mode 2 first performs the same operation as byte swap mode 1 and then it reverses the slots in the transaction. The result of this is that the transaction will be based at address 0 and contain the original slots in their original order. Byte swap mode 3 reverses the slots in the transaction and always leaves the base address of the transaction intact. This means that the byte swapped transaction will be based at address 1 and contain its original slots, but in reverse order.</p>
<p>Once the sub transactions are handled they are reassembled by the memory space, and that is when the identities of the slots comes into play. The reassembled transaction has the same shape as the original transaction and all the slots comes in the same order as they did in the original transaction.</p>
<p>Which mode to use depends on how the bridge chip you want to model works. For information about this you need to read its documentation.</p>
<p>The swapping can often be set up in a component when creating the memory spaces of the system. A device model can also set it up when using the <code>map_demap</code> interface to map devices into a memory space. It is set up in the <code>align_size</code> and <code>reverse_endian</code> members of the <code>map_info_t</code> value passed into the <code>map_demap</code> methods. <code>align_size</code> specifies the align size and <code>reverse_endian</code> the byte swap mode. </p>
<h2 id="putting-it-all-together">5 <a href="#putting-it-all-together">Putting it all Together</a></h2>
<figure id="figure-overview">
<p><img alt="" src="overview.png"></p><figcaption>Figure 6.  A complete read transaction. The figure uses digit sized slots in the transactions instead of byte sized ones to make it clearer. The slots in the transactions have both a name, in the form of a letter, and a contents. </figcaption><p></p>
</figure>
<p>Figure <a class="reference" href="#figure-overview">6</a> shows an example of a complete memory transaction involving both byte order conversion and byte swapping. It shows a device initiating a load of 4 bytes interpreted as a big endian number at address 2. The system model maps this address to a target device, with an align size of 4. The target device has two registers targeted by the transaction: a big endian register of size 2 at address 0 and a little endian register also of size 2 at address 6. The transaction goes through several steps: </p>
<ol>
<li>The initiating device creates a load transaction of size 4 with address 2.</li>
<li>The memory space, using align size 4 and byte swap mode 1, splits the transaction into two sub transactions and swaps the bytes in the sub transactions.</li>
<li>The first sub transaction is received by the target device, which uses a big endian store to store the value 47 into it.</li>
<li>The second sub transaction is received by the target device, which uses a little endian store to store the value 17 into it.</li>
<li>The sub transactions are reassembled into a single transaction.</li>
<li>The initiating device uses a big endian load to load the value 7417 from the transaction.</li>
</ol>

<div class="chain">
<span></span>
</div>