<!doctype html>
<head>
<meta charset="utf-8">
<title>13 Using Simics for Hardware Bring-Up and Firmware Development</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="revexec.html">12.3 Reverse Execution</a>
<a href="a-simple-example.html">13.1 A Simple Example</a>
</div>
<div class="path">
<a href="index.html">Simics User's Guide</a>
&nbsp;/&nbsp;
<a href="low-level-debugging.html">III Low-Level Debugging</a>
&nbsp;/&nbsp;</div>
<h1 class="jdocu"><a name="lowlevel-software">13 Using Simics for Hardware Bring-Up and Firmware Development</a></h1>
<p>

</p><p>
Simics makes hardware bring-up, firmware development, and other
low-level programming tasks easier in a number of ways:
</p><p>
</p><dl><dt id="dt:hardware-replacement"><b>Hardware replacement</b></dt><dd>A simulator replaces hardware. This has two key benefits during
  hardware bring-up: you can start working on the software before the
  hardware is available, and you can have as many copies of the
  simulated hardware as you like. Both of these translate directly to
  reduced total development time for the combined hardware+software
  product.</dd><dt id="dt:inspection-and-modification"><b>Inspection and modification</b></dt><dd>You can inspect the state of the entire simulation—memory,
  processor registers, device registers, anything—all entirely
  non-intrusively. And time is simply paused while you do so. You can
  run backward in time, modify memory or register contents, and then
  run forward again and see the effects of this change.</dd><dt id="dt:full-debug-support"><b>Full debug support</b></dt><dd>The full power of Simics debugging (see chapter <a class="reference" href="debug.html">12</a>), with breakpoints, symbolic debugging, reverse
  execution, scripting, and so on, is available everywhere, even at
  the very lowest levels.</dd></dl><p>
</p><p>
</p>
<ul class="subsections">
<li>
<a href="a-simple-example.html">13.1 A Simple Example</a>
</li>
<li>
<a href="going-further.html">13.2 Going Further</a>
</li>
</ul>
<div class="chain">
<a href="revexec.html">12.3 Reverse Execution</a>
<a href="a-simple-example.html">13.1 A Simple Example</a>
</div>