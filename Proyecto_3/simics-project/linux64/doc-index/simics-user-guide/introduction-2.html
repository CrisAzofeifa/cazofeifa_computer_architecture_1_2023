<!doctype html>
<head>
<meta charset="utf-8">
<title>11 Introduction</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="low-level-debugging.html">III Low-Level Debugging</a>
<a href="debug.html">12 Low-level Debugging with Simics</a>
</div>
<div class="path">
<a href="index.html">Simics User's Guide</a>
&nbsp;/&nbsp;
<a href="low-level-debugging.html">III Low-Level Debugging</a>
&nbsp;/&nbsp;</div>
<h1 class="jdocu"><a name="introduction">11 Introduction</a></h1>
<p>

</p><p>
This part of the document explains how to use Simics as a
tool in low-level software development. In this setting, Simics plays
two roles:
</p><p>
</p><dl><dt id="dt:execution-platform"><b>execution platform</b></dt><dd>The software is run on a simulated target machine inside
  Simics.</dd><dt id="dt:debugger"><b>debugger</b></dt><dd>Simics can either function as a stand-alone debugger, or as a
  debugger backend for an external debugger. The main Simics debugger
  is provided in Simics Analyzer.</dd></dl><p>Simics Analyzer provides a full symbolic debugger for C and C++. This
is described in the <em>Analyzer User's Guide</em>. The debugger
in Simics Analyzer is also capable of tracking software running on
target machines, to give you the ability to debug individual
processes, threads and tasks. Also, Simics provides some
debugging capabilities.
</p><p>
Using Simics as a debugger has some major benefits compared to
debugging on real hardware:
</p><p>
</p><ul>

  <li>Debugging is completely non-intrusive.</li>

  <li>You can inspect and modify the state of the entire target
  system, at any level. This is especially convenient when debugging
  low-level code such as firmware and hardware drivers.</li>

  <li>The simulation is completely deterministic. Once you manage to
  trigger a bug, you can repeat it as often as you like.</li>

  <li>You have complete control over time. For example, you can freeze
  time while inspecting the target, save the simulated state in a
  checkpoint and restore it at a later time, and even run the whole
  simulation backward.</li>

</ul>
<p>
</p><div class="note">
<b>Note:</b>
It is recommended that you have read <em>Getting Started</em>
before tackling this document.</div>
<div class="chain">
<a href="low-level-debugging.html">III Low-Level Debugging</a>
<a href="debug.html">12 Low-level Debugging with Simics</a>
</div>