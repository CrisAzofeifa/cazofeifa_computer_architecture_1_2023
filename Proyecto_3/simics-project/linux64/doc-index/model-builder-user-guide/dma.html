<!doctype html>
<head>
<meta charset="utf-8">
<title>18 Modeling Direct Memory Access (DMA)</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="modeling-interrupt-controllers.html">17 Modeling Interrupt Controllers</a>
<a href="modeling-i2c-devices.html">19 Modeling I2C Devices</a>
</div>
<div class="path">
<a href="index.html">Model Builder User's Guide</a>
&nbsp;/&nbsp;
<a href="part-common-hardware-components.html">III Modeling Common Hardware Components</a>
&nbsp;/&nbsp;</div>
<h1 class="jdocu"><a name="dma">18 Modeling Direct Memory Access (DMA)</a></h1>
<p>

It is not uncommon for a device to be able to act as bus-master,
reading and writing memory as it pleases. There may be several reasons
why direct memory access (DMA) is supported by a device. One reason
could be that the device's DMA capability may offload the CPU core by
transferring large chunks of memory on the behalf of software.
Another scenario is when a device has to be programmed. If the device
supports many options, writing to its registers may be slow, since
they
usually exist in cache-inhibited space. Using DMA all required
information can be written to a <i>descriptor</i> in memory and the
address to that descriptor can then be written to a register in the
device, using a single (slow) register write. The device is then able
to fetch the required information from main memory on its own,
offloading the CPU cores. This section will demonstrate how to write
device models that support DMA.
</p><p>
In this section it will be described how to create a model of a DMA
device that can be used to autonomously copy data from one area of the
memory to another. By reading this section you will learn how to:
</p><ul>
<li>
Create a device with registers and fields.
</li>
<li>
Instantiate devices and map them into the physical memory address
space.
</li>
<li>
Handle endian issues.
</li>
<li>
Access physical memory from the device (DMA).
</li>
<li>
Perform simple testing and debugging by manually interacting with the
device from the command line and using Simics logging facilities.
</li>
<li>
Simulate time using <i>events</i>.
</li>
<li>
Use interrupts to signal important events in the device.
</li>
<li>
Use layouts to handle descriptors in memory using target byte-order.
</li>
</ul>
<p>
As always when starting out to develop a new device model, it is
necessary to prepare your project for the new device. To do this,
issue the following command:
</p><pre class="jdocu_small"><span class="jdocu_small">
<b>project$ ./bin/project-setup --device=my-dma-device</b>
</span></pre><p>
This will create skeleton files for a new device,
<b>my_dma_device</b>. The relevant files will show up in
<code></code><em>[project]</em><code>/modules/my-dma-device/</code>. At this point it
should be possible to type <b>make</b> in the project directory
to build the skeleton device. The bulk of the device's code will go in
the file <code>my-dma-device.dml</code>. Examine this file, it
should look something like.
</p><p>
</p><pre class="jdocu_small"><span class="jdocu_small">
dml 1.4;

device my_dma_device;
</span></pre><p>

</p><pre class="jdocu_small">param desc = "name of device";

param documentation = "Longer description that will appear in the help";

import "utility.dml";

bank regs {
    param register_size = 4;

    register counter @ 0x00 "A simple counter.";
}

bank regs {
    register counter {

    }
}

</pre><p>
</p><p>

</p><p>
The skeleton code implements a simple counter. Since the DMA device
does not have this functionality it can be removed.
The <b><i>post_init</i></b> method is not going to be used either, so
get rid of that as well. The description <i>param desc</i>
and short documentation <i>param documentation</i> should be
written. The device code should now look something like:
</p><p>
</p><pre class="jdocu_small"><span class="jdocu_small">
dml 1.4;

device my_dma_device;
</span></pre><p>

</p><pre class="jdocu_small">param desc = "example DMA device";

param documentation =
    "Example of a DMA device supporting contiguous memory or scatter-gather "
    + "lists. The device has a controllable throughput (words per second) "
    + "and supports either polling mode or interrupt based signalling upon "
    + "DMA completion.";

import "utility.dml";


bank regs {
    param register_size = 4;

}

</pre><p>
</p><p>

</p><p>
This device now has a single (empty) register bank with 4-byte
registers. The DMA device modeled in this section has three registers,
<i>DMA_control, DMA_source</i> and
<i>DMA_dest</i>. The <i>DMA_source</i> and <i>DMA_dest</i>
registers will hold the source and destination address of the DMA
transfer. The <i>DMA_control</i> register is used to issue control
commands to the DMA engine and to receive the device's status. Add the
three registers to the bank.
</p><p>

</p><pre class="jdocu_small">bank regs {
    param register_size = 4;
    register DMA_control @ 0x00 "Control register";
    register DMA_source  @ 0x04 is (unimpl) "Source address";
    register DMA_dest    @ 0x08 is (unimpl) "Destination address";
}
</pre><p>
</p><p>

</p><p>
Compile the device again and start a new Simics session. It should now
be possible to instantiate the DMA device.
</p><p>

</p><pre class="jdocu_small"><span class="jdocu_small">
<b>project$ ./simics</b>
simics&gt; <b>@SIM_create_object ("my_dma_device", "mydma") </b>
simics&gt; <b>help mydma</b>
Class my_dma_device

  Provided by
    my-dma-device

  Interfaces Implemented
    conf_object, log_object

  Ports
    regs (io_memory), regs (int_register)

  Description
    Example of a DMA device supporting contiguous memory or scatter-gather
    lists. The device has a controllable throughput (words per second) and
    supports either polling mode or interrupt based signalling upon DMA
    completion.


Command List

  Commands defined by interface conf_object
    get-attribute-list, get-interface-list, get-interface-port-list,
    list-attributes, list-interfaces, log, log-group, log-level, log-size,
    log-type

  Commands
    info                print information about the device
    status              print status of the device


Attributes

  regs_DMA_control, regs_DMA_dest, regs_DMA_source

simics&gt;
</span></pre><p>
</p><p>
Note that attributes for the registers are created automatically.
</p><p>
The <i>DMA_control</i> register is divided into a number of
fields. Add a bank definition with the <i>DMA_control</i> register and
explicitly include those fields.
</p><p>

</p><pre class="jdocu_small">bank regs {
    register DMA_control {
        field EN   @ [31]  is (unimpl) "Enable DMA";
        field SWT  @ [30]  is (unimpl) "Software Transfer Trigger";
        field ECI  @ [29]  is (unimpl) "Enable Completion Interrupt";
        field TC   @ [28]  is (read_only)     "Transfer complete";
        field SG   @ [27]  is (unimpl) "Scatter-gather list input";
        field ERR  @ [26] "DMA transfer error";
        field TS   @ [15:0] "Transfer size (32-bit words)";
    }
}
</pre><p>
</p><p>

</p><p>
Now that the device's register map has been defined it is time to
start implementing its behavior. A DMA transfer of <i>TS</i> words
from <i>DMA_source</i> to <i>DMA_dest</i> is triggered when
writing a 1 to the <i>SWT</i> field of <i>DMA_control</i>, if
DMA is enabled by setting the <i>EN</i> bit. Once transfer is
completed the DMA device will notify software by setting the
<i>TC</i> bit and, if interrupts are enabled (<i>ECI</i> bit
set), the DMA device will trigger an interrupt. Using interrupts
alleviates software from the burden of polling the DMA device's
control register. The <i>SG</i> field will be described in section
<a class="reference" href="#dma-scatter-gather">18.3</a> when dealing with descriptors and
the <i>SG</i> field can be ignored for now.
</p><p>
Since the DMA transfer is initiated as a consequence of writing the
<i>SWT</i> bit of the control register one way of initiating
the transaction is to overload the <b><i>write_register</i></b> method of
the <i>DMA_control</i> register.
</p><p>

</p><pre class="jdocu_small">
bank regs {
    register DMA_control {
        field EN   @ [31]  "Enable DMA";
        field SWT  @ [30]  "Software Transfer Trigger";
        field ECI  @ [29]  is (unimpl) "Enable Completion Interrupt";
        field TC   @ [28]  is (read_only)     "Transfer complete";
        field SG   @ [27]  is (unimpl) "Scatter-gather list input";
        field ERR  @ [26] "DMA transfer error";
        field TS   @ [15:0] "Transfer size (32-bit words)";

        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            default(value, enabled_bytes, aux);
            do_dma_transfer();
        }
    }
    method do_dma_transfer() {
        if (DMA_control.SWT.val == 0)
            return; // No need to do anything if we are not asked by software

        // Software asked us to initiate a DMA transfer
        if(DMA_control.EN.val == 0) {
            // enable bit not set, so we cannot transfer
            log info, 2: "EN bit not set, SWT = 1 has no effect";
            return;
        }

        log info, 3: "EN bit set, SWT written, initiating DMA";
        log info, 3: "Transferring %d 32-bit words from 0x%x to 0x%x",
            DMA_control.TS.val, DMA_source.val, DMA_dest.val;

        complete_dma();
    }

    method complete_dma() {
        log unimpl, 1: "DMA transfer completion not implemented.";
    }
}
</pre><p>
</p><p>

</p><p>
Now that the basic logic is in place the only thing left is to
actually transfer the data. In order to do this the DMA device must
have a connection to the <b>memory-space</b> it is to operate
in. Add this connection.
</p><p>

</p><pre class="jdocu_small">
import "utility.dml";
import "simics/devs/memory-space.dml";


// Memory-space connection for DMA work
connect target_mem_space {
    param documentation =
        "The memory space on which the DMA engine operates. Data will be "
        + "read from and copied to the memory associated with this memory "
        + "space.";
    param configuration = "required";
    interface memory_space;
}

</pre><p>
</p><p>

</p><p>
To make DMA operation more convenient two utility methods are also
added, <b><i>read_mem</i></b> and <b><i>write_mem</i></b>. These methods
reads or writes an array of bytes from or to target memory. Think of
them as a <b><i>memcpy</i></b> between host and target.
</p><p>

</p><pre class="jdocu_small">// Read len bytes of target memory from the address src in the memory
// $target_mem_space. The result is put in memory pointed to by dst,
// which must be large enough to hold at least len bytes. If a memory
// access error occurs this method will print an error message and
// throw an exception.
method read_mem(void *dst,
                physical_address_t src,
                physical_address_t len) throws {
    local exception_type_t exc;
    exc = target_mem_space.memory_space.access_simple(dev.obj,
                                                src,
                                                dst,
                                                len,
                                                Sim_RW_Read,
                                                Sim_Endian_Target);

    if (exc != Sim_PE_No_Exception) {
        log error: "an error occurred when reading target memory";
        throw;
    }
}

// Write len bytes to target memory from the memory pointed to by
// src. The data is written to the memory space $target_mem_space at
// address dst. If a memory access error occurs this method will
// print an error message and throw an exception.
method write_mem(physical_address_t dst,
                 const void *src,
                 physical_address_t len) throws {
    local exception_type_t exc;
    exc = target_mem_space.memory_space.access_simple(dev.obj,
                                                dst,
                                                cast(src, uint8*),
                                                len,
                                                Sim_RW_Write,
                                                Sim_Endian_Target);

    if (exc != Sim_PE_No_Exception) {
        log error: "an error occurred when writing to target memory";
        throw;
    }
}


bank regs {
</pre><p>
</p><p>

</p><p>
Now the time has come to implement the actual transferring of bytes,
the main purpose of the DMA device.
</p><p>

</p><pre class="jdocu_small">    method do_dma_transfer() {
        if (DMA_control.SWT.val == 0)
            return; // No need to do anything if we are not asked by software

        // Software asked us to initiate a DMA transfer
        if(DMA_control.EN.val == 0) {
            // enable bit not set, so we cannot transfer
            log info, 2: "EN bit not set, SWT = 1 has no effect";
            return;
        }

        log info, 3: "EN bit set, SWT written, initiating DMA";
        log info, 3: "Transferring %d 32-bit words from 0x%x to 0x%x",
            DMA_control.TS.val, DMA_source.val, DMA_dest.val;

        local uint18 count = DMA_control.TS.val * 4;
        try {
            // Copy the memory block
            local uint8 buf[count];
            read_mem(buf, DMA_source.val, count);
            write_mem(DMA_dest.val, buf, count);
        } catch {
            log error: "DMA memory access failed";
            return;
        }

        complete_dma();
    }

    method complete_dma() {
        // Log that completion is done
        log info, 2: "DMA transfer completed";

        // clear SWT bit, update TS
        DMA_control.SWT.val = 0;
        DMA_control.TS.val = 0;
        DMA_control.TC.val = 1;
    }
}

</pre><p>
</p><p>

</p><p>
Since DMA transfer should now be operational it is no longer
appropriate to mark the source and destination registers as
unimplemented.
</p><p>

</p><pre class="jdocu_small">    register DMA_source  @ 0x04 "Source address";
    register DMA_dest    @ 0x08 "Destination address";
</pre><p>
</p><p>

</p><p>
After adding the <i>target_mem_space</i> connector the device
model can no longer be instantiated on its own. To test the device
start the sample machine in
<code></code><em>[project]</em><code>/targets/qsp-x86/firststeps.simics</code>.
</p><p>
The object of the <b>memory-space</b> class corresponding
to the main memory of this machine is called <b>board.mb.phys_mem</b>.
One can get insight into the machine's memory map with
the <b>info</b> command of the CPU object and
the <b>&lt;memory-space&gt;.map</b> command of the memory objects.
To get the DMA device working it is necessary to map it into
the <b>memory-space</b>.
</p><p>


</p><pre class="jdocu_small"><span class="jdocu_small">
project$ <b>./simics ./targets/qsp-x86/firststeps.simics</b>
simics&gt; <b>board.mb.cpu0.core[0][0].info</b>
Information about board.mb.cpu0.core[0][0] [class x86QSP1]
==========================================================

                 Execution mode : VMP
                Clock frequency : 2000 MHz
                            CPI : 1.00
                Physical memory : board.mb.cpu0.mem[0][0]
                           Cell : board.cell
</span></pre><p>
To get the system to initialize the DDR memory the simulation has to run
for a short while.
</p><pre class="jdocu_small"><span class="jdocu_small">
<b>run 2 s</b>

simics&gt; <b>board.mb.phys_mem.map</b>
┌───────────┬────────────────────────────┬──┬───────────┬───────────┬──────┬────┬─────┬────┐
│       Base│Object                      │Fn│     Offset│     Length│Target│Prio│Align│Swap│
├───────────┼────────────────────────────┼──┼───────────┼───────────┼──────┼────┼─────┼────┤
│        0x0│board.mb.dram_space         │  │        0x0│    0xa0000│      │   0│     │    │
│   0x100000│board.mb.dram_space         │  │   0x100000│ 0xdff00000│      │   0│     │    │
│0x100000000│board.mb.dram_space         │  │0x100000000│0x100000000│      │   0│     │    │
│  -default-│board.mb.nb.pci_bus.port.mem│  │        0x0│           │      │    │     │    │
└───────────┴────────────────────────────┴──┴───────────┴───────────┴──────┴────┴─────┴────┘

simics&gt; <b>@SIM_create_object("my_dma_device", "mydma", target_mem_space=<img alt="Line break" src="nextline.png">
conf.board.mb.phys_mem)</b>
&lt;the my_dma_device 'mydma'&gt;


simics&gt; <b>board.mb.phys_mem.add-map mydma.bank.regs  0x250000000 0xc</b>
Mapped 'mydma.bank.regs' in 'board.mb.phys_mem' at address 0x250000000.
</span></pre><p>
</p><p>
Make sure the device was correctly mapped by examining the memory map
of the <b>board.mb.phys_mem</b> <b>memory-space</b>.
</p><p>
</p><pre class="jdocu_small"><span class="jdocu_small">
simics&gt; <b>board.mb.phys_mem.map</b>
┌───────────┬────────────────────────────┬──┬───────────┬───────────┬──────┬────┬─────┬────┐
│       Base│Object                      │Fn│     Offset│     Length│Target│Prio│Align│Swap│
├───────────┼────────────────────────────┼──┼───────────┼───────────┼──────┼────┼─────┼────┤
│        0x0│board.mb.dram_space         │  │        0x0│    0xa0000│      │   0│     │    │
│   0x100000│board.mb.dram_space         │  │   0x100000│ 0xdff00000│      │   0│     │    │
│0x100000000│board.mb.dram_space         │  │0x100000000│0x100000000│      │   0│     │    │
│0x250000000│mydma.bank.regs             │  │        0x0│        0xc│      │   0│    8│    │
│  -default-│board.mb.nb.pci_bus.port.mem│  │        0x0│           │      │    │     │    │
└───────────┴────────────────────────────┴──┴───────────┴───────────┴──────┴────┴─────┴────┘
</span></pre><p>
</p><p>
To test the device it is possible to trigger a DMA transfer from
within Simics by manually writing to the appropriate registers.
</p><p>
</p><div class="note">
<b>Note:</b>
You must access the device's registers through its memory mapped
interface and not through the attributes, since attribute
accesses are free from side-effects.</div>Set the source register to 0x20000 by writing to the physical memory
at address 0x250000004. Remember that the DMA device was previously
mapped at offset 0x250000000 in the physical memory and that the
source register is at offset 4 in the regs bank of the device.
<p>
</p><pre class="jdocu_small"><span class="jdocu_small">simics&gt; <b>board.mb.phys_mem.write 0x250000004 0x20000</b></span></pre><p>
Now examine the register's value with print-device-regs:
</p><pre class="jdocu_small"><span class="jdocu_small">
simics&gt; <b>print-device-regs mydma DMA_source</b>
0x200
</span></pre><p>
</p><p>
Now that is unexpected! The value written, 0x20000, and the value in
the register, 0x200, does not match. This is because the device uses
<i>little endian</i> byte ordering and the sample machine is
<i>big endian</i>. This is because no byte order was specified in the
DML file and the default is little endian. Little
endian devices can (and do) exist on big endian machines, and vice
versa. To set the value of a little endian device's register add the
-l flag to the <b>write</b> command.
</p><pre class="jdocu_small"><span class="jdocu_small">
simics&gt; <b>board.mb.phys_mem.write 0x250000004 0x20000 -l</b>
simics&gt; <b>print-device-regs mydma DMA_source</b>
0x20000
</span></pre><p>
</p><p>
Assuming the device should actually be big endian it is a simple
matter to convert it. All that is required is to tell DML to use big
endian byte order.

</p><pre class="jdocu_small">import "utility.dml";
import "simics/devs/memory-space.dml";

param byte_order = "big-endian";

// Memory-space connection for DMA work
connect target_mem_space {
    param documentation =
        "The memory space on which the DMA engine operates. Data will be "
        + "read from and copied to the memory associated with this memory "
        + "space.";
    param configuration = "required";
    interface memory_space;
}

</pre><p>
</p><p>

</p><p>
Recompile the device and repeat the above steps.
</p><pre class="jdocu_small"><span class="jdocu_small">
project$ make
=== Building module "my_dma_device" ===
<i>[…]</i>



project$ <b>./simics ./targets/qsp-x86/firststeps.simics</b>
simics&gt; <b>c 2_000_000</b>
simics&gt; <b>@SIM_create_object("my_dma_device", "mydma", 
	        [["target_mem_space", conf.board.mb.phys_mem]])</b>

simics&gt; <b>board.mb.phys_mem.add-map mydma.bank.regs  0x250000000 0xc</b>
simics&gt; <b>board.mb.phys_mem.write 0x250000004 0x20000</b>
simics&gt; <b>print-device-regs mydma DMA_source</b>
0x20000
simics&gt; <b>board.mb.phys_mem.write 0x250000008 0x30000</b>
simics&gt; <b>print-device-regs mydma DMA_dest</b>
0x30000
</span></pre><p>
</p><p>
Now transfer 16 words of data by writing a control word to the DMA
device.
</p><pre class="jdocu_small"><span class="jdocu_small">
simics&gt; <b>mydma.log-level 4</b>
[mydma] Changing log level: 1 -&gt; 4
simics&gt; <b>$cw = 0x100000c0</b>
simics&gt; <b>board.mb.phys_mem.write 0x250000000 $cw</b>
[mydma info] Write to register regs.DMA_control &lt;- 0xc0000010
[mydma.bank.regs info] EN bit set, SWT written, initiating DMA
[mydma.bank.regs info] Transferring 16 32-bit words from 0x200 to 0x300
[mydma.bank.regs info] DMA transfer completed
simics&gt;
</span></pre><p>
</p><p>
Note that the first thing done is to raise the log-level of the DMA
device to 4 so that it is possible to track the execution path. Now
the basic DMA device is completed. The following sections will
demonstrate how to make the DMA transfer appear to take (virtual)
time, how to generate interrupts on completion and
how to use <i>layouts</i> to transfer data from a scatter-gather
list. The full source for the DMA device used throughout this section
is listed below.
</p><pre class="jdocu_small"><span class="jdocu_small">
dml 1.4;

device my_dma_device;
</span></pre><p>

</p><pre class="jdocu_small">
param desc = "example DMA device";

param documentation =
    "Example of a DMA device supporting contiguous memory or scatter-gather "
    + "lists. The device has a controllable throughput (words per second) "
    + "and supports either polling mode or interrupt based signalling upon "
    + "DMA completion.";

import "utility.dml";
import "simics/devs/memory-space.dml";

param byte_order = "big-endian";

// Memory-space connection for DMA work
connect target_mem_space {
    param documentation =
        "The memory space on which the DMA engine operates. Data will be "
        + "read from and copied to the memory associated with this memory "
        + "space.";
    param configuration = "required";
    interface memory_space;
}

bank regs {
    param register_size = 4;
    register DMA_control @ 0x00 "Control register";
    register DMA_source  @ 0x04 "Source address";
    register DMA_dest    @ 0x08 "Destination address";
}

// Read len bytes of target memory from the address src in the memory
// $target_mem_space. The result is put in memory pointed to by dst,
// which must be large enough to hold at least len bytes. If a memory
// access error occurs this method will print an error message and
// throw an exception.
method read_mem(void *dst,
                physical_address_t src,
                physical_address_t len) throws {
    local exception_type_t exc;
    exc = target_mem_space.memory_space.access_simple(dev.obj,
                                                src,
                                                dst,
                                                len,
                                                Sim_RW_Read,
                                                Sim_Endian_Target);

    if (exc != Sim_PE_No_Exception) {
        log error: "an error occurred when reading target memory";
        throw;
    }
}

// Write len bytes to target memory from the memory pointed to by
// src. The data is written to the memory space $target_mem_space at
// address dst. If a memory access error occurs this method will
// print an error message and throw an exception.
method write_mem(physical_address_t dst,
                 const void *src,
                 physical_address_t len) throws {
    local exception_type_t exc;
    exc = target_mem_space.memory_space.access_simple(dev.obj,
                                                dst,
                                                cast(src, uint8*),
                                                len,
                                                Sim_RW_Write,
                                                Sim_Endian_Target);

    if (exc != Sim_PE_No_Exception) {
        log error: "an error occurred when writing to target memory";
        throw;
    }
}

bank regs {
    register DMA_control {
        field EN   @ [31]  "Enable DMA";
        field SWT  @ [30]  "Software Transfer Trigger";
        field ECI  @ [29]  is (unimpl) "Enable Completion Interrupt";
        field TC   @ [28]  is (read_only)     "Transfer complete";
        field SG   @ [27]  is (unimpl) "Scatter-gather list input";
        field ERR  @ [26] "DMA transfer error";
        field TS   @ [15:0] "Transfer size (32-bit words)";

        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            default(value, enabled_bytes, aux);
            do_dma_transfer();
        }
    }

    method do_dma_transfer() {
        if (DMA_control.SWT.val == 0)
            return; // No need to do anything if we are not asked by software

        // Software asked us to initiate a DMA transfer
        if(DMA_control.EN.val == 0) {
            // enable bit not set, so we cannot transfer
            log info, 2: "EN bit not set, SWT = 1 has no effect";
            return;
        }

        log info, 3: "EN bit set, SWT written, initiating DMA";
        log info, 3: "Transferring %d 32-bit words from 0x%x to 0x%x",
            DMA_control.TS.val, DMA_source.val, DMA_dest.val;

        local uint18 count = DMA_control.TS.val * 4;
        try {
            // Copy the memory block
            local uint8 buf[count];
            read_mem(buf, DMA_source.val, count);
            write_mem(DMA_dest.val, buf, count);
        } catch {
            log error: "DMA memory access failed";
            return;
        }

        complete_dma();
    }

    method complete_dma() {
        // Log that completion is done
        log info, 2: "DMA transfer completed";

        // clear SWT bit, update TS
        DMA_control.SWT.val = 0;
        DMA_control.TS.val = 0;
        DMA_control.TC.val = 1;
    }
}
</pre><p>
</p><p>

</p><p>
</p><h2 class="jdocu"><a name="Simulating-Time">18.1 Simulating Time</a></h2>
<p>  Software
often expects operations such as DMA transfers to take some amount of
time. Some device drivers even rely on this in order to work
properly. In order to simulate the passage of time in a device it is
necessary to estimate how long an operation should take and to delay
the effects by that amount. The DMA device will use a simple algorithm
to compute the time a DMA transfer should take. The time will be
proportional to the number of words copied. The <code>after</code>
statement in DML is the easiest way to delay the call to
<b><i>complete_dma</i></b>. In this example the DMA device will appear to
transfer one million words per second since the delay is set to 1 ms
per word. The <code>after</code> statement posts an <em>event</em>, which
when executed calls the method <b><i>complete_dma</i></b>.
</p><p>

</p><pre class="jdocu_small">    method do_dma_transfer() {
        if (DMA_control.SWT.val == 0)
            return; // No need to do anything if we are not asked by software

        // Software asked us to initiate a DMA transfer
        if(DMA_control.EN.val == 0) {
            // enable bit not set, so we cannot transfer
            log info, 2: "EN bit not set, SWT = 1 has no effect";
            return;
        }

        log info, 3: "EN bit set, SWT written, initiating DMA";
        log info, 3: "Transferring %d 32-bit words from 0x%x to 0x%x",
            DMA_control.TS.val, DMA_source.val, DMA_dest.val;

        local uint18 count = DMA_control.TS.val * 4;
        try {
            // Copy the memory block
            local uint8 buf[count];
            read_mem(buf, DMA_source.val, count);
            write_mem(DMA_dest.val, buf, count);
        } catch {
            log error: "DMA memory access failed";
            return;
        }
        after 1.0e-6 * count / 4.0 s: complete_dma();
    }
</pre><p>
</p><p>

</p><p>
Test the device again
</p><p>



</p><pre class="jdocu_small"><span class="jdocu_small">
simics&gt; <b>c 2_000_000</b>
simics&gt; <b>@SIM_create_object("my_dma_device", "mydma",
	  [["target_mem_space", conf.board.mb.phys_mem],
	  ["queue", conf.board.mb.soc.cpu[0]]])</b>

simics&gt; <b>board.mb.phys_mem.add-map mydma.bank.regs  0x250000000 0xc</b>
Mapped 'mydma.bank.regs' in 'board.mb.phys_mem' at address 0x250000000.
simics&gt; <b>board.mb.phys_mem.write 0x250000004 0x20000</b>
simics&gt; <b>board.mb.phys_mem.write 0x250000008 0x30000</b>
simics&gt; <b>$cw = 0x100000c0</b>

simics&gt; <b>mydma.log-level 4</b>
[mydma] Changing log level: 1 -&gt; 4

simics&gt; <b>board.mb.phys_mem.write 0x250000000 $cw</b>
[mydma info] Write to register regs.DMA_control &lt;- 0xc0000010
[mydma.bank.regs info] EN bit set, SWT written, initiating DMA
[mydma.bank.regs info] Transferring 16 32-bit words from 0x200 to 0x300
</span></pre><p>
</p><p>
There are a few differences compared to the previous time the device
model was tested. First the <i>queue</i> attribute of the device
is set to the CPU. A <i>time queue</i> is required for a device that
post events.
If the <i>queue</i> attribute had not been set it had
been forced to the CPU anyway but an error message would have been
generated. The other difference is that the "DMA transfer completed"
message no longer appears. This is because the simulation is currently
not running and the DMA transfer is supposed to take some time.
</p><p>
It is possible to examine the event queue using the <b>peq</b>
command. It is possible to see that there is an event <i>complete_dma</i>
pending for the <b>mydma</b> object.
</p><pre class="jdocu_small"><span class="jdocu_small">
simics&gt; <b>peq</b>
┌──────────┬───────────────────┬─────────────────┐
│  Cycle   │      Object       │   Description   │
├──────────┼───────────────────┼─────────────────┤
│     32000│mydma              │regs.complete_dma│
│   1600000│board.mb.sb.uhci[0]│frame_update     │
│   1600000│board.mb.sb.uhci[1]│frame_update     │
│   1600000│board.mb.sb.uhci[2]│frame_update     │
│   1600000│board.mb.sb.uhci[3]│frame_update     │
│   1600000│board.mb.sb.uhci[4]│frame_update     │
│   1600000│board.mb.sb.uhci[5]│frame_update     │
│9371537749│board.mb.sb.lpc    │pm1_ovf          │
└──────────┴───────────────────┴─────────────────┘
</span></pre><p>
</p><p>
Continue the simulation for a few steps and the DMA transfer will
complete.
</p><pre class="jdocu_small"><span class="jdocu_small">
simics&gt; <b>c 220000</b>
[mydma.bank.regs info] DMA transfer completed
simics&gt;
</span></pre><p>
</p><p>
It is probably better to allow the user to determine the transfer rate
of the DMA device. This is easily accomplished by adding an attribute
for the transfer rate.
</p><p>

</p><pre class="jdocu_small">// Timing parameter
attribute throttle is double_attr {
    is init;
    method init() {
        val = 1e-6; // a really slow DMA device
    }

    param documentation =
        "Delay in seconds per 32-bit word of memory copied, default is 1μs.";
    param configuration = "optional";
}
</pre><p>
</p><p>

</p><p>
Then update the <code>after</code> line in <b><i>do_dma_transfer</i></b>
method to use this attribute to calculate the transfer delay.
</p><p>

</p><pre class="jdocu_small">        after throttle.val * count / 4.0 s: complete_dma();
</pre><p>
</p><p>

</p><p>
It is also a good idea to supply a reasonable default value for the
transfer rate. This can be done by instantiating the <code>init</code>
template and providing the <b><i>init</i></b> method, which
is called before all attributes are initialized by loading a
checkpoint or configuration.
</p><p>
Since DMA transfers now take some time, software will have to poll the
<i>TC</i> bit of the <i>DMA_control</i> register in order to
determine when the DMA transfer is done. This is inefficient and it
would be better if the DMA device could notify software that it is
done through some mechanism that does not require polling. The next
section will demonstrate how to improve the DMA device so that it will
interrupt the processor when the transfer is completed.
</p><p>

</p><h2 class="jdocu"><a name="Interrupting-on-Completion">18.2 Interrupting on Completion</a></h2>
<p>

To avoid the situation where software has to poll hardware during
lengthy operation interrupts can be used to notify software that an
interesting event has taken place. This section demonstrates how to
deliver an interrupt to a CPU core when DMA transfer is completed.
</p><p>
To be able to interrupt the CPU the device must have a connection to
it. The CPUs in Simics support the <code>signal</code> interface
that can be used to signal an interrupt. Add a new connection to the
device that should receive interrupts (this is not necessarily the CPU
core).
</p><p>

</p><pre class="jdocu_small">// CPU connection for interrupting
connect intr_target {
    param documentation =
        "Interrupt target port to signal on DMA interrupts.";
    param configuration = "required";
    interface signal;
}
</pre><p>
</p><p>

</p><p>
Once again it will be necessary to supply additional parameters when
instantiating the <b>mydma</b> object. This time the device's
<i>intr_target</i> attribute is set to
[conf.board.mb.cpu0.core[0][0], "EXTERNAL_INTERRUPT"],
connecting the <i>intr_target</i> connection to the external
interrupt port on the CPU.
</p><pre class="jdocu_small"><span class="jdocu_small">
simics&gt; <b>@SIM_create_object("my_dma_device", "mydma", 
          [["target_mem_space", conf.board.mb.phys_mem], 
          ["queue", conf.board.mb.cpu0.core[0][0]], 
          ["intr_target", [conf.board.mb.cpu0.core[0][0], "EXTERNAL_INTERRUPT"]]]
</b>
</span></pre><p>
</p><p>
Add a saved variable to keep track if an interrupt has been
raised or not.

</p><pre class="jdocu_small">// Tracks if interrupts are posted.
saved bool DMA_interrupt_posted;
</pre><p>
</p><p>

</p><p>
Next, add the code that will raise the interrupt once the transfer is
completed to the end of <b><i>complete_dma</i></b>.
</p><p>

</p><pre class="jdocu_small">
        DMA_control.TS.val = 0;
        DMA_control.TC.val = 1;

        // raise interrupt towards CPU
        if(DMA_control.ECI.val == 0) {
            log info, 3: "ECI is zero, no interrupt raised";
            return;
        }

        log info, 3: "raising interrupt signal";
        intr_target.signal.signal_raise();

        // remember that we raised it
        DMA_interrupt_posted = true;
</pre><p>
</p><p>

</p><p>
Now the device can interrupt the CPU to inform it that DMA transfer
has completed. However, once raised the signal will stay asserted
forever. The software needs a mechanism for acknowledging receipt of
the interrupt. This mechanism is implemented using the <i>TC</i>
(transfer complete) bit in this particular DMA device. First change
the <i>TC</i> field from read-only to read-write and then
implement its semantics in the <b><i>write</i></b> method. Since
interrupt functionality is now implemented also change the
<i>ECI</i> field from unimplemented.
</p><p>
</p><div class="note">
<b>Note:</b>
In order to make sure the update happens after all field writes,
<b><i>do_dma_transfer</i></b> is called in an override of the
<b><i>write_register</i></b> method. In order to retain the regular write
semantics of the register, <b><i>default</i></b> is also called.</div><pre class="jdocu_small">    register DMA_control {
        field EN   @ [31] "Enable DMA";
        field SWT  @ [30] "Software Transfer Trigger";
        field ECI  @ [29]  "Enable Completion Interrupt";
        field TC   @ [28] "Transfer complete" {
            // Set to 1 when transfer completed by device itself.
            // Clear by writing a zero.
            // If interrupts are enabled and interrupt status is one
            // also clear the interrupt in the processor.
            is write;
            method write(uint64 value) {
                if (value != 0) {
                    log spec_viol: "write one to TC - ignored";
                    return;
                }

                if (this.val == 0) // Already cleared
                    return;

                log info, 3: "write zero to TC - clearing TC";
                this.val = 0;

                if (!DMA_interrupt_posted)
                    return;

                log info, 3: "also clearing interrupt on CPU";
                DMA_interrupt_posted = false; // remember cleared
                intr_target.signal.signal_lower();
            }
        }
        field SG   @ [27]  is (unimpl) "Scatter-gather list input";
        field ERR  @ [26] "DMA transfer error";
        field TS   @ [15:0] "Transfer size (32-bit words)";
        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            default(value, enabled_bytes, aux);
            do_dma_transfer();
        }
</pre><p>
</p><p>

</p><p>
Now the DMA device is completed, except for the field <i>SG</i>
which is still marked as unimplemented. The next section will finalize
the DMA device by adding support for reading data from a
scatter-gather list when performing the copy operation.
</p><p>

</p><h2 class="jdocu"><a name="dma-scatter-gather">18.3 Supporting Scatter Gather Lists Using Layouts</a></h2>
<p>

This section will show how <i>layouts</i> can be used to help with
parsing descriptors that reside in target memory. A data structure
known as <i>scatter-gather</i> list will be traversed during DMA copy
operation. In a scatter-gather list data is spread out over several
<i>blocks</i>. These blocks can be of two types, data blocks and
extension blocks. A data block is simply a chunk of application
specific data while the extension blocks contains references to other
blocks. Extension blocks are always referenced from the last row in
another extension block.
An example of a scatter-gather data structure is shown in
Figure <a class="reference" href="#figsg-list">4</a>.
</p><p>
</p><div style="text-align: center">
<div class="figure" id="figsg-list">

<img alt="" src="sg-list.png">
<div class="caption">Figure 4. Scatter-gather list data structure.</div>
</div>

</div>
<p>
The layout of an extension block is shown in
Figure <a class="reference" href="#figsg-list-block">5</a>. The individual fields are
described below:
</p><p>
</p><dl><dt id="dt:address"><b>Address:</b></dt><dd>Pointer to a block.</dd><dt id="dt:length"><b>Length:</b></dt><dd>The length of valid data at address + offset.</dd><dt id="dt:offset"><b>Offset:</b></dt><dd>Data begins at address + offset</dd><dt id="dt:flags"><b>Flags:</b></dt><dd>Bit 0: If set address points to an extension
block. If not set address points to a data block.</dd></dl><p></p><div style="text-align: center">
<div class="figure" id="figsg-list-block">

<img alt="" src="sg-list-block.png">
<div class="caption">Figure 5. Scatter-gather list block descriptor.</div>
</div>

</div>
<p>
When using scatter-gather mode the <i>DMA_source</i> register
contains the address of a scatter-gather <i>head block</i>. The head
block is illustrated in Figure <a class="reference" href="#figsg-list-head">6</a>. The
head block points to the first scatter gather block, which is always
an extension block. The length field is the length of valid data in
the first extension block.
</p><p>
</p><div style="text-align: center">
<div class="figure" id="figsg-list-head">

<img alt="" src="sg-list-head.png">
<div class="caption">Figure 6. Scatter-gather list head descriptor.</div>
</div>

</div>
<p>
The first step towards supporting scatter-gather lists is to break out
the part of the code in <b><i>do_dma_transfer</i></b> that actually does the
copying and put that in a method of its own.
</p><p>

</p><pre class="jdocu_small">    method copy_contiguous(physical_address_t dst,
                          physical_address_t src,
                          uint18 count) throws {
        local uint8 buf[count];
        read_mem(buf, src, count);
        write_mem(dst, buf, count);
    }

</pre><p>
</p><p>

</p><p>
Next define two new layout types corresponding to the
descriptors. Note that "big-endian" byte order is used since the
target machine is big endian. Layouts makes it possible to conveniently
access target memory regardless of the host's and target's byte
order. Refer to the <i>DML Reference Manual</i> for more details on
layouts.
</p><p>

</p><pre class="jdocu_small">typedef layout "big-endian" {
    uint32 addr;
    uint16 len;
    uint16 reserved;
} sg_list_head_t;

typedef layout "big-endian" {
    uint32 addr;
    uint16 len;
    uint8 offset;
    bitfields 8 {
        uint1 ext @ [0:0];
    } flags;
} sg_list_block_row_t;
</pre><p>
</p><p>

</p><p>
Add a method that steps one step forward in the scatter-gather list,
either going to the next row of the current block or following an
extension block to the next block.

</p><pre class="jdocu_small">    // next_row - Returns the address to next row to be processed.
    // end_addr is the address after the end of the block, if this address
    // is reached the transaction should have finished
    method next_row(physical_address_t addr, physical_address_t end_addr)
        -&gt; (physical_address_t, physical_address_t,
            bool) throws /* next_addr, next_end_addr, finished */ {
        local physical_address_t next_addr;
        local physical_address_t next_end_addr;
        local bool finished;
        local sg_list_block_row_t block_row;
        read_mem(&amp;block_row, addr, sizeof block_row);
        if (block_row.flags.ext) {
            next_addr = block_row.addr + block_row.offset;
            next_end_addr = next_addr + block_row.len;
        } else {
            next_addr = addr + sizeof block_row;
            next_end_addr = end_addr;
        }
        finished = next_addr == end_addr;
        return (next_addr, next_end_addr, finished);
    }
</pre><p>
</p><p>

</p><p>
Now implement a new copy-method that copies data contained in a
scatter-gather list. This method should use the <b><i>next_row</i></b>
method to advance in the scatter-gather list. The method should return
the number of bytes copied so these can be used to set the delay.

</p><pre class="jdocu_small">    method copy_scatter_gather(physical_address_t dst, physical_address_t src)
        -&gt; (uint18) throws {
        local uint18 copied_bytes;
        // Get the header data
        local sg_list_head_t head;
        read_mem(&amp;head, src, sizeof head);
        copied_bytes = 0;

        local physical_address_t addr = head.addr;
        local physical_address_t end_addr = head.addr + head.len;

        // Continue running through the lists until the end is reached
        // or an error has been detected
        local sg_list_block_row_t row;
        local bool finished = false;
        while (!finished) {
            read_mem(&amp;row, addr, sizeof row);

            if (!row.flags.ext) { // Data block
                log info, 4: "Data block of length %d at 0x%x with offset %d",
                    row.len, row.addr, row.offset;
                // Copy a block of data
                copy_contiguous(dst, row.addr + row.offset, row.len);
                dst += row.len;
                copied_bytes += row.len;
            } else
                log info, 4:
                "Extension block of length %d at 0x%x with offset %d",
                    row.len, row.addr, row.offset;

            (addr, end_addr, finished) = next_row(addr, end_addr);

        }
        return copied_bytes;
    }

</pre><p>
</p><p>

</p><p>
Now it is a simple matter of calling <b><i>copy_scatter_gather</i></b>
or <b><i>copy_contiguous</i></b> depending on if the <i>SG</i> bit is set
in the control register. At the same time remove the unimplemented
template from the <i>SG</i> field.
</p><p>

</p><pre class="jdocu_small">        field SG   @ [27]  "Scatter-gather list input";
</pre><p>
</p><p>


</p><pre class="jdocu_small">    method do_dma_transfer() {
        if (DMA_control.SWT.val == 0)
            return; // No need to do anything if we are not asked by software

        // Software asked us to initiate a DMA transfer
        if(DMA_control.EN.val == 0) {
            // enable bit not set, so we cannot transfer
            log info, 2: "EN bit not set, SWT = 1 has no effect";
            return;
        }

        log info, 3: "EN bit set, SWT written, initiating DMA";
        log info, 3: "Transferring %d 32-bit words from 0x%x to 0x%x",
            DMA_control.TS.val, DMA_source.val, DMA_dest.val;

        local uint18 count = DMA_control.TS.val * 4;
        try {
            if (DMA_control.SG.val != 0) {
                log info, 4: "Scatter Gather Transfer";
                count = copy_scatter_gather(DMA_dest.val, DMA_source.val);
            } else {
                log info, 4: "Contiguous Transfer";
                copy_contiguous(DMA_dest.val, DMA_source.val, count);
            }
        } catch {
            log error: "DMA memory access failed";
            return;
        }

        after throttle.val * count / 4.0 s: complete_dma();
    }
</pre><p>
</p><p>

</p><p>
In the <b><i>copy_scatter_gather</i></b> method it is also a good idea to
implement checking for improperly set up lists that would make the
method end up in a loop, causing the simulation to get stuck in this loop.
In this case a good algorithm to use is one called the tortoise and the hare 
algorithm that uses two pointers that move through the list at
different speeds, the first moving twice as fast as the slower one.
If at any time the two pointers end up at the same address  a
loop has been found. If the faster moving pointer reaches the end this means
that there is no loop.
</p><p>
Set up some variables and change so that the stepping through the
list ends if an error has occurred.

</p><pre class="jdocu_small">        local physical_address_t addr = head.addr;
        local physical_address_t end_addr = head.addr + head.len;
        local physical_address_t hare_addr = addr;
        local physical_address_t hare_end_addr = end_addr;

        // Continue running through the lists until the end is reached
        // or an error has been detected
        local sg_list_block_row_t row;
        local bool finished = false;
        local bool hare_finished = false;
        while (!finished &amp;&amp; DMA_control.ERR.val == 0) {
            read_mem(&amp;row, addr, sizeof row);
</pre><p>
</p><p>

Check for loops and set the <i>ERR</i> flag if a loop is detected
causing the transfer to end.

</p><pre class="jdocu_small">            (addr, end_addr, finished) = next_row(addr, end_addr);

            // Check for loops.
            if (!hare_finished) {
                local int8 i;
                // Hare moves through lists at double the speed of addr.
                // If the hare ends up at the same address as addr, a loop has
                // been detected, if the hare reaches the end there is no loop.
                for (i = 0; i &lt; 2; i++) {
                    (hare_addr, hare_end_addr, hare_finished) = next_row(hare_addr, hare_end_addr);
                    if (hare_finished) {
                        log info, 4: "Loop checker finished, no loops";
                        break;
                    }
                }
                if (hare_addr == addr) {
                    log spec_viol: "Stuck in a loop.";
                    DMA_control.ERR.val = 1;
                }
            }
</pre><p>
</p><p>

</p><p>
The DMA device is now completed and the full source is listed below.
</p><p>
</p><pre class="jdocu_small"><span class="jdocu_small">
dml 1.4;

device my_dma_device;
</span></pre><p>

</p><pre class="jdocu_small">param desc = "example DMA device";

param documentation =
    "Example of a DMA device supporting contiguous memory or scatter-gather "
    + "lists. The device has a controllable throughput (words per second) "
    + "and supports either polling mode or interrupt based signalling upon "
    + "DMA completion.";

import "utility.dml";
import "simics/devs/memory-space.dml";
import "simics/devs/signal.dml";

typedef layout "big-endian" {
    uint32 addr;
    uint16 len;
    uint16 reserved;
} sg_list_head_t;

typedef layout "big-endian" {
    uint32 addr;
    uint16 len;
    uint8 offset;
    bitfields 8 {
        uint1 ext @ [0:0];
    } flags;
} sg_list_block_row_t;

param byte_order = "big-endian";

// Memory-space connection for DMA work
connect target_mem_space {
    param documentation =
        "The memory space on which the DMA engine operates. Data will be "
        + "read from and copied to the memory associated with this memory "
        + "space.";
    param configuration = "required";
    interface memory_space;
}

// CPU connection for interrupting
connect intr_target {
    param documentation =
        "Interrupt target port to signal on DMA interrupts.";
    param configuration = "required";
    interface signal;
}

// Timing parameter
attribute throttle is double_attr {
    is init;
    method init() {
        val = 1e-6;
    }
    param documentation =
        "Delay in seconds per 32-bit word of memory copied, default is 1μs.";
    param configuration = "optional";
}

bank regs {
    param register_size = 4;
    register DMA_control @ 0x00 "Control register";
    register DMA_source  @ 0x04 "Source address";
    register DMA_dest    @ 0x08 "Destination address";
}

// Tracks if interrupts are posted
saved bool DMA_interrupt_posted;

// Read len bytes of target memory from the address src in the memory
// $target_mem_space. The result is put in memory pointed to by dst,
// which must be large enough to hold at least len bytes. If a memory
// access error occurs, this method will print an error message and
// throw an exception.
method read_mem(void *dst,
                physical_address_t src,
                physical_address_t len) throws {
    local exception_type_t exc;
    exc = target_mem_space.memory_space.access_simple(dev.obj,
                                                src,
                                                dst,
                                                len,
                                                Sim_RW_Read,
                                                Sim_Endian_Target);

    if (exc != Sim_PE_No_Exception) {
        log error: "an error occurred when reading target memory";
        throw;
    }
}

// Write len bytes to target memory from the memory pointed to by
// src. The data is written to the memory space $target_mem_space at
// address dst. If a memory access error occurs this method will
// print an error message and throw an exception.
method write_mem(physical_address_t dst,
                 const void *src,
                 physical_address_t len) throws {
    local exception_type_t exc;
    exc = target_mem_space.memory_space.access_simple(dev.obj,
                                                dst,
                                                cast(src, uint8*),
                                                len,
                                                Sim_RW_Write,
                                                Sim_Endian_Target);

    if (exc != Sim_PE_No_Exception) {
        log error: "an error occurred when writing to target memory";
        throw;
    }
}

bank regs {
    register DMA_control {
        field EN   @ [31] "Enable DMA";
        field SWT  @ [30] "Software Transfer Trigger";
        field ECI  @ [29] "Enable Completion Interrupt";
        field TC   @ [28] "Transfer complete" {
            // Set to 1 when transfer completed by device itself.
            // Clear by writing a zero.
            // If interrupts are enabled and interrupt status is one
            // also clear the interrupt in the processor.
            is write;
            method write(uint64 value) {
                if (value != 0) {
                    log spec_viol: "write one to TC - ignored";
                    return;
                }

                if (this.val == 0) // Already cleared
                    return;

                log info, 3: "write zero to TC - clearing TC";
                this.val = 0;

                if (!DMA_interrupt_posted)
                    return;

                log info, 3: "also clearing interrupt on CPU";
                DMA_interrupt_posted = false; // remember cleared
                intr_target.signal.signal_lower();
            }
        }
        field SG   @ [27]   "Scatter-gather list input";
        field ERR  @ [26]   "DMA transfer error";
        field TS   @ [15:0] "Transfer size (32-bit words)";

        method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
            default(value, enabled_bytes, aux);
            do_dma_transfer();
        }
    }

    method do_dma_transfer() {
        if (DMA_control.SWT.val == 0)
            return; // No need to do anything if we are not asked by software

        // Software asked us to initiate a DMA transfer
        if(DMA_control.EN.val == 0) {
            // enable bit not set, so we cannot transfer
            log info, 2: "EN bit not set, SWT = 1 has no effect";
            return;
        }

        log info, 3: "EN bit set, SWT written, initiating DMA";
        log info, 3: "Transferring %d 32-bit words from 0x%x to 0x%x",
            DMA_control.TS.val, DMA_source.val, DMA_dest.val;

        local uint18 count = DMA_control.TS.val * 4;
        try {
            if (DMA_control.SG.val != 0) {
                log info, 4: "Scatter Gather Transfer";
                count = copy_scatter_gather(DMA_dest.val, DMA_source.val);
            } else {
                log info, 4: "Contiguous Transfer";
                copy_contiguous(DMA_dest.val, DMA_source.val, count);
            }
        } catch {
            log error: "DMA memory access failed";
            return;
        }

        after throttle.val * count / 4.0 s: complete_dma();
    }

    method copy_contiguous(physical_address_t dst,
                          physical_address_t src,
                          uint18 count) throws {
        local uint8 buf[count];
        read_mem(buf, src, count);
        write_mem(dst, buf, count);
    }

    // next_row - Returns the address to next row to be processed.
    // end_addr is the address after the end of the block, if this address
    // is reached the transaction should have finished
    method next_row(physical_address_t addr, physical_address_t end_addr)
        -&gt; (physical_address_t, physical_address_t,
            bool) throws /* next_addr, next_end_addr, finished */ {
        local physical_address_t next_addr;
        local physical_address_t next_end_addr;
        local bool finished;
        local sg_list_block_row_t block_row;
        read_mem(&amp;block_row, addr, sizeof block_row);
        if (block_row.flags.ext) {
            next_addr = block_row.addr + block_row.offset;
            next_end_addr = next_addr + block_row.len;
        } else {
            next_addr = addr + sizeof block_row;
            next_end_addr = end_addr;
        }
        finished = next_addr == end_addr;
        return (next_addr, next_end_addr, finished);
    }

    // Copy Scatter Gathered data.
    method copy_scatter_gather(physical_address_t dst, physical_address_t src)
        -&gt; (uint18) throws {
        local uint18 copied_bytes;
        // Get the header data
        local sg_list_head_t head;
        read_mem(&amp;head, src, sizeof head);
        copied_bytes = 0;

        local physical_address_t addr = head.addr;
        local physical_address_t end_addr = head.addr + head.len;
        local physical_address_t hare_addr = addr;
        local physical_address_t hare_end_addr = end_addr;

        // Continue running through the lists until the end is reached
        // or an error has been detected
        local sg_list_block_row_t row;
        local bool finished = false;
        local bool hare_finished = false;
        while (!finished &amp;&amp; DMA_control.ERR.val == 0) {
            read_mem(&amp;row, addr, sizeof row);

            if (!row.flags.ext) { // Data block
                log info, 4: "Data block of length %d at 0x%x with offset %d",
                    row.len, row.addr, row.offset;
                // Copy a block of data
                copy_contiguous(dst, row.addr + row.offset, row.len);
                dst += row.len;
                copied_bytes += row.len;
            } else
                log info, 4:
                "Extension block of length %d at 0x%x with offset %d",
                    row.len, row.addr, row.offset;

            (addr, end_addr, finished) = next_row(addr, end_addr);

            // Check for loops.
            if (!hare_finished) {
                local int8 i;
                // Hare moves through lists at double the speed of addr.
                // If the hare ends up at the same address as addr, a loop has
                // been detected, if the hare reaches the end there is no loop.
                for (i = 0; i &lt; 2; i++) {
                    (hare_addr, hare_end_addr, hare_finished) = next_row(hare_addr, hare_end_addr);
                    if (hare_finished) {
                        log info, 4: "Loop checker finished, no loops";
                        break;
                    }
                }
                if (hare_addr == addr) {
                    log spec_viol: "Stuck in a loop.";
                    DMA_control.ERR.val = 1;
                }
            }
        }
        return copied_bytes;
    }

    method complete_dma() {
        // Log that completion is done
        log info, 2: "DMA transfer completed";

        // clear SWT bit, update TS
        DMA_control.SWT.val = 0;
        DMA_control.TS.val = 0;
        DMA_control.TC.val = 1;

        // raise interrupt towards CPU
        if(DMA_control.ECI.val == 0) {
            log info, 3: "ECI is zero, no interrupt raised";
            return;
        }

        log info, 3: "raising interrupt signal";
        intr_target.signal.signal_raise();

        // remember that we raised it
        DMA_interrupt_posted = true;
    }
}
</pre><p>
</p><p>


</p><p>
</p>
<div class="chain">
<a href="modeling-interrupt-controllers.html">17 Modeling Interrupt Controllers</a>
<a href="modeling-i2c-devices.html">19 Modeling I2C Devices</a>
</div>