<!doctype html>
<head>
<meta charset="utf-8">
<title>3 Device Modeling Language, version 1.4</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="running-dmlc.html">2 The DML compiler</a>
<a href="dml-builtins.html">4 Libraries and Built-ins</a>
</div>
<div class="path">
<a href="index.html">Device Modeling Language 1.4 Reference Manual</a>
&nbsp;/&nbsp;</div>
<h1 id="device-modeling-language-version-1-4">3 <a href="#device-modeling-language-version-1-4">Device Modeling Language, version 1.4</a></h1>
<p>This chapter describes the Device Modeling Language (DML), version 1.4. It will
help to have read and understood the object model in the previous
chapter before reading this chapter.</p>
<h2 id="overview">3.1 <a href="#overview">Overview</a></h2>
<p>DML is not a general-purpose programming language, but a modeling
language, targeted at writing Simics device models. The algorithmic part
of the language is similar to ISO C; however, the main power
of DML is derived from its simple object-oriented constructs for
defining and accessing the static data structures that a device model
requires, and the automatic creation of bindings to Simics.</p>
<p>Furthermore, DML provides syntax for <em>bit-slicing</em>, which much simplifies the
manipulation of bit fields in integers; <a href="#new-expressions"><code>new</code></a> and
<a href="#delete-statements"><code>delete</code></a> operators for allocating and deallocating
memory; a basic <a href="#try-statements"><code>try</code></a>/<a href="#throw-statements"><code>throw</code></a> mechanism
for error handling; built-in <a href="#log-statements"><code>log</code></a> and
<a href="#assert-statements"><code>assert</code></a> statements; and a powerful metaprogramming
facility using <a href="#templates"><em>templates</em></a> and <a href="#in-each-declarations"><em>in each
statements</em></a>.</p>
<p>Most of the built-in Simics-specific logic is implemented directly in
DML, in standard library modules that are automatically imported; the
<code>dmlc</code> compiler itself contains as little knowledge as possible
about the specifics of Simics.</p>
<h2 id="lexical-structure">3.2 <a href="#lexical-structure">Lexical Structure</a></h2>
<p>A major difference from C is that names do not generally need to
be defined before their first use. This is quite useful, but might
sometimes appear confusing to C programmers.</p>
<dl><dt id="dt:character-encoding">
<p>Character encoding</p>
</dt><dd>
<p>DML source files are written using UTF-8 encoding.  Non-ASCII characters are
only allowed in comments and in string literals.  Unicode BiDi control
characters (U+2066 to U+2069 and U+202a to U+202e) are not allowed.  String
values are still handled as byte arrays, which means that a string value
written with a literal of three characters may actually create an array of more
than three bytes.  </p></dd><dt id="dt:reserved-words"><p></p>
<p>Reserved words</p>
</dt><dd>
<p>All ISO/ANSI C reserved words are reserved words in DML (even if
currently unused). In addition, the C99 and C++ reserved words
<code>restrict</code>, <code>inline</code>, <code>this</code>, <code>new</code>,
<code>delete</code>, <code>throw</code>, <code>try</code>, <code>catch</code>, and
<code>template</code> are also reserved in DML. The C++ reserved words
<code>class</code>, <code>namespace</code>, <code>private</code>,
<code>protected</code>, <code>public</code>, <code>using</code>, and
<code>virtual</code>, are reserved in DML for future use; as are
identifiers starting with an underscore (<code>_</code>).</p>
<p>The following words are reserved specially by DML: <code>after</code>,
<code>assert</code>, <code>call</code>, <code>cast</code>, <code>defined</code>, <code>each</code>,
<code>error</code>, <code>foreach</code>, <code>in</code>, <code>is</code>,
<code>local</code>, <code>log</code>, <code>param</code>, <code>saved</code>, <code>select</code>,
<code>session</code>, <code>shared</code>, <code>sizeoftype</code>, <code>typeof</code>, <code>undefined</code>,
<code>vect</code>, <code>where</code>, <code>async</code>, <code>await</code>,
<code>with</code>, and <code>stringify</code>.</p>
</dd><dt id="dt:identifiers">
<p>Identifiers</p>
</dt><dd>
<p>Identifiers in DML are defined as in C; an identifier may begin
with a letter or underscore, followed by any number of letters,
numbers, or underscores. Identifiers that begin with an underscore (<code>_</code>)
are reserved by the DML language and standard library and should not
be used.</p>
</dd><dt id="dt:constant-literals">
<p>Constant Literals</p>
</dt><dd>
<p>DML has literals for strings, characters, integers, booleans, and
floating-point numbers.  The integer literals can be written in
decimal (<code>01234</code>), hexadecimal (<code>0x12af</code>), or binary
(<code>0b110110</code>) form.</p>
<p>Underscores (<code>_</code>) can be used between digits, or immediately
following the <code>0b</code>, <code>0x</code> prefixes, in integer literals
to separate groups of digits for improved readability. For example,
<code>123_456</code>, <code>0b10_1110</code>, <code>0x_eace_f9b6</code> are valid
integer constants, whereas <code>_78</code>, <code>0xab_</code> are not.</p>
<p>String literals are surrounded by double quotes (<code>"</code>). To
include a double quote or a backslash (<code>\</code>) in a string
literal, precede them with a backslash (<code>\"</code> and <code>\\</code>,
respectively). Newline, carriage return, tab and backspace characters
are represented by <code>\n</code>, <code>\r</code>, <code>\t</code> and
<code>\b</code>. Arbitrary byte values can be encoded as <code>\x</code>
followed by exactly two hexadecimal digits, such as <code>\x1f</code>.
Such escaped byte values are restricted to 00-7f for strings
containing Unicode characters above U+007F.</p>
<p>Character literals consist of a pair of single quotes (<code>'</code>)
surrounding either a single printable ASCII character or one of the
escape sequences <code>\'</code>, <code>\\</code>, <code>\n</code>, <code>\r</code>,
<code>\t</code> or <code>\b</code>. The value of a character literal is
the character's ASCII value.</p>
</dd><dt id="dt:comments">
<p>Comments</p>
</dt><dd>
<p>C-style comments are used in DML.  This includes both in-line
comments (<code>/*</code>...<code>*/</code>) and comments
that continue to the end of the line (<code>//</code>...).</p>
</dd></dl>
<h2 id="module-system">3.3 <a href="#module-system">Module System</a></h2>
<p>DML employs a very simple module system, where a <em>module</em> is any source file
that can be imported using the <a href="#import-declarations"><code>import</code> directive</a>.
Such files may not contain a [<code>device</code> declaration], but otherwise look like
normal DML source files. The imported files are merged into the main model
as if all the code was contained in a single file (with some exceptions). This
is similar to C preprocessor <code>#include</code> directives, but in DML each imported
file must be possible to parse in isolation, and may contain declarations (such
as <a href="#bitorder-declarations"><code>bitorder</code></a>) that are only effective for that file.
Also, DML imports are automatically idempotent, in the sense that importing the
same file twice does not yield any duplicate definitions.</p>
<p>The import hierarchy has semantic significance in DML: If a module
defines some method or parameter declarations that can be overridden,
then <em>only</em> files that explicitly import the module are allowed
to override these declarations. It is however sufficient to import the
module indirectly via some other module. For instance, if A.dml
contains a default declaration of a method, and B.dml wants to
override it, then B.dml must either import A.dml, or some file C.dml
that in turn imports A.dml. Without that import, it is an error to
import both A.dml and B.dml in the same device.</p>
<h2 id="source-file-structure">3.4 <a href="#source-file-structure">Source File Structure</a></h2>
<p>A DML source file describes both the structure of the modeled device and
the actions to be taken when the device is accessed.</p>
<p>A DML source file defining a device starts with a <em>language version declaration</em>
and a <em>device declaration</em>. After that, any number of <em>parameter declarations</em>,
<em>methods</em>, <em>data fields</em>, <em>object declarations</em>, or <em>global declarations</em> can be
written. A DML file intended to be <em>imported</em> (by an <a href="#import-declarations"><code>import</code>
statement</a> in another DML file) has the same layout except
for the device declaration.</p>
<h3 id="language-version-declaration">3.4.1 <a href="#language-version-declaration">Language Version Declaration</a></h3>
<p>Every DML source file should contain a version declaration, on the form
<code>dml 1.4;</code>. The version
declaration allows the <code>dmlc</code> compiler to select the proper
versions of the DML parser and standard libraries to be used for the
file. A file can not
import a file with a different language version than its own.</p>
<p>The version declaration must be the first declaration in the file,
possibly preceded by comments. For example:</p>
<pre><code>// My Device
dml 1.4;
...
</code></pre>
<h3 id="device-declaration">3.4.2 <a href="#device-declaration">Device Declaration</a></h3>
<p>Every DML source file that contains a device declaration is a <em>DML model</em>, and
defines a Simics device class with the specified name. Such a file may <em>import</em>
other files, but only the initial file may contain a device declaration.</p>
<p>The device declaration must be the first proper declaration in the file,
only preceded by comments and the language version declaration. For
example:</p>
<pre><code>/*
 *  My New Device
 */
dml 1.4;
device my_device;
...
</code></pre>
<h2 id="the-object-model">3.5 <a href="#the-object-model">The Object Model</a></h2>
<p>DML is structured around an <em>object model</em>, where each DML model
describes a single <em>device object</em>, which can contain a number of
<em>member objects</em>. Each member object can in its turn have a number of
members of its own, and so on in a nested fashion.</p>
<p>Every object (including the device itself) can also have
<a href="#methods-brief"><em>methods</em></a>, which implement the functionality of the object,
and <a href="#parameters"><em>parameters</em></a>, which are members that describe static
properties of the object.</p>
<p>Each object is of a certain <em>object type</em>, e.g., <code>bank</code> or
<code>register</code>. There is no way of adding user-defined object types in
DML; however, each object is in general locally modified by adding (or
overriding) members, methods and parameters - this can be viewed as
creating a local one-shot subtype for each object.</p>
<p>A DML model can only be instantiated as a whole: Individual
objects can not be instantiated standalone; instead, the whole
hierarchy of objects is instantiated atomically together with the model. This
way, it is safe for sibling objects in the hierarchy to assume each
other's existence, and any method can freely access state from any
part of the object hierarchy.</p>
<p>Another unit of instantiation in DML is the <em>template</em>. A template
contains a reusable block of code that can be instantiated in an
object, which can be understood as expanding the template's code into
the object.</p>
<p>Many parts of the DML object model are automatically mapped onto the
Simics <em>configuration object</em> model; most importantly, the device
object maps to a Simics configuration class, such that configuration
objects of that class correspond to instances of the DML model, and
the attribute and interface objects of the DML model map to Simics
attributes and interfaces associated with the created Simics
configuration class (See <em>Simics Model Builder User's Guide</em> for
details.)</p>
<h3 id="device-structure">3.5.1 <a href="#device-structure">Device Structure</a></h3>
<p>A device is made up of a number of member objects and methods, where any object
may contain further objects and methods of its own. Many object types only make
sense in a particular context and are not allowed elsewhere:</p>
<ul>
<li>
<p>There is exactly one <a href="#the-device"><code>device</code></a> object. It resides on the top
level.</p>
</li>
<li>
<p>Objects of type <a href="#register-banks"><code>bank</code></a>, <a href="#ports"><code>port</code></a> or
<a href="#subdevices"><code>subdevice</code></a> may only appear as part of a <code>device</code> or
<code>subdevice</code> object.</p>
</li>
<li>
<p>Objects of type <a href="#implements"><code>implement</code></a> may only appear as part of a
<code>device</code>, <code>port</code>, <code>bank</code>, or <code>subdevice</code> object.</p>
</li>
<li>
<p>Objects of type <a href="#registers"><code>register</code></a> may only appear as part of a <code>bank</code>.</p>
</li>
<li>
<p>Objects of type <a href="#fields"><code>field</code></a> may only appear as part of a <code>register</code>.</p>
</li>
<li>
<p>Objects of type <a href="#connects"><code>connect</code></a> may only appear as part of a <code>device</code>,
<code>subdevice</code>, <code>bank</code>, or <code>port</code> object.</p>
</li>
<li>
<p>Objects of type <a href="#interfaces"><code>interface</code></a> may only appear directly below a
<code>connect</code> object.</p>
</li>
<li>
<p>Objects of type <a href="#attributes"><code>attribute</code></a> may only appear as part of a
<code>device</code>, <code>bank</code>, <code>port</code>, <code>subdevice</code>, or <code>implement</code> object.</p>
</li>
<li>
<p>Objects of type <a href="#events"><code>event</code></a> may appear anywhere <strong>except</strong> as part of a
<code>field</code>, <code>interface</code>, <code>implement</code>, or another <code>event</code>.</p>
</li>
<li>
<p>Objects of type <a href="#groups"><code>group</code></a> are neutral: Any object may contain a
<code>group</code> object, and a <code>group</code> object may contain any object that its parent
object may contain, with the exception that a <code>group</code> cannot contain an
object of type <code>interface</code> or <code>implement</code>.</p>
</li>
</ul>
<h3 id="parameters">3.5.2 <a href="#parameters">Parameters</a></h3>
<p>Parameters (shortened as "<code>param</code>") are a kind of object members that <em>describe
expressions</em>. During compilation, any parameter reference will be expanded to
the definition of that parameter. In this sense, parameters are similar to
macros, and indeed have some usage patterns in common - in particular,
parameters are typically used to represent constant expressions.</p>
<p>Like macros, no type declarations are necessary for parameters, and every usage
of a parameter will re-evaluate the expression. Unlike macros, any parameter
definition must be a syntactically valid expression, and every unfolded
parameter expression is always evaluated using the scope in which the
parameter was defined, rather than the scope in which the parameter is
referenced.</p>
<p>Parameters cannot be dynamically updated at run-time; however, a parameter
can be declared to allow it being overridden by later definitions -
see <a href="#parameter-declarations">Parameter Declarations</a>.</p>
<p>Within DML's built-in modules and standard library, parameters are used to
describe static properties of objects, such as names, sizes, and offsets. Many
of these are overridable, allowing some properties to be configured by users.
For example, every bank object has a <code>byte_order</code> parameter that controls the
byte order of registers within that bank. By default, this parameter is defined
to be <code>"little-endian"</code> - but by overriding it, users may specify the byte
order on a bank-by-bank basis.</p>
<h3 id="methods">3.5.3 <a href="#methods">Methods</a></h3>
<a id="methods-brief">
<p>Methods are object members providing implementation of the functionality of the
object. Although similar to C functions, DML methods can have any number of
input parameters and return values. DML methods also support a basic exception
handling mechanism using <code>throw</code> and <code>try</code>.</p>
</a><p><a id="methods-brief"></a><a href="#methods-detailed">In-detail description of method declarations are covered in a separate
section.</a></p>
<h3 id="the-device">3.5.4 <a href="#the-device">The Device</a></h3>
<p>The <em>device</em> defined by a DML model corresponds
directly to a Simics <em>configuration object</em>, i.e., something
that can be included in a Simics configuration.</p>
<p>In DML's object hierarchy, the device object is represented by the
top-level scope.</p>
<p>The DML file passed to the DML compiler must <em>start</em> with a <code>device</code>
declaration following the language version specification:</p>
<pre>dml 1.4;
device <em>name</em>;
</pre>
<p>A <code>device</code> declaration may not appear anywhere else, neither in the
main file or in imported files. Thus, the device declaration is
limited to two purposes:</p>
<ul>
<li>to give a <em>name</em> to the configuration class registered with Simics</li>
<li>to declare which DML file is the top-level file in a DML model</li>
</ul>
<h3 id="register-banks">3.5.5 <a href="#register-banks">Register Banks</a></h3>
<p>A <em>register bank</em> (or simply <em>bank</em>) is an abstraction that is used to
group <em>registers</em> in DML, and to expose these to the outside
world. Registers are exposed to the rest of the simulated system
through the Simics interface <code>io_memory</code>, and exposed to scripting and
user interfaces through the <code>register_view</code>, <code>register_view_read_only</code>
and <code>bank_instrumentation_subscribe</code> Simics interfaces.</p>
<p>It is possible to define <em>bank arrays</em> to model a row of similar banks. Each
element in the bank array is a separate configuration object in Simics, and can
thus be individually mapped in a memory space.</p>
<p>Simics configuration objects for bank instances are named like the bank but
with a <code>.bank</code> prefix. For instance, if a device model has a declaration <code>bank regs[i &lt; 2]</code> on top level, and a device instance is named <code>dev</code> in Simics, then
the two banks are represented in Simics by configuration objects named
<code>dev.bank.regs[0]</code> and <code>dev.bank.regs[1]</code>.</p>
<h3 id="registers">3.5.6 <a href="#registers">Registers</a></h3>
<p>A <em>register</em> is an object that contains an integer value. Normally, a register
corresponds to a segment of consecutive locations in the address space of the
bank; however, it is also possible (and often useful) to have registers that are
not mapped to any address within the bank. All registers must be part of a
register bank.</p>
<p>Every register has a fixed <em>size</em>, which is
an integral, nonzero number of 8-bit bytes. A single register cannot
be wider than 8 bytes. The size of the register is given by the
<code>size</code> parameter,
which can be specified either by a normal parameter assignment, as in</p>
<pre><code>register r1 {
    param size = 4;
    ...
}
</code></pre>
<p>or, more commonly, using the following short-hand syntax:</p>
<pre><code>register r1 size 4 {
    ...
}
</code></pre>
<p>which has the same meaning. The default size is provided by the
<code>register_size</code>
parameter of the containing register bank, if that is defined.</p>
<p>There are multiple ways to manipulate the value of a register: the simplest
approach is to make use of the <code>val</code> member of registers, as in:</p>
<pre><code>log info: "the value of register r1 is %d", r1.val;
</code></pre>
<p>or</p>
<pre><code>++r1.val;
</code></pre>
<p>For more information, see Section
<a href="dml-builtins.html#register-objects">Register Objects</a>.</p>
<h4 id="mapping-addresses-to-registers">3.5.6.1 <a href="#mapping-addresses-to-registers">Mapping Addresses To Registers</a></h4>
<p>For a register to be mapped into the internal address space of the
containing bank, its starting address within the bank must be given by
setting the
<code>offset</code>
parameter. The address range occupied by the register is then from
<code>offset</code> to <code>offset</code> + <code>size</code> - 1. The offset
can be specified by a normal parameter assignment, as in</p>
<pre><code>register r1 {
    param offset = 0x0100;
    ...
}
</code></pre>
<p>or using the following short-hand syntax:</p>
<pre><code>register r1 @ 0x0100 {
    ...
}
</code></pre>
<p>similar to the <code>size</code> parameter above. Usually, a normal
read/write register does not need any additional specifications apart
from the size and offset, and can simply be written like this:</p>
<pre><code>register r1 size 4 @ 0x0100;
</code></pre>
<p>or, if the bank contains several registers of the same size:</p>
<pre><code>bank b1 {
    param register_size = 4;
    register r1 @ 0x0100;
    register r2 @ 0x0104;
    ...
}
</code></pre>
<p>The translation from the bank address space to the actual value of the
register is controlled by the <code>byte_order</code> parameter. When it is set to
<code>"little-endian"</code> (the default), the lowest address, i.e., that
defined by <code>offset</code>, corresponds to the least significant byte in
the register, and when set to <code>"big-endian"</code>, the lowest address
corresponds to the most significant byte in the register.</p>
<h4 id="not-mapping-addresses-to-registers">3.5.6.2 <a href="#not-mapping-addresses-to-registers">Not Mapping Addresses To Registers</a></h4>
<p>An important thing to note is that registers do not have to be mapped at all.
This may be useful for internal registers that are not directly accessible from
software. By using an unmapped register, you can get the advantages of using
register, such as automatic checkpointing and register fields. This internal
register can then be used from the implementations of other registers, or other
parts of the model.</p>
<p>Historically, unmapped registers were commonly used to store simple device
state, but this usage is no longer recommended —
<a href="#saved-variables">Saved Variables</a> should be preferred if possible.
Unmapped registers should only be used if saved variables do not fit a
particular use case.</p>
<p>To make a register unmapped, set the offset to <code>unmapped_offset</code>
or use the standard template <code>unmapped</code>:</p>
<pre><code>register r is (unmapped);
</code></pre>
<h4 id="register-attributes">3.5.6.3 <a href="#register-attributes">Register Attributes</a></h4>
<p>For every register, an attribute of integer type is automatically added
to the Simics configuration class generated from the device model. The
name of the attribute corresponds to the hierarchy in the DML model;
e.g., a register named <code>r1</code> in a bank named <code>bank0</code> will
get a corresponding attribute named <code>bank0_r1</code>.</p>
<p>The register value is automatically saved when Simics creates a checkpoint,
unless the <code>configuration</code> parameter indicates otherwise.</p>
<p>The value of a register is stored in a member named <code>val</code>. E.g., the <code>r1</code>
register will store its value in <code>r1.val</code>. This is normally the value that is
saved in checkpoints; however, checkpointing is defined by the <code>get</code> and <code>set</code>
methods, so if they are overridden, then some other value can be saved instead.</p>
<h4 id="fields">3.5.6.4 <a href="#fields">Fields</a></h4>
<p>Real hardware registers often have a number of <em>fields</em> with
separate meaning. For example, the lowest three bits of the register
could be a status code, the next six bits could be a set of flags, and
the rest of the bits could be reserved.</p>
<p>To make this easy to express, a <code>register</code> object can
contain a number of <code>field</code> objects. Each field is defined
to correspond to a bit range of the containing register.</p>
<p>The value of a field is stored in the corresponding bits of the containing
register's storage. The easiest way to access the value of a register or field
is to use the <code>get</code> and <code>set</code> methods.</p>
<p>The read and write behaviour of registers and fields is in most cases
controlled by instantiating <em>templates</em>. There are three
categories of templates:</p>
<ul>
<li>
<p>Registers and fields where a read or write just updates the
value with no side-effects, should use the <code>read</code>
and <code>write</code> templates, respectively.</p>
</li>
<li>
<p>Custom behaviour can be supplied by instantiating
the <code>read</code> or <code>write</code> template. The template leaves
a simple method <code>read</code> (or <code>write</code>) abstract;
custom behaviour is provided by overriding the method. There is
also a pair of templates <code>read_bits</code>
and <code>write_bits</code>, which similarly provide abstract
methods <code>read_bits</code> and <code>write_bits</code>. These
functions have some extra parameters, making them less convenient
to use, but they also offer some extra information about the
access.</p>
</li>
<li>
<p>There are many pre-defined templates with for common specialized
behaviour. The most common ones are <code>unimpl</code>, for registers
or fields whose behaviour has not yet been implemented,
and <code>read_only</code> for registers or fields that cannot be
written.</p>
</li>
</ul>
<p>A register or field can often instantiate two templates, one for reads
and one for writes; e.g., <code>read</code> to supply a read method
manually, and <code>read_only</code> to supply a standard write method. If
a register with fields instantiates a read or write template, then the
register will use that behaviour <em>instead</em> of descending into
fields. For instance, if a register instantiates
the <code>read_only</code> template, then all writes will be captured, and
only reads will descend into its fields.</p>
<p>The register described above could be modeled as follows,
using the default little-endian bit numbering.</p>
<pre><code>bank b2 {
    register r0 size 2 @ 0x0000 {
        field status @ [2:0];
        field flags @ [8:3];
        field reserved @ [15:9];
    }
    ...
}
</code></pre>
<p>Note that the most significant bit number is always the first number (to
the left of the colon) in the range, regardless of whether little-endian
or big-endian bit numbering is used. (The bit numbering convention used
in a source file can be selected by a <code>bitorder</code>
declaration.)</p>
<p>The value of the field can be accessed by using the <code>get</code>
and <code>set</code> methods, e.g.:</p>
<pre><code>log info: "the value of the status field is %d", r0.status.get();
</code></pre>
<h3 id="attributes">3.5.7 <a href="#attributes">Attributes</a></h3>
<p>An <a href="dml-builtins.html#attribute-objects"><code>attribute</code> object</a> in DML represents a
Simics configuration object attribute of the device. As mentioned above, Simics
attributes are created automatically for <a href="#registers"><code>register</code></a> and
<a href="#connects"><code>connect</code></a> objects to allow external inspection and modification;
explicit <code>attribute</code> objects can be used to expose additional data. There are
mainly three use cases for explicit attributes:</p>
<ul>
<li>
<p>Exposing a parameter for the end-user to configure or
tweak. Such attributes can often be <em>required</em> in order to
instantiate a device, and they usually come with documentation.</p>
</li>
<li>
<p>Exposing internal device state, required for checkpointing to work correctly.
Most device state is usually saved in registers or saved variables, but
attributes may sometimes be needed to save non-trivial state such as FIFOs.</p>
</li>
<li>
<p>Attributes can also be created as synthetic back-doors for
additional control or inspection of the device. Such attributes
are called <em>pseudo attributes</em>, and are not saved in
checkpoints.</p>
</li>
</ul>
<p>An attribute is basically a name with an associated pair of <code>get</code> and <code>set</code>
functions. The type of the value read and written through the get/set functions
is controlled by the <code>type</code> parameter. More information about configuration
object attributes can be found in <em>Simics Model Builder User's Guide</em>.</p>
<p>The <a href="dml-builtins.html#init"><code>init</code></a> template and associated method is often
useful together with <code>attribute</code> objects to initialize any associated state.</p>
<p>Four standard templates are provided for attributes: <code>bool_attr</code>, <code>int64_attr</code>,
<code>uint64_attr</code> and <code>double_attr</code>. They provide overridable <code>get</code> and <code>set</code>
methods, and store the attribute's value in a session variable named <code>val</code>,
using the corresponding type. For example, if <code>int64_attr</code> is used in the
attribute <code>a</code>, then one can access it as follows:</p>
<pre><code>log info: "the value of attribute a is %d", dev.a.val;
</code></pre>
<p>These templates also provide an overridable implementation of
<a href="dml-builtins.html#init"><code>init()</code></a> that initializes the <code>val</code> session variable.
The value that <code>val</code> is initialized to is controlled by the <code>init_val</code>
parameter, whose default definition simply causes <code>val</code> to be zero-initialized.</p>
<p>Defining <code>init_val</code> is typically the most convenient way of initializing any
attribute instantiating any one of the these templates — however,
overriding the default <code>init()</code> implementation with a custom one may still be
desirable in certain cases. In particular, the definition of <code>init_val</code> must be
constant, so a custom <code>init()</code> implementation is necessary if <code>val</code> should be
initialized to a non-constant value.</p>
<p>Note that using an attribute object purely to store and checkpoint simple
internal device state is not recommended; prefer
<a href="#saved-variables">Saved Variables</a> for such use cases.</p>
<h3 id="connects">3.5.8 <a href="#connects">Connects</a></h3>
<p>A <a href="dml-builtins.html#connect-objects"><code>connect</code> object</a>
is a container for a reference to an
arbitrary Simics configuration object. An attribute with the same name
as the connect is added to the Simics configuration class generated
from the device model. This attribute can be assigned a value of type
"Simics object".</p>
<p>A <code>connect</code> declaration is very similar to a simple
<code>attribute</code> declaration, but specialized to handle
connections to other objects.</p>
<p>Typically, the connected object is expected to implement one or more
particular Simics interfaces, such as <code>signal</code>
or <code>ethernet_common</code> (see
<em>Simics Model Builder User's Guide</em> for details). This is described
using <code>interface</code> declarations inside the
<code>connect</code>.</p>
<p>Initialization of the connect (i.e., setting the object reference) is
done from outside the device, usually in a Simics configuration
file. Just like other attributes, the parameter
<code>configuration</code> controls whether the value must
be initialized when the object is created, and whether it is
automatically saved when a checkpoint is created.</p>
<p>The actual object pointer, which is of type
<code>conf_object_t*</code> is stored in a <code>session</code>
member called <code>obj</code>.  This means that to access the current
object pointer in a connect called <em>otherdev</em>, you need to
write <code>otherdev.obj</code>.</p>
<p>If the <code>configuration</code> parameter is not <code>required</code>,
the object pointer may have a null value, so any code that tries to
use it must check if it is set first.</p>
<p>This is an example of how a connect can be declared and used:</p>
<pre><code>connect plugin {
    param configuration = "optional";
}

method mymethod() {
    if (plugin.obj)
        log info: "The plugin is connected";
    else
        log info: "The plugin is not connected";
}
</code></pre>
<h4 id="interfaces">3.5.8.1 <a href="#interfaces">Interfaces</a></h4>
<p>In order to use the Simics interfaces that a connected object
implements, they must be declared within the <code>connect</code>.
This is done through <a href="dml-builtins.html#interface-objects"><code>interface</code> objects</a>.
These name the expected interfaces and may also specify additional properties.</p>
<p>An important property of an interface object is whether or not a
connected object is <em>required</em> to implement the interface. This
can be controlled through the interface parameter <code>required</code>,
which is <code>true</code> by default. Attempting to connect an object
that does not implement the required interfaces will cause a runtime
error. The presence of optional interfaces can be verified by testing
if the <code>val</code> member of the interface object has a null
value.</p>
<p>By default, the C type of the Simics interface corresponding to a
particular interface object is assumed to be the name of the object
itself with the string <code>"_interface_t"</code> appended. (The C type is
typically a <code>typedef</code>:ed name for a struct containing function
pointers).</p>
<p>The following is an example of a connect with two interfaces, one of
which is not required:</p>
<pre><code>connect plugin {
    interface serial_device;
    interface rs232_device { param required = false; }
}
</code></pre>
<p>Calling interface functions is done in the same way as any C function
is called, but the first argument which is the target object
pointer is omitted.</p>
<p>The <code>serial_device</code> used above has a function with the
following definition:</p>
<pre><code>int (*write)(conf_object_t *obj, int value);
</code></pre>
<p>This interface function is called like this in DML:</p>
<pre><code>method call_write(int value) {
    local int n = plugin.serial_device.write(value);
    // code to check the return value omitted
}
</code></pre>
<h3 id="implements">3.5.9 <a href="#implements">Implements</a></h3>
<p>When a device needs to export a Simics interface, this is specified by an
<code>implement</code> object, containing the methods that implement
the interface. The name of the object is also used as the name of the
Simics interface registered for the generated device, and the names and
signatures of the methods must correspond to the C functions of the
Simics interface. (A device object pointer is automatically added as the
first parameter of the generated C functions.)</p>
<p>In most cases, a device exposes interfaces by adding <code>implement</code> object as
subobjects of named <a href="#ports"><code>port</code> objects</a>. A port object often represents a
hardware connection</p>
<p>The C type of the Simics interface is assumed to be the
value of the object's <code>name</code> parameter (which defaults to the name of
the object itself), with the string <code>"_interface_t"</code> appended.  The C
type is typically a <code>typedef</code>:ed name for a struct containing function
pointers.</p>
<p>For example, to implement the <code>ethernet_common</code> Simics interface, we can write:</p>
<pre><code>implement ethernet_common {
    method frame(const frags_t *frame, eth_frame_crc_status_t crc_status) {
        ...
    }
}
</code></pre>
<p>This requires that <code>ethernet_common_interface_t</code> is defined as a struct type
with a field <code>frame</code> with the function pointer type
<code>void (*)(conf_object_t *, const frags_t *, eth_frame_crc_status_t)</code>.</p>
<p>Definitions of all standard Simics interface types are available as DML files named like the corresponding C header files;
for instance, the <code>ethernet_common</code> interface can be imported as follows:</p>
<pre><code>import "simics/devs/ethernet.dml"
</code></pre>
<h3 id="events">3.5.10 <a href="#events">Events</a></h3>
<p>An <em>event</em> object is an encapsulation of a Simics event that can
be posted on a processor time or step queue. The location of event
objects in the object hierarchy of the device is not important, so an
event object can generally be placed wherever it is most convenient.</p>
<p>An event has a built-in <code>post</code> method, which inserts the
event in the default queue associated with the device. An event also
defines an abstract method <code>event</code>, which the user must
implement. That method is called when the event is triggered.</p>
<p>An event must instantiate one of six predefined
templates: <code>simple_time_event</code>, <code>simple_cycle_event</code>,
<code>uint64_time_event</code>, <code>uint64_cycle_event</code>,
<code>custom_time_event</code> or <code>custom_cycle_event</code>. The choice
of template affects the signature of the <code>post</code>
and <code>event</code> methods: In a time event, the delay is specified
as a floating-point value, denoting number of seconds, while in a
cycle event, the delay is specified in CPU cycles.</p>
<p>A posted event may have data associated with it. This data is given to
the <code>post</code> method and is provided to the <code>event</code>
callback method. They type of data depends on the template used: No
data is provided in simple events, and in uint64 events it is provided
as a uint64 parameter. In custom events, data is provided as
a <code>void *</code> parameter, and extra
methods <code>get_event_info</code> <code>set_event_info</code>
and <code>destroy</code> must be provided in order to provide proper
checkpointing of the event.</p>
<h3 id="groups">3.5.11 <a href="#groups">Groups</a></h3>
<p>Objects of type <code>attribute</code>, <code>connect</code>, <code>event</code>, <code>field</code>, <code>register</code>, <code>bank</code>,
<code>port</code> and <code>subdevice</code> can be organized into <em>groups</em>. A group is a neutral
object, which can be used just for namespacing, or to help structuring an array
of a collection of objects. Groups may appear anywhere, but are most commonly
used to group registers: If a bank has a sequence of blocks, each containing
the same registers, it can be written as a group array. In the following
example eight homogeneous groups of registers are created, resulting in
8×6 instances of register <code>r3</code>.</p>
<pre><code>bank regs {
    param register_size = 4;
    group blocks[i &lt; 8] {
        register r1 @ i * 32 + 0;
        register r2 @ i * 32 + 4;
        register r3[j &lt; 6] @ i * 32 + 8 + j * 4;
    }
}
</code></pre>
<p>Another typical use of <code>group</code> is in combination with a
template for the group that contains common registers and
more that are shared between several groups, as in the following
example.</p>
<pre><code>template weird {
    param group_offset;
    register a size 4 @ group_offset is (read, write);
    register b size 4 @ group_offset + 4 is (read, write) {
        method read() -&gt; (uint64) {
            // When register b is read, return a
            return a.val;
        }
    }
}

bank regs {
    group block_a is (weird) { param group_offset = 128; }
    group block_b is (weird) { param group_offset = 1024; }
}
</code></pre>
<p>In addition, groups can be nested.</p>
<pre><code>bank regs {
    param register_size = 4;
    group blocks[i &lt; 8] {
        register r1 @ i * 52 + 0;
        group sub_blocks[j &lt; 4] {
            register r2 @ i * 52 + j * 12 + 4;
            register r3[k &lt; 3] @ i * 52 + j * 12 + k * 4 + 8;
        }
    }
}
</code></pre>
<p>Banks, ports and subdevices can be placed inside groups; in this case, the
Simics configuration object that represents the bank, port or subdevice will be
placed under a namespace object; for instance, if a device with <code>group g { bank regs; }</code> is instantiated as <code>dev</code>, then the bank is represented by an object
<code>dev.g.bank.regs</code>, where <code>g</code> and <code>bank</code> are both <code>namespace</code> objects.</p>
<p>As groups have no special properties or restrictions, they can be used as a tool
for building abstractions — in particular in combination with templates.</p>
<p>For example, a template can be used to create an abstraction for finite state
machine objects, by letting users create FSMs by declaring group objects
instantiating that template. FSM states can also be represented through a
template instantiated by groups.</p>
<p>The following demonstrates a simple example of how such an abstraction may be
implemented:</p>
<pre><code>// Template for finite state machines
template fsm is init {
    saved fsm_state curr_state;

    // The initial FSM state.
    // Must be defined by any object instantiating this template.
    param init_fsm_state : fsm_state;

    shared method init() default {
        curr_state = init_fsm_state;
    }

    // Execute the action associated to the current state
    shared method action() {
        curr_state.action();
    }
}

// Template for states of an FSM. Such states must be sub-objects
// of an FSM.
template fsm_state {
    param parent_fsm : fsm;
    param parent_fsm = cast(parent, fsm);

    // The action associated to this state
    shared method action();

    // Transitions the parent FSM to this state
    shared method set() {
        parent_fsm.curr_state = cast(this, fsm_state);
    }
}
</code></pre>
<p>These templates can then be used as follows:</p>
<pre><code>group main_fsm is fsm {
    param init_fsm_state = cast(init_state, fsm_state);

    group init_state is fsm_state {
        method action() {
          log info: "init_state -&gt; second_state";
          // Transition to second_state
          second_state.set();
        }
    }

    group second_state is fsm_state {
        method action() {
          log info: "second_state -&gt; final_state";
          // Transition to final_state
          final_state.set();
        }
    }

    group final_state is fsm_state {
        method action() {
            log info: "in final_state";
        }
    }
}

method trigger_fsm() {
    // Execute the action of main_fsm's current state.
    main_fsm.action();
}
</code></pre>
<h3 id="ports">3.5.12 <a href="#ports">Ports</a></h3>
<p>An interface port is a structural element that groups implementations
of one or more interfaces. When one configuration object connects to
another, it can connect to one of the target object's ports, using the
interfaces in the port. This way, the device model can expose
different interfaces to different objects.</p>
<p>Sometimes a port is as simple as a single pin, implementing
the <code>signal</code> interface, and sometimes it can be more complex,
implementing high-level communication interfaces.</p>
<p>It is also possible to define port arrays that are indexed
with an integer parameter, to model a row of similar connectors.</p>
<p>In Simics, a port is represented by a separate configuration object, named like
the port but with a <code>.port</code> prefix. For instance, if a device model has a
declaration <code>port p[i&lt;2]</code> on top level, and a device instance is named <code>dev</code> in
Simics, then the two ports are represented in Simics by objects named
<code>dev.port.p[0]</code> and <code>dev.port.p[1]</code>.</p>
<h3 id="subdevices">3.5.13 <a href="#subdevices">Subdevices</a></h3>
<p>A subdevice is a structural element that represents a distinct subsystem of the
device. Like a <code>group</code>, a subdevice can be used to group a set of related
banks, ports and attributes, but a subdevice is presented to the end-user as a
separate configuration object. If a subdevice contains <code>attribute</code> or <code>connect</code>
objects, or <code>saved</code> declarations, then the corresponding configuration
attributes appears as members of the subdevice object rather than the device.</p>
<h2 id="templates">3.6 <a href="#templates">Templates</a></h2>
<pre>template <em>name</em> { ... }
</pre>
<p>Defines a <em>template</em>, a piece of code that can be reused in
multiple locations. The body of the template contains a number of
declarations that will be added to any object that uses the template.</p>
<p>Templates are imported into an object declaration body using
<code>is</code> statements, written as</p>
<pre>is <em>name</em>;
</pre>
<p>for example:</p>
<pre><code>field F {
    is A;
}
</code></pre>
<p>It is also possible to use templates when declaring an object, as in</p>
<pre>field F is (<em>name1</em>, <em>name2</em>);
</pre>
<p>These can be used in any context where an object declaration may be written, and
has the effect of expanding the body of the template at the point of the <code>is</code>.
Using <code>is</code> together with object declarations is typically more idiomatic than
the standalone <code>is</code> object statement; however, the latter is useful in order
to instantiate templates in the top-level device object, and also for use in
conjunction with <a href="#in-each-declarations"><code>in each</code> declarations</a>; for example:</p>
<pre><code>register r {
    in each field {
        is A;
    }

    field F1 @ [7:6];
    ...
}
</code></pre>
<p>If two templates define methods or parameters with the same name, then the
template instantiation hierarchy is used to deduce which method overrides the
other: If one template <em>B</em> instantiates another template <em>A</em>, directly or
indirectly, then methods from <em>B</em> override methods from <em>A</em>. Note, however, that
overrides can only happen on methods and parameters that are declared <code>default</code>.
Example:</p>
<pre><code>template A {
    method hello() default {
        log info: "hello";
    }
}
template B is A {
    // this method overrides the
    // method from A
    method hello() default {
        default();
        log info "world";
    }
}
</code></pre>
<p>See <a href="#resolution-of-overrides">Resolution of Overrides</a> for a formal
specification of override rules.</p>
<h3 id="templates-as-types">3.6.1 <a href="#templates-as-types">Templates as types</a></h3>
<p>Each template defines a <em>type</em>, which is similar to a class
in an object oriented language like Java. The type allows you to
store references to a DML object in a variable. Some, but not all,
top-level declarations inside a template appear as members of the template type.
A template type has the following members:</p>
<ul>
<li>
<p>All <a href="#session-variables">session</a> and <a href="#saved-variables">saved</a> variables
declared within the template. E.g., the declaration <code>session int val;</code> gives a
type member <code>val</code>.</p>
</li>
<li>
<p>All declarations of typed parameters, further discussed below.
E.g., the declaration <code>param foo : uint64;</code> gives a type member <code>foo</code>.</p>
</li>
<li>
<p>All method declarations declared with the <code>shared</code> keyword,
further discussed below. E.g., the declaration
<code>shared method fun() { ... }</code>
gives a type member <code>fun</code>, which can be called.</p>
</li>
<li>
<p>All type members of inherited templates. E.g., the declaration
<code>is simple_time_event;</code>
adds two type members <code>post</code> and <code>next</code>, since
<code>post</code> and <code>next</code> are members of
the <code>simple_time_event</code> template type.</p>
</li>
</ul>
<p>Template members are dereferenced using the <code>.</code> operator,
much like struct members.</p>
<p>A template's type is named like the template, and an object
reference can be converted to a value using the <code>cast</code>
operator.  For instance, a reference to the
register <code>regs.r0</code> can be created and used as follows
(all register objects automatically implement the template <code>register</code>):</p>
<pre><code>local register x = cast(regs.r0, register);
x.val = 14;  // sets regs.r0.val
</code></pre>
<p>Two values of the same template type can be compared for equality, and are
considered equal when they both reference the same object.</p>
<p>A value of a template type can be upcast to an ancestor template type; for
example:</p>
<pre><code>local uint64_attr x = cast(attr, uint64_attr);
local attribute y = cast(x, attribute);
</code></pre>
<p>In addition, a value of any template type can be cast to the template type
<code>object</code>, even if <code>object</code> is not an ancestor of the template.</p>
<h3 id="shared-methods">3.6.2 <a href="#shared-methods">Shared methods</a></h3>
<p>If a method is declared in a template, then one copy of the method
will appear in each object where the template is instantiated;
therefore, the method can access all methods and parameters of that
object. This is often convenient, but comes with a cost; in
particular, if a template is instantiated in many objects, then this
gives unnecessarily large code size and slow compilation. To address
this problem, a method can be declared <em>shared</em> to operate on
the template type rather than the implementing object. The
implementation of a shared method is compiled once and shared between
all instances of the template, rather than duplicated between
instances.</p>
<p>Declaring a method as shared imposes restrictions on its
implementation, in particular which symbols it is permitted to access:
Apart from symbols in the global scope, a shared method may only
access members of the template's type; it is an error to access any
other symbols defined by the template. Members can be referenced
directly by name, or as fields of the automatic <code>this</code>
variable.  When accessed in the scope of the shared method's body,
the <code>this</code> variable evaluates to a value whose type is the
template's type.</p>
<p>Example:</p>
<pre><code>template base {
    // abstract method: must be instantiated in sub-template or object
    shared method m(int i) -&gt; (int);
    shared method n() -&gt; (int) default { return 5; }
}
template sub is base {
    // override
    shared method m(int i) -&gt; (int) default {
        return i + this.n();
    }
}
</code></pre>
<p>If code duplication is not a concern, it is possible to define a shared method
whose implementation is not subject to above restrictions while still retaining
the benefit of having the method be a member of the template type.
This is done by defining the implementation separately from the declaration
of the shared method, for example:</p>
<pre><code>template get_qname {
    shared method get_qname() -&gt; (const char *);
    method get_qname() -&gt; (const char *) {
        // qname is an untyped parameter, and would thus not be accessible
        // within a shared implementation of get_qname()
        return this.qname;
    }
}
</code></pre>
<h3 id="typed-parameters">3.6.3 <a href="#typed-parameters">Typed Parameters</a></h3>
<p>A <em>typed parameter declaration</em> is a parameter declaration form that may only
appear within templates:</p>
<pre>param <em>name</em> : <em>type</em>;
</pre>
<p>A typed parameter declaration adds a member to the template type with the same
name as the specified parameter, and with the specified type. That member is
associated with the specified parameter, in the sense that the definition of the
parameter is used as the value of the template type member.</p>
<p>A typed parameter declaration places a number of requirements on the
named parameter:</p>
<ul>
<li>
<p>The named parameter must be defined (through a regular <a href="#parameter-declarations">parameter
declaration</a>). This can be done either within the
template itself, within sub-templates, or within individual objects
instantiating the template.</p>
</li>
<li>
<p>The parameter definition must be a valid expression of the specified type.</p>
</li>
<li>
<p>The parameter definition must be free of side-effects, and must not rely on
the specific device instance of the DML model — in particular, the
definition must be independent of device state.</p>
<p>This essentially means that the definition must be a constant expression,
except that it may also make use of device-independent expressions whose
values are known to be constant. For example, index parameters, <a href="#each-in-expressions"><code>each</code>-<code>in</code>
expressions</a>, and object references cast to template
types are allowed. It is also allowed to reference other parameters that obey
this rule.</p>
<p>Examples of expressions that may <em>not</em> be used include method calls and
references to <code>session</code>/<code>saved</code> variables.</p>
</li>
<li>
<p>The parameter definition must not contain calls to
<a href="#independent-methods">independent methods</a>.</p>
</li>
</ul>
<p>Typed parameters are most often used to allow a shared method defined within
the template to access parameters of the template. For example:</p>
<pre><code>template max_val_reg is write {
    param max_val : uint64;

    shared method write(uint64 v) {
        if (v &gt; max_val) {
            log info: "Ignoring write to register exceeding max value %u",
                      max_val;
        } else {
            default(v);
        }
    }
}

bank regs {
    register reg[i &lt; 2] size 8 @0x0 + i*8 is max_val_reg {
        param max_val = 128 * (i + 1) - 1;
    }
}
</code></pre>
<h2 id="parameter-declarations">3.7 <a href="#parameter-declarations">Parameter Declarations</a></h2>
<p>A parameter declaration has the general form "<code>param <em>name</em>
<em>specification</em>;</code>", where <em><code>specification</code></em> is
either "<code>= <em>expr</em></code>" or "<code>default <em>expr</em></code>".
For example:</p>
<pre><code>param offset = 8;
param byte_order default "little-endian";
</code></pre>
<p>A default value is overridden by an assignment (<code>=</code>). There can
be at most one assignment for each parameter.
Typically, a default value for a parameter is specified in a
template, and the programmer may then choose to override it where the
template is used.</p>
<p>The <em><code>specification</code></em> part is in fact optional; if omitted, it means that the
parameter is declared to exist (and <em>must</em> be given a value, or the model will
not compile). This is sometimes useful in templates, as in:</p>
<pre><code>template constant is register {
    param value;
    method get() -&gt; (uint64) {
        return value;
    }
}
</code></pre>
<p>so that wherever the template <code>constant</code> is used, the programmer
is also forced to define the parameter <code>value</code>. E.g.:</p>
<pre><code>register r0 size 2 @ 0x0000 is (constant) {
    param value = 0xffff;
}
</code></pre>
<p>Note that simply leaving out the parameter declaration from the template
definition can have unwanted effects if the programmer forgets to
specify its value where the template is used. At best, it will only
cause a more obscure error message, such as "unknown identifier"; at
worst, the scoping rules will select an unrelated definition of the same
parameter name.</p>
<p>Also note that a parameter declaration without definition is redundant if a
<a href="#typed-parameters">typed parameter declaration</a> for that parameter already
exists, as that already enforces that the parameter must be defined.</p>
<div class="note">
<p><strong>Note:</strong> You may see the following special form in some standard library files:</p>
<pre>param <em>name</em> auto;
</pre>
<p>for example,</p>
<pre><code>param parent auto;
</code></pre>
<p>This is used to explicitly declare the built-in automatic parameters,
and should never be used outside the libraries.</p>
</div>
<h2 id="data-types">3.8 <a href="#data-types">Data types</a></h2>
<p>The type system in DML builds on the type system in C, with a few
modifications.  There are eight kinds of data types.  New names for
types can also be assigned using a <code>typedef</code> declaration.</p>
<dl><dt id="dt:integers">
<p>Integers</p>
</dt><dd>
<p>Integer types guarantee a certain <em>minimum</em> bit width and
may be signed or unsigned.  The basic integer types are
named <code>uint1</code>,
<code>uint2</code>, ..., <code>uint64</code> for the unsigned types, and
<code>int1</code>, <code>int2</code>, ..., <code>int64</code> for the signed
types. Note that the size of the integer type is only a hint and the
type is guaranteed to be able to hold at least that many
bits. Assigning a value that would not fit into the type is
undefined, thus it is an error to assume that values will be
truncated. For bit-exact types, refer to <code>bitfields</code>
and <code>layout</code>.</p>
<p>The familiar integer types <code>char</code> and <code>int</code> are
available as aliases for <code>int8</code> and <code>int32</code>,
respectively. The C keywords <code>short</code>, <code>signed</code>, <code>unsigned</code>
and <code>long</code> are reserved words in DML and not allowed in type
declarations.  The types <code>size_t</code> and <code>uintptr_t</code> are
defined as in C.</p>
</dd><dt id="dt:endian-integers">
<p>Endian integers</p>
</dt><dd>
<p>Endian integer types hold similar values as
integer types, but in addition have the following attributes:</p>
<ul>
<li>
<p><em>They are guaranteed to be stored in the exact number of bytes
required for their bitsize, without padding.</em></p>
</li>
<li>
<p><em>They have a defined byte order.</em></p>
</li>
<li>
<p><em>They have a natural alignment of 1 byte.</em></p>
</li>
</ul>
<p>Endian integer types are named after the integer type
with which they share a bitsize and sign but in addition
have a <code>_be_t</code> or <code>_le_t</code> suffix, for big-endian
and little-endian integers, respectively. The full list of endian types is:</p>
<!-- A markdown table would have been nice here, but that's currently (2021)
too poorly rendered (SIMICS-18374) -->
<pre><code>int8_be_t    int8_le_t    uint8_be_t    uint8_le_t
int16_be_t   int16_le_t   uint16_be_t   uint16_le_t
int24_be_t   int24_le_t   uint24_be_t   uint24_le_t
int32_be_t   int32_le_t   uint32_be_t   uint32_le_t
int40_be_t   int40_le_t   uint40_be_t   uint40_le_t
int48_be_t   int48_le_t   uint48_be_t   uint48_le_t
int56_be_t   int56_le_t   uint56_be_t   uint56_le_t
int64_be_t   int64_le_t   uint64_be_t   uint64_le_t
</code></pre>
<p>These types can be transparently
used interchangeably with regular integer types, values of one
type will be coerced to the other as needed. Note that operations
on integers will always produce regular integer types, even
if all operands are of endian integer type.</p>
</dd><dt id="dt:floating-point-numbers">
<p>Floating-point numbers</p>
</dt><dd>
<p>There is only one floating-point type, called <code>double</code>.
It corresponds to the C type <code>double</code>.</p>
</dd><dt id="dt:booleans">
<p>Booleans</p>
</dt><dd>
<p>The boolean type <code>bool</code> has two values, <code>true</code> and
<code>false</code>.</p>
</dd><dt id="dt:arrays">
<p>Arrays</p>
</dt><dd>
<p>An array is a sequence of elements of another type, and works as
in C.</p>
</dd><dt id="dt:pointers">
<p>Pointers</p>
</dt><dd>
<p>Pointers to types, work as in C. String literals have the
type <code>const char *</code>. A pointer has undefined meaning
if the pointer target type is an integer whose bit-width is neither 8,
16, 32, nor 64.</p>
</dd><dt id="dt:structures">
<p>Structures</p>
</dt><dd>
<p>A <code>struct</code> type defines a composite type that contains
named members of different types.  DML makes no assumptions about the
data layout in struct types, but see the layout types below for that.
Note that there is no struct label as in C, and struct member declarations
are permitted to refer to types that are defined further down in the file.
Thus, new struct types can always be declared using the following syntax:</p>
<pre>typedef struct { <em>member declarations</em> } <em>name</em>;
</pre>
</dd><dt id="dt:layouts">
<p>Layouts</p>
</dt><dd>
<p>A layout is similar to a struct in many ways.  The important
difference is that there is a well-defined mapping between a layout
object and the underlying memory representation, and layouts may
specify that in great detail.</p>
<p>A basic layout type looks like this:</p>
<pre><code>layout "big-endian" {
    uint24 x;
    uint16 y;
    uint32 z;
}
</code></pre>
<p>By casting a pointer to a piece of host memory to a pointer of this
layout type, you can access the fourth and fifth byte as a 16-bit
unsigned integer with big-endian byte order by simply writing
<code>p-&gt;y</code>.</p>
<p>The allowed types of layout members in a layout type declaration
are integers, endian integers, other layout types,
bitfields (see below), and arrays of these.</p>
<p>The byte order declaration is mandatory, and is
either <code>"big-endian"</code> or <code>"little-endian"</code>.</p>
<p>Access of layout members do not always provide a value of the
type used for the member in the declaration. Bitfields and
integer members (and arrays of similar) are translated
to endian integers (or arrays of such) of similar size,
with endianness matching the layout. Layout and endian integer
members are accessed normally.</p>
</dd><dt id="dt:bitfields">
<p>Bitfields</p>
</dt><dd>
<p>A bitfield type works similar to an integer type where you use bit
slicing to access individual bits, but where the bit ranges are
assigned names. A <code>bitfields</code> declaration looks like this:</p>
<pre><code>bitfields 32 {
    uint3  a @ [31:29];
    uint16 b @ [23:8];
    uint7  c @ [7:1];
    uint1  d @ [0];
}
</code></pre>
<p>The bit numbering is determined by the <code>bitorder</code> declaration
in the current file.</p>
<p>Accessing bit fields is done as with a struct or layout, but the whole
bitfield can also be used as an unsigned integer. See the following
example:</p>
<pre><code>local bitfields 32 { uint8 x @ [7:0] } bf;
bf = 0x000000ff;
bf.x = bf.x - 1;
local uint32 v = bf;
</code></pre>
</dd></dl>
<h3 id="serializable-types">3.8.1 <a href="#serializable-types">Serializable types</a></h3>
<p><em>Serializable types</em> are types that the DML compiler knows how to serialize and
deserialize for the purposes of checkpointing. This is important for the use of
<a href="#saved-variables"><code>saved</code> variables</a> and the <a href="#after-statements"><code>after</code>
statement</a>.</p>
<p>All primitive non-pointer data types (integers, floating-point types, booleans,
etc.) are considered serializable, as is any struct, layout, or array type
consisting entirely of serializable types. <a href="#templates-as-types">Template types</a>
are also considered serializable.</p>
<p>Any type not fitting the above criteria is not considered serializable:
in particular, any pointer type is not considered serializable, nor is any
<a href="#typedef-declarations"><code>extern</code></a> struct type; the latter is because it's
impossible for the compiler to ensure it's aware of all members of the struct
type.</p>
<h2 id="methods-2">3.9 <a href="#methods-2">Methods</a></h2>
<a id="methods-detailed">
</a><p><a id="methods-detailed">Methods are similar to C functions, but also have an implicit
(invisible) parameter which allows them to refer to the current device
instance, i.e., the Simics configuration object representing the device.
Methods also support exception handling in DML, using <code>try</code> and
<code>throw</code>. The body of the method is a compound statement in an
</a><a href="#comparison-to-c">extended subset of C</a>.
It is an error to have more than one method declaration using the same
name within the same scope.</p>
<h3 id="input-parameters-and-return-values">3.9.1 <a href="#input-parameters-and-return-values">Input Parameters and Return Values</a></h3>
<p>A DML method can have any number of return values, in contrast to C
functions which have at most one return value. DML methods do not use
the keyword <code>void</code> — an empty pair of parentheses always
means "zero parameters". Furthermore, lack of return value can even be
omitted. Apart from this, the parameter declarations of a method are
ordinary C-style declarations.</p>
<p>For example,</p>
<pre><code>method m1() -&gt; () {...}
</code></pre>
<p>and</p>
<pre><code>method m1() {...}
</code></pre>
<p>are equivalent, and define a method that takes no input parameters and
returns nothing.</p>
<pre><code>method m2(int a) -&gt; () {...}
</code></pre>
<p>defines a method that takes a single input parameter, and also returns
nothing.</p>
<pre><code>method m3(int a, int b) -&gt; (int) {
    return a + b;
}
</code></pre>
<p>defines a method with two input parameters and a single return value.
A method that has a return value must end with a return statement.</p>
<pre><code>method m4() -&gt; (int, int) {
    ...;
    return (x, y);
}
</code></pre>
<p>has no input parameters, but two return values.</p>
<p>A method that can throw an exception must declare so, using
the <code>throws</code> keyword:</p>
<pre><code>method m5(int x) -&gt; (int) throws {
    if (x &lt; 0)
        throw;
    return x * x;
}
</code></pre>
<h3 id="default-methods">3.9.2 <a href="#default-methods">Default Methods</a></h3>
<p>A parameter or method can now be overridden more than once.</p>
<p>When there are multiple declarations of a parameter, then the template
and import hierarchy are used to deduce which declaration to use: A
declaration that appears in a block that instantiates a template will
override any declaration in that template, and a declaration that
appears in a file that imports another file will override any
declaration from that file. The declarations of one parameter must
appear so that one declaration overrides all other declarations of he
parameter; otherwise the declaration is considered ambiguous and an
error is signalled.</p>
<p>Examples: A file <code>common.dml</code> might contain:</p>
<pre><code>param num_banks default 2;
bank banks[num_banks] {
    ...
}
</code></pre>
<p>Your device <code>my-dev.dml</code> can then contain:</p>
<pre><code>device my_dev;
import "common.dml";
// overrides the declaration in common.dml
param num_banks = 4;
</code></pre>
<p>The assignment in <code>my-dev.dml</code> takes precedence,
because <code>my-dev.dml</code> imports <code>common.dml</code>.</p>
<p>Another example: The following example gives an compile error:</p>
<pre><code>template my_read_constant {
    param value default 0;
    ...
}
template my_write_constant {
    param value default 0;
    ...
}
bank b {
    // ERROR: Two declarations exist, and neither takes precedence
    register r is (my_read_constant, my_write_constant);
}
</code></pre>
<p>The conflict can be resolved by declaring the parameter a third time,
in a location that overrides both the conflicting declarations:</p>
<pre><code>bank b {
    register r is (my_read_constant, my_write_constant) {
        param value default 0;
    }
}
</code></pre>
<p>Furthermore, an assignment (<code>=</code>) of a parameter may not be
overridden by another declaration.</p>
<p>If more than one declaration of a method appears in the same object,
then the template and import hierarchies are used to deduce the
override order. This is done in a similar way to how parameters are
handled:</p>
<ul>
<li>
<p>A method declaration that appears in a block that instantiates a
template will override any declaration from that template</p>
</li>
<li>
<p>A method declaration that appears in a file that imports another
file will override any declaration from that file.</p>
</li>
<li>
<p>The declarations of one method must appear so that one
declaration overrides all other declarations of the method; otherwise
the declaration is considered ambiguous and an error is signalled.</p>
</li>
<li>
<p>A method can only be overridden by another method if it is declared
<code>default</code>.</p>
</li>
</ul>
<div class="note">
<p><strong>Note:</strong> An overridable built-in method is defined by a template
named as the object type. So, if you want to write a template that
overrides the <code>read</code> method of a register, and want to make
your implementation overridable, then your template must explicitly
instantiate the <code>register</code> template using a statement <code>is register;</code>.</p>
</div>
<h3 id="calling-methods">3.9.3 <a href="#calling-methods">Calling Methods</a></h3>
<p>In DML, a method call looks much like in C, with some exceptions. For instance,</p>
<pre><code>(a, b) = access(...);
</code></pre>
<p>calls the method 'access' in the same object, assigning the return values to
variables <code>a</code> and <code>b</code>.</p>
<p>If one method overrides another, it is possible to refer to the overridden
method from within the body of the overriding method using the identifier
<code>default</code>:</p>
<pre><code>x = default(...);
</code></pre>
<p>DML supports <em>compound initializer syntax</em> for the arguments of called methods,
meaning arguments of struct-like types can be constructed using
<tt>{<em>...</em>}</tt>. For example:</p>
<pre><code>typedef struct {
    int x;
    int y;
} struct_t;

method copy_struct(struct_t *tgt, struct_t src) {
    *tgt = src
}

method m() {
    local struct_t s;
    copy_struct(&amp;s, {1, 4});
    copy_struct(&amp;s, {.y = 1, .x = 4});
    copy_struct(&amp;s, {.y = 1, ...}); // Partial designated initializer
}
</code></pre>
<p>This syntax can't be used for variadic arguments or <a href="#inline-methods">inline
arguments</a>.</p>
<h3 id="inline-methods">3.9.4 <a href="#inline-methods">Inline Methods</a></h3>
<p>Methods can also be defined as inline, meaning that at
least one of the input arguments is declared <code>inline</code> instead
of declaring a type. The method body is re-evaluated every time it is
invoked, and when a constant is passed for an inline argument, it will
be propagated into the method as a constant.</p>
<p>Inline methods were popular in previous versions of the language, when
constant folding across methods was a useful way to reduce the size of
the compiled model. DML 1.4 provides better ways to reduce code size,
and inline methods remain mainly for compatibility reasons.</p>
<h3 id="exported-methods">3.9.5 <a href="#exported-methods">Exported Methods</a></h3>
<p>In DML 1.4, methods can be <code>exported</code> using the
<a href="#export-declarations"><code>export</code> declaration</a>.</p>
<h3 id="retrieving-function-pointers-to-methods">3.9.6 <a href="#retrieving-function-pointers-to-methods">Retrieving Function Pointers to Methods</a></h3>
<p>In DML 1.4, <a href="#method-references-as-function-pointers">method references can be converted to function pointers using
<code>&amp;</code></a>.</p>
<h3 id="independent-methods">3.9.7 <a href="#independent-methods">Independent Methods</a></h3>
<p>Methods that do not rely on the particular instance of the device model may
be declared <code>independent</code>:</p>
<pre><code>independent method m(...) -&gt; (...) {...}
</code></pre>
<p><a href="#export-declarations">Exported</a> independent methods do not have the input
parameter corresponding to the device instance, allowing them to be called
in greater number of contexts. The body of independent methods may not contain
statements or expressions that rely on the device instance in any way; for
example, <code>session</code> or <code>saved</code> variables may not be referenced, <code>after</code> and <code>log</code>
statements may not be used, and non-<code>independent</code> methods may not be called.</p>
<p>Within a template, <code>shared</code> independent methods may be declared.</p>
<p>When independent methods are used as callbacks, it can sometimes be desirable to
mutate device state. In order to do this safely, device state should be mutated
within a method not declared <code>independent</code>, which can called from independent
methods <a href="#method-references-as-function-pointers">through the use of <code>&amp;</code></a>.
Device state should not be mutated directly within an independent method as this
could cause certain Simics breakpoints to not function correctly; for example,
an independent method should not mutate a session variable through a pointer to
that variable.</p>
<h4 id="independent-startup-methods">3.9.7.1 <a href="#independent-startup-methods">Independent Startup Methods</a></h4>
<p>Independent methods may also be declared <code>startup</code>, which causes them to be
called when the model is loaded into the simulation, <em>before</em> any device is
created. In order for this to be possible, <code>independent startup methods</code> may not
have any return values nor be declared <code>throw</code>s. In addition, independent
startup methods may not be declared with an overridable definition due to
technical limitations — this restriction can be worked around by having an
independent startup method call an overridable independent method. Note that
abstract <code>shared</code> independent startup methods are allowed.</p>
<p>The order in which independent startup methods are implicitly called at model
load is not defined, with the exception that independent startup methods not
declared memoized are called before any independent startup methods that are.</p>
<h4 id="independent-startup-memoized-methods">3.9.7.2 <a href="#independent-startup-memoized-methods">Independent Startup Memoized Methods</a></h4>
<p>Independent startup methods may also be declared <code>memoized</code>. Unlike regular
<code>independent startup</code> methods, <code>independent startup memoized</code> methods may
— indeed, are required to — have return values and/or be
declared <code>throws</code>.</p>
<p>After the first call of a memoized method, all subsequent calls for the
simulation session return the results of the first call without executing the
body of the method. If a memoized method call throws, then subsequent calls will
throw without executing the body.</p>
<p>The first call to an independent startup memoized method will typically be the
one implicitly performed at model load, but it may also occur beforehand (for
example, if the method is called as part of another independent startup method).</p>
<p>Result caching is shared across all instances of the device model. This
mechanism can be used to compute device-independent data which is then shared
across all instances of the device model.</p>
<p>The results of <code>shared</code> memoized methods are cached per template instance, and
are not shared across all objects instantiating the template.</p>
<p>(Indirectly) recursive memoized method calls are not allowed; the result of
such a call is a run-time critical error.</p>
<h2 id="session-variables">3.10 <a href="#session-variables">Session variables</a></h2>
<p>A <em>session</em> declaration creates a number of named storage locations for
arbitrary run-time values. The names belongs to the same namespace as
objects and methods. The general form is:</p>
<pre>session <em>declarations</em> = <em>initializer</em>;
</pre>
<p>where <em><code>= initializers</code></em> is optional
and <em><code>declarations</code></em> is a variable declaration similar to C, or
a sequence of such declarations; for example,</p>
<pre><code>session int id = 1;
session bool active;
session double table[4] = {0.1, 0.2, 0.4, 0.8};
session (int x, int y) = (4, 3);
session conf_object_t *obj;
</code></pre>
<p>In the absence of explicit initializer expressions, a default
"all zero" initializer will be applied to each declared object.</p>
<p>Note that the number of initializers — together given as a tuple
— must match the number of declared variables.
In addition, the number of elements in each initializer must match with
the number of elements or fields of the type of the declared <em>session</em>
variable. This also implies that each sub-element, if itself being a
compound data structure, must also be enclosed in braces.</p>
<p>C99-style designated initializers are supported for <code>struct</code>, <code>layout</code>, and
<code>bitfields</code> types:</p>
<pre><code>typedef struct { int x; struct { int i; int j; } y; } struct_t;
session struct_t s = { .x = 1, .y = { .i = 2, .j = 3 } }
</code></pre>
<p>Unlike C, partial initialization is not allowed implicitly; a designated
initializer for each member must be specified.
However, partial initialization can be done explicitly through the use of
trailing <code>...</code> syntax:</p>
<pre><code>session struct_t s = { .y = { .i = 2, ... }, ... }
</code></pre>
<p>Also unlike C, designator lists are not supported, and designated initializers
for arrays are not supported.</p>
<div class="note">
<p><strong>Note:</strong> Previously <code>session</code> variables were known as <code>data</code>
variables.</p>
</div>
<h2 id="saved-variables">3.11 <a href="#saved-variables">Saved variables</a></h2>
<p>A <em>saved</em> declaration creates a named storage location for an
arbitrary run-time value, and automatically creates an attribute
that checkpoints this variable. Saved variables can be declared in
object or statement scope, and the name will belong to the namespace
of other declarations in that scope. The general form is:</p>
<pre>saved <em>declaration</em> = <em>initializer</em>;
</pre>
<p>where <em><code>= initializer</code></em> is optional
and <em><code>declaration</code></em> is similar to a C variable
declaration; for example,</p>
<pre><code>saved int id = 1;
saved bool active;
saved double table[4] = {0.1, 0.2, 0.4, 0.8};
</code></pre>
<p>In the absence of explicit initializer expression, a default
"all zero" initializer will be applied to the declared object.</p>
<p>Note that the number of elements in the initializer must match with
the number of elements or fields of the type of the <em>saved</em>
variable. This also implies that each sub-element, if itself being a
compound data structure, must also be enclosed in braces.</p>
<p>C99-style designated initializers are supported for <code>struct</code>, <code>layout</code>, and
<code>bitfields</code> types:</p>
<pre><code>typedef struct { int x; struct { int i; int j; } y; } struct_t;
saved struct_t s = { .x = 1, .y = { .i = 2, .j = 3 } }
</code></pre>
<p>Unlike C, partial initialization is not allowed implicitly; a designated
initializer for each member must be specified.
However, partial initialization can be done explicitly through the use of
trailing <code>...</code> syntax:</p>
<pre><code>session struct_t s = { .y = { .i = 2, ... }, ... }
</code></pre>
<p>Also unlike C, designator lists are not supported, and designated initializers
for arrays are not supported.</p>
<p>In addition, the types of saved declaration variables are currently
restricted to primitive data types, or structs or arrays containing
only data types that could be saved. Such types are called
<a href="#serializable-types"><em>serializable</em></a>.</p>
<div class="note">
<p><strong>Note:</strong> Saved variables are primarily intended for making checkpointable
state easier. For configuration, <code>attribute</code> objects should
be used instead. Additional data types for saved declarations are planned to
be supported.</p>
</div>
<h2 id="object-declarations">3.12 <a href="#object-declarations">Object Declarations</a></h2>
<p>The general form of an object declaration is "<code><em>type</em>
<em>name</em> <em>extras</em> is (<em>template</em>, ...) <em>desc</em> {
... }</code>" or "<code><em>type</em> <em>name</em> <em>extras</em> is
(<em>template</em>, ...) <em>desc</em>;</code>", where <em><code>type</code></em>
is an object type such as <code>bank</code>, <em><code>name</code></em> is an
identifier naming the object, and <em><code>extras</code></em> is optional
special notation which depends on the object type. The <code>is
(<em>template</em>, ...)</code> part is optional and will make the object
inherit the named templates. The surrounding parenthesis can be omitted if
only one template is inherited. The <em><code>desc</code></em> is an optional
string constant giving a very short summary of the object. It can consist
of several string literals concatenated by the '+' operator. Ending the
declaration with a semicolon is equivalent to ending with an empty
pair of braces. The <em>body</em> (the section within the braces) may
contain <em>parameter declarations</em>, <em>methods</em>, <em>session
variable declarations</em>, <em>saved variable declarations</em>,
<em>in each declarations</em> and
<em>object declarations</em>.</p>
<p>For example, a <code>register</code> object may be declared as</p>
<pre><code>register r0 @ 0x0100 "general-purpose register 0";
</code></pre>
<p>where the "<code>@ <em>offset</em></code>" notation is particular for the
<code>register</code> object type; see below for details.</p>
<p>Using <code>is (<em>template1</em>, <em>template2</em>)</code> is equivalent to
using <code>is</code> statements in the body, so the following two
declarations are equivalent:</p>
<pre><code>register r0 @ 0x0100 is (read_only,autoreg);

register r0 @ 0x0100 {
    is read_only;
    is autoreg;
}
</code></pre>
<p>An object declaration with a <em><code>desc</code></em> section, on the form</p>
<pre><em>type</em> <em>name</em> ... <em>desc</em> { ... }
</pre>
<p>is equivalent to defining the parameter <code>desc</code>, as in</p>
<pre><em>type</em> <em>name</em> ... {
    param desc = <em>desc</em>;
    ...
}
</pre>
<p>In the following sections, we will leave out <em><code>desc</code></em> from
the object declarations, since it is always optional. Another parameter,
<code>documentation</code> (for which there is no short-hand), may also be
defined for each object, and for some object types it is used to give a
more detailed description.
See Section <a href="dml-builtins.html#universal-templates">Universal Templates</a>
for details.)</p>
<p>If two object declarations with the same name occur within the same
containing object, and they specify the same object type, then the
declarations are concatenated; e.g.,</p>
<pre>bank b {
    register r size 4 { ...<em>body1</em>... }
    ...
    register r @ 0x0100 { ...<em>body2</em>... }
    ...
}
</pre>
<p>is equivalent to</p>
<pre>bank b {
    register r size 4 @ 0x0100  {
        ...<em>body1</em>...
        ...<em>body2</em>...
    }
    ...
}
</pre>
<p>However, it is an error if the object types should differ.</p>
<p>Most object types (<code>bank</code>, <code>register</code>,
<code>field</code>,
<code>group</code>, <code>attribute</code>, <code>connect</code>,
<code>event</code>, and <code>port</code>) may be used
in <em>arrays</em>. The general form of an object array declaration is</p>
<pre><em>type</em> <em>name</em>[<em>var</em> &lt; <em>size</em>]... <em>extras</em> { ... }
</pre>
<p>Here each <code>[<em>var</em> &lt; <em>size</em>]</code> declaration defines
a dimension of resulting array. <em>var</em> defines the name of the
index in that dimension, and <em>size</em> defines the size of the dimension.
Each <em>variable</em> defines a parameter in the object scope, and thus must
be unique.
The size must be a compile time constant. For instance,</p>
<pre><code>register regs[i &lt; 16] size 2 {
    param offset = 0x0100 + 2 * i;
    ...
}
</code></pre>
<p>or written more compactly</p>
<pre><code>register regs[i &lt; 16] size 2 @ 0x0100 + 2 * i;
</code></pre>
<p>defines an array named <code>regs</code> of 16 registers (numbered from 0 to
15) of 2 bytes each, whose offsets start at 0x0100.
See Section <a href="dml-builtins.html#universal-templates">Universal Templates</a>
for details about arrays and index parameters.</p>
<p>The size specification of an array dimension may be replaced with <code>...</code> if the
size has already been defined by a different declaration of the same object
array. For example, the following is valid:</p>
<pre><code>register regs[i &lt; 16][j &lt; ...] size 2 @ 0x0100 + 16 * i + 2 * j;
register regs[i &lt; ...][j &lt; 8] is (read_only);
</code></pre>
<p>Note that in Simics 5, <code>port</code> arrays and <code>bank</code> arrays
cannot be multi-dimensional.</p>
<p>The following sections give further details on declarations for object
types that have special conventions.</p>
<h3 id="register-declarations">3.12.1 <a href="#register-declarations">Register Declarations</a></h3>
<p>The general form of a <code>register</code> declaration is</p>
<pre>register <em>name</em> size <em>n</em> @ <em>d</em> is (<em>templates</em>) { ... }
</pre>
<p>Each of the "<code>size <em>n</em></code>", "<code>@ <em>d</em></code>", and "<code>is
(<em>templates</em>)</code>" sections is optional, but if present, they must
be specified in the above order.</p>
<ul>
<li>
<p>A declaration</p>
<pre>register <em>name</em> size <em>n</em> ... { ... }
</pre>
<p>is equivalent to</p>
<pre>register <em>name</em> ... { param size = <em>n</em>; ... }
</pre>
</li>
<li>
<p>A declaration</p>
<pre>register <em>name</em> ... @ <em>d</em> ... { ... }
</pre>
<p>is equivalent to</p>
<pre>register <em>name</em>  ... { param offset = <em>d</em>; ... }
</pre>
</li>
</ul>
<h3 id="field-declarations">3.12.2 <a href="#field-declarations">Field Declarations</a></h3>
<p>The general form of a <a href="dml-builtins.html#field-objects"><code>field</code> object</a>
declaration is</p>
<pre>field <em>name</em> @ [<em>highbit</em>:<em>lowbit</em>] is (<em>templates</em>) { ... }
</pre>
<p>or simply</p>
<pre>field <em>name</em> @ [<em>bit</em>] ... { ... }
</pre>
<p>specifying a range of bits of the containing register, where the syntax
<code>[<em>bit</em>]</code> is short for <code>[<em>bit</em>:<em>bit</em>]</code>.
Both the "<code>@ [...]</code>" and the <code>is (<em>templates</em>)</code>
sections are optional; in fact, the "<code>[...]</code>" syntax is merely a
much more convenient way of defining the (required) field parameters
<code>lsb</code> and <code>msb</code>.</p>
<p>For a range of two or more bits, the first (leftmost) number always
indicates the <em>most significant bit</em>, regardless of the bit
numbering scheme used in the file. This corresponds to how bit fields
are usually visualized, with the most significant bit to the left.</p>
<p>The bits of a register are always numbered from zero to <em>n</em> - 1,
where <em>n</em> is the width of the register. If the default
little-endian bit numbering is used, the least significant bit has index
zero, and the most significant bit has index <em>n</em> - 1. In this case,
a 32-bit register with two fields corresponding to the high and low
half-words may be declared as</p>
<pre><code>register HL size 4 ... {
    field H @ [31:16];
    field L @ [15:0];
}
</code></pre>
<p>If instead big-endian bit numbering is selected in the file, the most
significant bit has index zero, and the least significant bit has the
highest index. In that case, the register above may be written as</p>
<pre><code>register HL size 4 ... {
    field H @ [0:15];
    field L @ [16:31];
}
</code></pre>
<p>This is useful when modeling a system where the documentation uses
big-endian bit numbering, so it can be compared directly to the model.</p>
<h2 id="conditional-objects">3.13 <a href="#conditional-objects">Conditional Objects</a></h2>
<p>It is also possible to conditionally include or exclude one or more
object declarations, depending on the value of a boolean
expression. This is especially useful when reusing source files
between several similar models that differ in some of the details.</p>
<p>The syntax is very similar to the <a href="#if-else-statements"><code>#if</code> statements</a>
used in methods.</p>
<pre><code>#if (enable_target) {
    connect target (
        interface signal;
    }
}
</code></pre>
<p>One difference is that the braces are required.  It is also possible
to add else branches, or else-if branches.</p>
<pre><code>#if (modeltype == "Mark I") {
    ...
} #else #if (modeltype == "Mark II" {
    ...
} #else {
    ...
}
</code></pre>
<p>The general syntax is</p>
<pre>#if ( <em>conditional</em> ) { <em>object declarations</em> ... }
#else #if ( <em>conditional</em> ) { <em>object declarations</em> ... }
...
#else { <em>object declarations</em> ... }
</pre>
<p>The <em>conditional</em> is an expression with a constant boolean value.  It
may reference parameters declared at the same level in the object
hierarchy, or in parent levels.</p>
<p>The <em>object declarations</em> are any number of declarations of objects, session
variables, saved variables, methods, or other <code>#if</code> statements, but not
parameters, <code>is</code> statements, or <code>in each</code> statements . When the conditional is
<code>true</code> (or if it's the else branch of a false conditional), the object
declarations are treated as if they had appeared without any surrounding <em>#if</em>.
So the two following declarations are equivalent:</p>
<pre><code>#if (true) {
    register R size 4;
} #else {
    register R size 2;
}
</code></pre>
<p>is equivalent to</p>
<pre><code>register R size 4;
</code></pre>
<h2 id="in-each-declarations">3.14 <a href="#in-each-declarations">In Each Declarations</a></h2>
<p>In Each declarations are a convenient mechanism to apply a
pattern to a group of objects. The syntax is:</p>
<p><code>in each</code> (<code>template-name</code>, ...) <code>{</code>
<code>body</code> <code>}</code></p>
<p>where <code>template-name</code> is the name of a template
and <code>body</code> is a list of object statements, much like the body
of a template. The statements in <code>body</code> are expanded in any
subobjects that instantiate the template <code>template-name</code>,
either directly or indirectly. If more than
one <code>template-name</code> is given, then the body will be expanded
only in objects that instantiate <em>all</em> the listed templates.</p>
<p>The <code>in each</code> construct can be used as a convenient way to
express when many objects share a common property. For
example, a bank can contain the following to conveniently set the size
of all its registers:</p>
<pre><code>in each register { param size = 2; }
</code></pre>
<p>Declarations in an <code>in each</code> block will override any
declarations in the extended template. Furthermore, declarations in
the scope that contains an <code>in each</code> statement, will override
declarations from that <code>in each</code> statement. This can be used
to define exceptions for the <code>in each</code> rule:</p>
<pre><code>bank regs {
    in each register { param size default 2; }
    register r1 @ 0;
    register r2 @ 2;
    register r3 @ 4 { param size = 1; }
    register r4 @ 5 { param size = 1; }
}
</code></pre>
<p>An <code>in each</code> block is only expanded in subobjects; the
object where the <code>in each</code> statement is present is
unaffected even if it instantiates the extended template.</p>
<p>An <code>in each</code> statement with multiple template names can be used
to cause a template to act differently depending on context:</p>
<pre><code>template greeting { is read; }
template field_greeting is write {
    method write(uint64 val) {
        log info: "hello";
    }
}
in each (greeting, field) { is field_greeting; }
template register_greeting is write {
    method write(uint64 val) {
        log info: "world";
    }
}
in each (greeting, register) { is register_greeting; }

bank regs {
    register r0 @ 0 {
        // logs "hello" on write
        field f @ [0] is (greeting);
    }
    // logs "world" on write
    register r1 @ 4 is (greeting);
}
</code></pre>
<h2 id="global-declarations">3.15 <a href="#global-declarations">Global Declarations</a></h2>
<p>The following sections describe the global declarations in DML. These
can only occur on the top level of a DML model, i.e., not within an
object or method. Unless otherwise noted, their scope is the entire
model.</p>
<h3 id="import-declarations">3.15.1 <a href="#import-declarations">Import Declarations</a></h3>
<pre>import <em>filename</em>;
</pre>
<p>Imports the contents of the named file. <em>filename</em> must be a string
literal, such as <code>"utility.dml"</code>. The <code>-I</code> option to the
<code>dmlc</code> compiler can be used to specify directories to be searched
for import files.</p>
<p>If <em>filename</em> starts with <code>./</code> or <code>../</code>, the
compiler disregards the <code>-I</code> flag, and the path is instead
interpreted relative to the directory of the importing file.</p>
<p>Note that imported files are parsed as separate units, and use their
own language version and bit order declarations. A DML 1.4 file is not
allowed to import a DML 1.2 file, but a DML 1.2 file may import a DML
1.4 file.</p>
<h3 id="template-declarations">3.15.2 <a href="#template-declarations">Template Declarations</a></h3>
<p><a href="#templates">Templates</a> may only be declared on the top level, and the syntax
and semantics for such declarations have been described previously.</p>
<p>Templates share the same namespace as types, as each template declaration
defines a corresponding template type of the same name. It is illegal to define
a template whose name conflicts with that of another type.</p>
<h3 id="bitorder-declarations">3.15.3 <a href="#bitorder-declarations">Bitorder Declarations</a></h3>
<pre>bitorder <em>order</em>;
</pre>
<p>Selects the default bit numbering scheme to be used for interpreting
bit-slicing expressions and bit field declarations in the file. The
<em><code>order</code></em> is one of the identifiers <code>le</code> or
<code>be</code>, implying little-endian or big-endian, respectively.  The
little-endian numbering scheme means that bit zero is the least
significant bit in a word, while in the big-endian scheme, bit zero is
the most significant bit.</p>
<p>A <code>bitorder</code> declaration should be placed before any other
global declaration in each DML-file, but must follow immediately after
the <code>device</code> declaration if such one is present.
The scope of the declaration is the whole of the file it
occurs in. If no <code>bitorder</code> declaration is present in a file, the
default bit order is <code>le</code> (little-endian). The bitorder does not
extend to imported files; for example, if a file containing a
declaration "<code>bitorder be;</code>" imports a file with no bit order
declaration, the latter file will still use the default <code>le</code>
order.</p>
<h3 id="constant-declarations">3.15.4 <a href="#constant-declarations">Constant Declarations</a></h3>
<pre>constant <em>name</em> = <em>expr</em>;
</pre>
<p>Defines a named constant.
<em><code>expr</code></em> must be a constant-valued expression.</p>
<p>Parameters have a similar behaviour as constants but are more
powerful, so constants are rarely useful. The only advantage of
constants over parameters is that they can be used in <code>typedef</code>
declarations.</p>
<h3 id="loggroup-declarations">3.15.5 <a href="#loggroup-declarations">Loggroup Declarations</a></h3>
<pre>loggroup <em>name</em>;
</pre>
<p>Defines a log group, for use in <a href="#log-statements"><code>log</code> statements</a>.
More generally,
the identifier <em><code>name</code></em> is bound to an unsigned integer
value that is a power of 2, and can be used anywhere in C context; this
is similar to a <code>constant</code> declaration, but the value is
allocated automatically so that all log groups are represented by
distinct powers of 2 and can be combined with bitwise <em>or</em>.</p>
<h3 id="typedef-declarations">3.15.6 <a href="#typedef-declarations">Typedef Declarations</a></h3>
<pre>typedef <em>declaration</em>;
extern typedef <em>declaration</em>;
</pre>
<p>Defines a name for a <a href="#data-types">data type</a>.</p>
<p>When the <code>extern</code> form is used, the type is assumed to exist in
the C environment. No definition of the type is added to the
generated C code, and the generated C code blindly assume that the
type exists and has the given definition.</p>
<p>An <code>extern typedef</code> declaration may not contain a <code>layout</code> or
<code>endian int</code> type.</p>
<p>If a <code>struct</code> type appears within an <code>extern typedef</code>
declaration, then DMLC will assume that there is a corresponding C
type, which has members of given types that can be accessed with
the <code>.</code> operator. No assumptions are made on completeness or
size; so the C struct may have additional fields, or it might be
a <code>union</code> type. An empty member list is even allowed; this can
make sense for opaque structs. DML variables of <code>extern</code> struct type are
initialized such that any members of the C struct which are unknown to DML are
initialized to 0.</p>
<p>Nested struct definitions are permitted in an <code>extern typedef</code>
declaration, but an inner struct type only supports member access; it
cannot be used as a standalone type. For instance, if you have:</p>
<pre><code>extern typedef struct {
    struct { int x; } inner;
} outer_t;
</code></pre>
<p>then you can declare <code>local outer_t var;</code> and access the member
<code>var.inner.x</code>, but the inner type is unknown to DML so you cannot
declare a variable <code>local typeof var.inner *inner_p;</code>.</p>
<h3 id="extern-declarations">3.15.7 <a href="#extern-declarations">Extern Declarations</a></h3>
<pre>extern <em>declaration</em>;
</pre>
<p>Declares an external identifier, similar to a C <code>extern</code>
declaration; for example,</p>
<pre><code>extern char *motd;
extern double table[16];
extern conf_object_t *obj;
extern int foo(int x);
extern int printf(const char *format, ...);
</code></pre>
<h3 id="header-declarations">3.15.8 <a href="#header-declarations">Header Declarations</a></h3>
<pre><code>header %{
...
%}
</code></pre>
<p>Specifies a section of C code which will be included verbatim in the
generated C header file for the device. There must be no whitespace
between the <code>%</code> and the corresponding brace in the <code>%{</code>
and <code>%}</code> markers. The contents of the header section are not
examined in any way by the <code>dmlc</code> compiler; declarations made
in C code must also be specified separately in the DML code proper.</p>
<p>This feature should only be used to solve problems that cannot easily be
handled directly in DML. It is most often used to make the generated
code include particular C header files, as in:</p>
<pre><code>header %{
#include "extra_defs.h"
%}
</code></pre>
<p>The expanded header block will appear in the generated C file, which
usually is in a different directory than the source DML
file. Therefore, when including a file with a relative path, the C
compiler will not automatically look for the <code>.h</code> file in
the directory of the <code>.dml</code> file, unless a corresponding
<code>-I</code> flag is passed. To avoid this problem, DMLC inserts a C
macro definition to permit including a <em>companion header
file</em>. For instance, if the
file <code>/path/to/hello-world.dml</code> includes a header block,
then the macro <code>DMLDIR_HELLO_WORLD_H</code> is defined as the
string <code>"/path/to/hello-world.h"</code> within this header
block. This allows the header block to contain <code>#include DMLDIR_HELLO_WORLD_H</code>, as a way to include <code>hello-world.h</code>
without passing <code>-I/path/to</code> to the C compiler.</p>
<p>DMLC only defines one such macro in each header block, by taking the
DML file name and substituting the <code>.dml</code> suffix
for <code>.h</code>. Furthermore, the macro is undefined after the
header. Hence, the macro can only be used to access one specific
companion header file; if other header files are desired, then
<code>#include</code> directives can be added to the companion header
file, where relative paths are expanded as expected.</p>
<p>See also <code>footer</code> declarations, below.</p>
<h3 id="footer-declarations">3.15.9 <a href="#footer-declarations">Footer Declarations</a></h3>
<pre><code>footer %{
...
%}
</code></pre>
<p>Specifies a piece of C code which will be included verbatim at the end
of the generated code for the device. There must be no whitespace
between the <code>%</code> and the corresponding brace in the <code>%{</code>
and <code>%}</code> markers. The contents of the footer section are not
examined in any way by the <code>dmlc</code> compiler.</p>
<p>This feature should only be used to solve problems that cannot easily be
handled directly in DML. See also <code>header</code> declarations, above.</p>
<h3 id="export-declarations">3.15.10 <a href="#export-declarations">Export Declarations</a></h3>
<pre>export <em>method</em> as <em>name</em>;
</pre>
<p>Exposes a method specified by <em><code>method</code></em> to other C modules within the
same Simics module under the name <em><code>name</code></em> with external linkage. Note
that inline methods, shared methods, methods that throw, methods with
more than one return argument, and methods declared inside object
arrays cannot be exported. It is sometimes possible to write wrapper
methods that call into non-exportable methods to handle such cases,
and export the wrapper instead.</p>
<p>Exported methods are rarely used; it is better to use Simics
interfaces for communication between devices. However, exported
methods can sometimes be practical in tight cross-language
integrations, when the implementation of one device is split between
one DML part and one C/C++ part.</p>
<p>Example: the following code in DML:</p>
<pre><code>method my_method(int x) { ... }
export my_method as "my_c_function";
</code></pre>
<p>will export <code>my_method</code> as a C function with external linkage,
using the following signature:</p>
<pre><code>void my_c_function(conf_object_t *obj, int x);
</code></pre>
<p>The <code>conf_object_t *obj</code> parameter corresponds to the device instance, and is
omitted when the referenced method is <a href="#independent-methods">independent</a>.</p>
<h2 id="resolution-of-overrides">3.16 <a href="#resolution-of-overrides">Resolution of overrides</a></h2>
<p>This section describes in detail the rules for how DML handles when there are
multiple definitions of the same parameter or method. A less technical but
incomplete description can be found in the <a href="#templates">section on templates</a>.</p>
<ul>
<li>
<p>Each declaration in every DML file is assigned a <em>rank</em>. The set of ranks
form a partial order, and are defined as follows:</p>
<ul>
<li>The top level of each file has a rank.</li>
<li>Each template definition has a rank.</li>
<li>The block in an <code>in each</code> declaration has a rank.</li>
<li>If one object declaration has rank <em>R</em>, then any subobject
declaration inside it, also those inside an <code>#if</code> block, has rank <em>R</em>.</li>
<li><code>param</code> and <code>method</code> declarations has the rank of the object they
are declared within. This includes shared methods.</li>
<li>If an object declaration contains <code>is <em>T</em></code>, then
that object declaration has higher rank than the body of the
template <em><code>T</code></em>.</li>
<li>If one file <em>F<sub>1</sub></em> imports another file <em>F<sub>2</sub></em>,
then the top level of <em>F<sub>1</sub></em> has higher rank than the top
level of <em>F<sub>2</sub></em>.</li>
<li>A declaration has higher rank than the block of any <code>in each</code>
declaration it contains.</li>
<li>An <code>in each</code> block has higher rank than the templates it applies to</li>
<li>If there are three declarations <em>D<sub>1</sub></em>, <em>D<sub>2</sub></em>
and <em>D<sub>3</sub></em>, where <em>D<sub>1</sub></em> has higher rank than
<em>D<sub>2</sub></em> and <em>D<sub>2</sub></em> has higher rank than
<em>D<sub>3</sub></em>, then <em>D<sub>1</sub></em> has higher rank than
<em>D<sub>3</sub></em>.</li>
<li>A declaration may not have higher rank than itself.</li>
</ul>
</li>
<li>
<p>In a set of <code>method</code> or <code>param</code> declarations that declare the same
object in the hierarchy, then we say that one declaration
<em>dominates</em> the set if it has higher rank than all other
declarations in the set.  Abstract <code>param</code> declarations (<code>param
<em>name</em>;</code> or <code>param <em>name</em> :
<em>type</em>;</code>) and abstract method definitions (<code>method
<em>name</em>(<em>args...</em>);</code>) are excluded here; they
cannot dominate a set, and a dominating declaration in a set does
not need to have higher declaration than any abstract <code>param</code> or
<code>method</code> declaration in the set.</p>
</li>
<li>
<p>There may be any number of <em>untyped</em> abstract definitions of a
parameter (<code>param <em>name</em>;</code>).</p>
</li>
<li>
<p>There may be at most one <em>typed</em> abstract definition of a parameter
(<code>param <em>name</em> : <em>type</em>;</code>)</p>
</li>
<li>
<p>There may be at most one abstract shared definition of a method. Any
other <em>shared</em> definition of this method must have higher rank than
the abstract definition, but any rank is permitted for non-shared
definitions. For instance:</p>
<pre><code>template a {
    method m() default {}
}
template b {
    shared method m() default {}
}
template aa is a {
    // OK: overrides non-shared method
    shared method m();
}
template bb is b {
    // Error: abstract shared definition overrides non-abstract
    shared method m();
}
</code></pre>
</li>
<li>
<p>When there is a set of declarations of the same a <code>method</code> or
<code>param</code> object in the hierarchy, then there must be (exactly) one of
these declarations that dominates the set; it is an error if there
is not.</p>
</li>
<li>
<p>If there is a <code>method</code> or <code>param</code> that is <em>not</em> declared <code>default</code>,
then it must dominate the set of declarations of that method or
parameter; it is an error if it does not.</p>
</li>
<li>
<p>In the above two rules, "the set of declarations" of an object does
not include declarations that are disabled through an <code>#if</code>
statement, or definitions that appear in a template that never is
instantiated in an object. However, the rules <em>do</em> also apply to
<em>shared</em> method declarations in templates, regardless whether the
templates are used. For instance:</p>
<pre><code>template t1 {
    method a() {}
    shared method b() {}
}
template t2 is t1 {
    // OK, as long as t2 never is instantiated
    method a default {}
    // Error, even if t2 is unused
    shared method b() default {}
}
</code></pre>
</li>
<li>
<p>If the set of declarations <em>D<sub>1</sub></em>, <em>D<sub>2</sub></em>, ...,
<em>D<sub>n</sub></em> of a method <em>M</em> is dominated by the declaration
<em>D<sub>n</sub></em>, then:</p>
<ul>
<li>If there is a <em>k</em>, 1 ≤ <em>k</em> ≤ n-1, such that <em>D<sub>k</sub></em> dominates
the set <em>D<sub>1</sub></em>, ..., <em>D<sub>n-1</sub></em>, then the symbol
<code>default</code> refers to the method implementation of <em>D<sub>k</sub></em>
within the scope of the method implementation of <em>D<sub>n</sub></em>.</li>
<li>If not, then <code>default</code> is an illegal value within the method
implementation of <em>D<sub>n</sub></em>.</li>
</ul>
</li>
</ul>
<p>It follows that:</p>
<ul>
<li>
<p>The following code is illegal, because it would otherwise give T a higher
rank than itself:</p>
<pre><code>template T {
    #if (p) {
        group g is T {
            param p = false;
        }
    }
}
</code></pre>
</li>
<li>
<p>Cyclic imports are not permitted, for the same reason.</p>
</li>
<li>
<p>If an object is declared twice on the top level in the same file,
then both declarations have the same rank. Thus, the following
declarations of the parameter <code>p</code> count as conflicting, because
neither has a rank that dominates the other:</p>
<pre><code>bank b {
    register r {
        param p default 3;
    }
}
bank b {
    register r {
        param p = 4;
    }
}
</code></pre>
</li>
</ul>
<h2 id="comparison-to-c-c">3.17 <a href="#comparison-to-c-c">Comparison to C/C++</a></h2>
<a id="comparison-to-c">
</a><p><a id="comparison-to-c">The algorithmic language used to express method bodies in DML is an extended
subset of ISO C, with some C++ extensions such as <code>new</code> and <code>delete</code>. The
DML-specific statements and expressions are described in Sections
</a><a href="#method-statements">Method Statements</a> and <a href="#expressions">Expressions</a>.</p>
<p>DML defines the following additional built-in data types:</p>
<dl><dt id="dt:int1-int64-uint1-uint64">
<p><code>int1</code>, ..., <code>int64</code>, <code>uint1</code>, ...,
<code>uint64</code></p>
</dt><dd>
<p>Signed and unsigned specific-width integer types. Widths from 1 to
64 are allowed.</p>
</dd><dt id="dt:bool">
<p><code>bool</code></p>
</dt><dd>
<p>The generic boolean datatype, consisting of the values <code>true</code>
and <code>false</code>. It is not an integer type, and the only implicit
conversion is to <code>uint1</code></p>
</dd></dl>
<p>DML also supports the non-standard C extension
<code>typeof(<em>expr</em>)</code> operator, as provided by some modern C
compilers such as GCC.</p>
<p>DML deviates from the C language in a number of ways:</p>
<ul>
<li>
<p>All integer arithmetic is performed on 64-bit numbers in DML,
and truncated to target types on assignment. This is similar to how
arithmetic would work in C on a platform where the <code>int</code> type
is 64 bits wide (though in DML, <code>int</code> is an alias
of <code>int32</code>). Similarly, all floating-point arithmetic is
performed on the <code>double</code> type.</p>
<p>For instance, consider the following:</p>
<pre><code>local int24 x = -3;
local uint32 y = 2;
local uint64 sum = x + y;
</code></pre>
<p>In C, the expression <code>x + y</code> would cast both operands up to unsigned
32-bit integers before performing a 32-bit addition; overflow gives
the result is 2<sup>32</sup> - 1, which is promoted without sign
extension into a 64-bit integer before stored in the <code>sum</code>
variable. In DML, both operands are instead promoted to 64-bit
signed integers, so the addition evaluates to -1, which is stored as
2<sup>64</sup> - 1 in the <code>sum</code> variable.</p>
<p>Formally, if any of the two operands of an arithmetic binary
operator (including bitwise operators) has the type <code>uint64</code>, then
both operands are promoted into <code>uint64</code> before the operation;
otherwise, both operands are promoted into <code>int64</code> before the
operation. If any operand has floating-point type, then both
operands are promoted into the <code>double</code> type.</p>
</li>
<li>
<p>Comparison operators
(<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>
and <code>&gt;=</code>) do <em>not</em> promote signed integers to
unsigned before comparison. Thus, unlike in C, the following
comparison yields <code>true</code>:</p>
<pre><code>int32 x = -1;
uint64 val = 0;
if (val &gt; x) { ... }
</code></pre>
</li>
<li>
<p>The shift operators (<code>&lt;&lt;</code> and <code>&gt;&gt;</code>) have well-defined semantics when
the right operand is large: Shifting by more than 63 bits gives zero
(-1 if the left operand is negative). Shifting a negative number of
bits is an error.</p>
</li>
<li>
<p>Division by zero is an error.</p>
</li>
<li>
<p>Signed overflow in arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;&lt;</code>)
is well-defined. The overflow value is calculated assuming two's
complement representation; i.e., the result is the unique value <em>v</em>
such that <em>v</em> ≡ <em>r</em> (mod 2<sup>64</sup>), where <em>r</em> is the result of
operation using arbitrary precision arithmetic.</p>
</li>
<li>
<p>Local variable declarations must use the keyword <a href="#local-statements">local</a>,
<a href="#session-statements">session</a>, or <a href="#saved-statements">saved</a>; as in</p>
<pre><code>method m() {
    session int call_count = 0;
    saved bool called = false;
    local int n = 0;
    local float f;
    ...
}
</code></pre>
<p>Session and saved variables have a similar meaning to static variables as in
C: they retain value over function calls.
However, such variables in DML are allocated per device object, and are not
globally shared between device instances.</p>
<p>Unlike C, multiple simultaneous variable declaration and
initialization is done through tuple syntax:</p>
<pre>method m() {
    local (int n, bool b) = (0, true);
    local (float f, void *p);
    ...
}
</pre>
</li>
<li>
<p>Plain C functions (i.e., not DML methods) can be called using normal
function call syntax, as in <code>f(x)</code>.</p>
<p>In order to call a C function from DML, three steps are needed:</p>
<ul>
<li>
<p>In order for DML to recognize an identifier as a C function, it
must be declared in DML, using an <a href="#extern-declarations"><code>extern</code>
declaration</a>.</p>
</li>
<li>
<p>In order for the C <em>compiler</em> to recognize the identifier when
compiling generated C code, a function declaration must also be
declared in a <a href="#header-declarations"><code>header</code></a> section, or in a
header file included from this section.</p>
</li>
<li>
<p>In order for the C <em>linker</em> to resolve the symbol, a function
definition must be present, either in a separate C file or in a header or 
<a href="#footer-declarations"><code>footer</code></a> section.</p>
</li>
</ul>
<p><strong>foo.c</strong></p>
<pre><code>int foo(int i)
{
    return ~i + 1;
}
</code></pre>
<p><strong>foo.h</strong></p>
<pre><code>int foo(int i);
</code></pre>
<p><strong>bar.dml</strong></p>
<pre><code>// tell DML that these functions are available
extern int foo(int);
extern int bar(int);

header %{
    // tell generated C that these functions are available
    #include "foo.h"
    int bar(int);  // defined in the DML footer section
%}

footer %{
    int bar(int i)
    {
        return -i;
    }
%}
</code></pre>
<p><strong>Makefile</strong></p>
<pre><code>SRC_FILES=foo.c bar.dml
</code></pre>
</li>
<li>
<p>Assignments (<code>=</code>) are required to be separate statements.
You are still allowed to assign multiple variables in one statement, as in:</p>
<pre><code>i = j = 0;
</code></pre>
</li>
<li>
<p>Multiple simultaneous assignment can be performed in one statement
through tuple syntax, allowing e.g. the following:</p>
<pre><code>(i, j) = (j, i);
</code></pre>
<p>However, such assignments are not allowed to be chained.</p>
</li>
<li>
<p>If a method can throw exceptions, or if it has more than one return argument, then the call must be a separate statement. If it has one or more return values, these must be assigned. If a method has multiple return arguments, these are enclosed in a parenthesis, as in:</p>
<pre><code>method divmod(int x, int y) -&gt; (int, int) {
    return (x / y, x % y);
}
...
(quotient, remainder) = divmod(17, 5);
</code></pre>
</li>
<li>
<p>Type casts must be written as <code>cast(<em>expr</em>,
<em>type</em>)</code>.</p>
</li>
<li>
<p>Comparison operators and logical operators produce results of type
<code>bool</code>, not integers.</p>
</li>
<li>
<p>Conditions in <code>if</code>, <code>for</code>, <code>while</code>, etc. must
be proper booleans; e.g., <code>if (i == 0)</code> is allowed, and <code>if (b)</code> is allowed if <code>b</code> is a boolean variable, but <code>if (i)</code> is not, if <code>i</code> is an integer.</p>
</li>
<li>
<p>The <code>sizeof</code> operator can only be used on lvalue expressions. To
take the size of a datatype, the <code>sizeoftype</code> operator must be
used.</p>
</li>
<li>
<p>Comma-expressions are only allowed in the head of
<code>for</code>-statements, as in</p>
<pre><code>for (i = 10, k = 0; i &gt; 0; --i, ++k) ...
</code></pre>
</li>
<li>
<p><code>delete</code> and <code>throw</code> can only be used as statements
in DML, not as expressions.</p>
</li>
<li>
<p><code>throw</code> does not take any argument, and <code>catch</code> cannot
switch on the type or value of an exception.</p>
</li>
<li>
<p>Type declarations do not allow the use of <code>union</code>.
However, the <code>extern typedef</code> construct can be used to achieve
the same result.  For example, consider the union data type declared in C
as:</p>
<pre><code>typedef union { int i; bool b; } u_t;
</code></pre>
<p>The data type can be exposed in DML as follows:</p>
<pre><code>header %{
    typedef union { int i; bool b; } u_t;
%}
extern typedef struct { int i; bool b; } u_t;
</code></pre>
<p>This will make <code>u_t</code> look like a struct to DML, but since union
and struct syntax is identical in C, the C code generated from uses
of <code>u_t</code> will work correctly together with the definition from
the <code>header</code> declaration.</p>
</li>
</ul>
<h2 id="method-statements">3.18 <a href="#method-statements">Method Statements</a></h2>
<p>All ISO C statements are available in DML, and have the same semantics
as in C. Like ordinary C expressions, all DML expressions can also be
used in expression-statements.</p>
<p>DML adds the following statements:</p>
<h3 id="assignment-statements">3.18.1 <a href="#assignment-statements">Assignment Statements</a></h3>
<pre><em>target1</em> [= <em>target2</em> = <em>...</em>] = <em>initializer</em>;
(<em>target1</em>, <em>target2</em>, ...) = <em>initializer</em>;
</pre>
<p>Assign values to targets according to an initializer. Unlike C, assignments are
not expressions, and the right-hand side can be any initializer — such as
compound initializers (<tt>{<em>...</em>}</tt>) for struct-like types.</p>
<p>The first form is chaining assignments. The initializer is executed once and
the value it evaluates to is assigned to each target.</p>
<p>The second form is multiple simultaneous assignment. The initializer describes
multiple values — one for each target. This can be done either through:</p>
<ul>
<li>Providing an initializer for each target through tuple syntax, e.g.:</li>
</ul>
<pre><code>(a, i) = (false, 4);
</code></pre>
<ul>
<li>Performing a method call where each target is a return value recipient, e.g.:</li>
</ul>
<pre><code>method m() -&gt; (bool, int) {
    ...
}
</code></pre>
<pre><code>(a, i) = m();
</code></pre>
<p>Targets are updated simultaneously, meaning it's possible to e.g. swap the
contents of variables through the following:</p>
<pre><code>(a, b) = (b, a)
</code></pre>
<h3 id="local-statements">3.18.2 <a href="#local-statements">Local Statements</a></h3>
<pre>local <em>type</em> <em>identifier</em> [= <em>initializer</em>];
local (<em>type1</em> <em>identifier1</em>, <em>type2</em> <em>identifier2</em>, <em>...</em>) [= <em>initializer</em>];
</pre>
<p>Declares one or multiple local variables in the current scope. The right-hand
side is an initializer, meaning, for example, that compound initializers
(<tt>{<em>...</em>}</tt>) can be used.</p>
<p>The initializer must provide the exact number of values needed to initialize
the variables, and they must be of compatible type. Multiple values can be
provided either through:</p>
<ul>
<li>Providing an initializer for each variable through tuple syntax, e.g.:</li>
</ul>
<pre><code>local (bool a, int i) = (false, 4);
</code></pre>
<ul>
<li>Performing a method call where each return value initializes a variable, e.g.:</li>
</ul>
<pre><code>method m() -&gt; (bool, int) {
    ...
}
</code></pre>
<pre><code>local (bool a, int i) = m();
</code></pre>
<h3 id="session-statements">3.18.3 <a href="#session-statements">Session Statements</a></h3>
<pre>session <em>type</em> <em>identifier</em> [= <em>initializer</em>];
session (<em>type1</em> <em>identifier1</em>, <em>type2</em> <em>identifier2</em>, <em>...</em>) [= (<em>initializer1</em>, initializer2, <em>...</em>)];
</pre>
<p>Declares one or multiple <a href="#session-variables">session variables</a> in the current
scope.
Note that initializers of such variables are evaluated <em>once</em> when
initializing the device, and thus must be a compile-time constant.</p>
<h3 id="saved-statements">3.18.4 <a href="#saved-statements">Saved Statements</a></h3>
<pre>saved <em>type</em> <em>identifier</em> [= <em>initializer</em>];
sabed (<em>type1</em> <em>identifier1</em>, <em>type2</em> <em>identifier2</em>, <em>...</em>) [= (<em>initializer1</em>, initializer2, <em>...</em>)];
</pre>
<p>Declares one or multiple <a href="#saved-variables">saved variables</a> in the current
scope.
Note that initializers of such variables are evaluated <em>once</em> when
initializing the device, and thus must be a compile-time constant.</p>
<h3 id="return-statements">3.18.5 <a href="#return-statements">Return Statements</a></h3>
<pre>return [<em>initializer</em>];
</pre>
<p>Returns from method with the value(s) specified by the argument.
Unlike C, the argument is an <em>initializer</em>, meaning, for example, return
values of struct-like type can be constructed using <tt>{<em>...</em>}</tt>.</p>
<p>The initializer must provide the exact number of values corresponding as the
return values of the method, and they must be of compatible type. Multiple
values can be provided either through:</p>
<ul>
<li>Providing an initializer for each return value through tuple syntax, e.g.:</li>
</ul>
<pre><code>method m() -&gt; (bool, int) {
    return (false, 4);
}
</code></pre>
<ul>
<li>Performing a method call and propagating the return values:</li>
</ul>
<pre><code>method n() -&gt; (bool, int) {
    return m();
}
</code></pre>
<h3 id="delete-statements">3.18.6 <a href="#delete-statements">Delete Statements</a></h3>
<pre>delete <em>expr</em>;
</pre>
<p>Deallocates the memory pointed to by the result of evaluating
<em><code>expr</code></em>. The memory must have been allocated with the
<code>new</code> operator, and must not have been deallocated previously.
Equivalent to <code>delete</code> in C++; however, in DML, <code>delete</code>
can only be used as a statement, not as an expression.</p>
<h3 id="try-statements">3.18.7 <a href="#try-statements">Try Statements</a></h3>
<pre>try <em>protected-stmt</em> catch <em>handle-stmt</em>
</pre>
<p>Executes <em><code>protected-stmt</code></em>; if that completes normally,
the whole <code>try</code>-statement completes normally. Otherwise,
<em><code>handle-stmt</code></em> is executed. This is similar to exception
handling in C++, but in DML there is only one kind of exception. Note
that Simics C-exceptions are not handled. See also <code>throw</code>.</p>
<h3 id="throw-statements">3.18.8 <a href="#throw-statements">Throw Statements</a></h3>
<pre><code>throw;
</code></pre>
<p>Throws (raises) an exception, which may be caught by a
<code>try</code>-statement. This is
similar to <code>throw</code> in C++, but in DML it is not possible to
specify a value to be thrown. Furthermore, in DML,
<code>throw</code> is a statement, not an expression.</p>
<p>If an exception is not caught inside a method body, then the method
must be declared as <code>throws</code>, and the exception is propagated
over the method call boundary.</p>
<h3 id="method-calls">3.18.9 <a href="#method-calls">Method Calls</a></h3>
<pre>(<em>d1</em>, ... <em>dM</em>) = <em>method</em>(<em>e1</em>, ... <em>eN</em>);
</pre>
<p>A DML method is called similarly as a C function, with the exception that you
must have assignment destinations according to the number of return values of
the method. Here a DML method is called with input arguments <em><code>e1</code></em>, ... <em><code>eN</code></em>,
assigning return values to destinations <em><code>d1</code></em>, ... <em><code>dM</code></em>. The destinations are
usually variables, but they can be arbitrary L-values (even bit slices) as long
as their types match the method signature.</p>
<p>If the method has no return value, the call is simply expressed as:</p>
<pre><code>p(...);
</code></pre>
<p>A method with exactly one return value can also be called in any
expression, unless it is an inline method, or a method that can throw
exceptions. For example:</p>
<pre><code>method m() -&gt; (int) { ... }
...
if (m() + i == 13) { ... }
</code></pre>
<p>A method call (even if it is throwing or has multiple return values) can be used
as an initializer in any context that accepts non-constant initializers; i.e.,
in <a href="#assignment-statements">assignment statements</a> (as shown above), <a href="#local-statements">local
variable declarations</a>, and <a href="#return-statements">return
statements</a>. For example:</p>
<pre><code>// declare multiple variables, and initialize them from one method call
local (int i, uint8 j) = m(e1);

// Propagate all return values from a method call as the return values of the
// caller.
return m(e1)
</code></pre>
<h3 id="after-statements">3.18.10 <a href="#after-statements">After Statements</a></h3>
<pre>after <em>scalar</em> <em>unit</em>: <em>method</em>(<em>e1</em>, ... <em>eN</em>);
</pre>
<p>The <code>after</code> construct sets up an asynchronous event which will perform the
specified method call with the provided arguments at the given time into the
future (in simulated time, measured in the specified time unit) relative to the
time when the <code>after</code> statement is executed. The currently supported time units
are <code>s</code> for seconds and <code>cycles</code> for cycles.</p>
<p>For example:</p>
<pre><code>after 0.1 s: my_callback(1, false);
</code></pre>
<p>This is equivalent to creating a named <a href="#events"><code>event</code></a> object with
an event-method that performs the specified call, and posting
that event at the given time, with associated data corresponding to the
provided arguments.</p>
<p>Each argument to the called method is evaluated at the time the
<code>after</code> statement is executed and the event is posted.</p>
<p>To allow the posted event to be checkpointed, <code>after</code> statements
may only be performed with methods that have no return values, and
where each input parameter is of <a href="#serializable-types"><em>serializable type</em></a>.</p>
<p>This means that <code>after</code> statements cannot be used with methods
that e.g. have pointer parameters.</p>
<p>Any events posted via an <code>after</code> statement are <em>associated</em> with the object that
contain the method containing the statement. It is possible to cancel all
<code>after</code> events associated with an object through that object's <code>cancel_after()</code>
method, as provided by the <a href="dml-builtins.html#object"><code>object</code> template</a>.</p>
<div class="note">
<p><strong>Note:</strong> We plan to extend the <code>after</code> statement to allow for users to
explicitly state what objects the posted events are to be associated with.</p>
</div>
<h3 id="log-statements">3.18.11 <a href="#log-statements">Log Statements</a></h3>
<pre>log <em>log-type</em>[, <em>level</em> [ then <em>subsequent_level</em> ] [, <em>groups</em>] ]: <em>format-string</em>, <em>e1</em>, ..., <em>eN</em>;
</pre>
<p>Outputs a formatted string to the Simics logging facility. The string
following the colon is a normal C <code>printf</code> format string,
optionally followed by one or more arguments separated by commas. (The
format string should not contain the name of the device, or the type of
the message, e.g., "error:..."; these things are automatically prefixed.)
Either both of <em><code>level</code></em> and <em><code>groups</code></em> may be
omitted, or only the latter; i.e., if <em><code>groups</code></em> is
specified, then <em><code>level</code></em> must also be given explicitly.</p>
<p>A Simics user can configure the logging facility to show only specific
messages, by matching on the three main properties of each message:</p>
<ul>
<li>
<p>The <em><code>log-type</code></em> specifies the general category
of the message. The value must be one of the identifiers
<code>info</code>, <code>error</code>, <code>critical</code>,
<code>spec_viol</code>, or <code>unimpl</code>.</p>
</li>
<li>
<p>The <em><code>level</code></em> specifies at what verbosity level the log
messages are displayed. The value must be an integer from 1 to 4; if
omitted, the default level is 1. The different levels have the following
meaning:</p>
<ol>
<li>
<p>Important messages (displayed at the normal verbosity level)</p>
</li>
<li>
<p>High level informative messages (like mode changes and important events)</p>
</li>
<li>
<p>Medium level information (the lowest log level for SW development)</p>
</li>
<li>
<p>Debugging level with low level model detail (Mainly used for model
development)</p>
</li>
</ol>
</li>
<li>
<p>If <em><code>subsequent_level</code></em> is specified, then all logs after the first
issued will be on the level <em><code>subsequent_level</code></em>. You are allowed
to specify a <em><code>subsequent_level</code></em> of 5, meaning no logging after the
initial log.</p>
</li>
<li>
<p>The <em><code>groups</code></em> argument is an integer whose bit
representation is used to select which log groups the message belongs
to. If omitted, the default value is 0. The log groups are specific for
the device, and must be declared using the <code>loggroup</code>
device-level declaration. For example, a DML source file containing the
declarations</p>
<pre><code>loggroup good;
loggroup bad;
loggroup ugly;
</code></pre>
<p>could also contain a log statement such as</p>
<pre><code>log info, 2, (bad | ugly): "...";
</code></pre>
<p>(note the <code>|</code> bitwise-or operator), which would be displayed if
the user chooses to view messages from group <code>bad</code> or
<code>ugly</code>, but not if only group <code>good</code> is shown.</p>
<p>Groups allow the user to create arbitrary classifications of log
messages, e.g., to indicate things that occur in different states, or in
different parts of the device, etc. The two log groups
<code>Register_Read</code> and <code>Register_Write</code> are predefined by
DML, and are used by several of the built-in methods.</p>
</li>
</ul>
<p>The <em><code>format-string</code></em> should be one or several string
literals concatenated by the '+' operator, all optionally surrounded
by round brackets.</p>
<p>See also <em>Simics Model Builder User's Guide</em>, section
"Logging", for further details.</p>
<h3 id="assert-statements">3.18.12 <a href="#assert-statements">Assert Statements</a></h3>
<pre>assert <em>expr</em>;
</pre>
<p>Evaluates <em><code>expr</code></em>. If the result is <code>true</code>, the
statement has no effect; otherwise, a runtime-error is generated.
<em><code>expr</code></em> must have type <code>bool</code>.</p>
<h3 id="error-statements">3.18.13 <a href="#error-statements">Error Statements</a></h3>
<pre>error [<em>string</em>];
</pre>
<p>Attempting to compile an <code>error</code> statement causes the compiler to
generate an error, using the specified string as error message. The
string may be omitted; in that case, a default error message is used.</p>
<p>The <em><code>string</code></em>, if present, should be one or several
string literals concatenated by the '+' operator, all optionally
surrounded by round brackets.</p>
<h3 id="foreach-statements">3.18.14 <a href="#foreach-statements">Foreach Statements</a></h3>
<pre>foreach <em>identifier</em> in (<em>expr</em>) <em>statement</em>
</pre>
<p>The <code>foreach</code> statement repeats its body (the
<em><code>statement</code></em> part) once for each element given by <em><code>expr</code></em>.
The <em><code>identifier</code></em> is used to refer to the current element
within the body.</p>
<p>DML currently only supports <code>foreach</code> iteration on values of <code>sequence</code> types
— which are created through <a href="#each-in-expressions">Each-In expressions</a>.</p>
<p>The <code>break</code> statement can be used within a <code>foreach</code> loop to exit it.</p>
<pre>#foreach <em>identifier</em> in (<em>expr</em>) <em>statement</em>
</pre>
<p>In this alternative form the <em><code>expr</code></em> is required
to be a DML compile-time constant,
and the loop is completely unrolled by the DML compiler.
This can be combined with tests on the value of
<em><code>identifier</code></em> within the body, which will be evaluated at
compile time.</p>
<p>DML currently only supports <code>#foreach</code> iteration on <a href="#list-expressions">compile-time list
constants</a>.</p>
<p>For example:</p>
<pre><code>#foreach x in ([3,2,1]) {
    #if (x == 1) foo();
    #else #if (x == 2) bar();
    #else #if (x == 3) baz();
    #else error "out of range";
}
</code></pre>
<p>would be equivalent to</p>
<pre><code>baz();
bar();
foo();
</code></pre>
<p>Only <code>#if</code> can be used to make such selections; <code>switch</code> or
<code>if</code> statements are <em>not</em> evaluated at compile time. (Also
note the use of <code>error</code> above to catch any compile-time
mistakes.)</p>
<p>The <code>break</code> statement can be used within a <code>#foreach</code> loop to exit it.</p>
<h3 id="select-statements">3.18.15 <a href="#select-statements">Select Statements</a></h3>
<pre>select <em>identifier</em> in (<em>expr</em>) where (<em>cond-expr</em>) <em>statement</em> else <em>default-statement</em>
</pre>
<p>The <code>select</code> statement resembles a C <code>switch</code> statement and is very similar
to the <code>foreach</code> statement, but executes the <em><code>statement</code></em> exactly once for the
first matching element of those given by <em><code>expr</code></em>, i.e., for the first element
such that <em><code>cond-expr</code></em> is <code>true</code>; or if no element matches, it executes the
<em><code>default-statement</code></em>.</p>
<pre>#select <em>identifier</em> in (<em>expr</em>) where (<em>cond-expr</em>) <em>statement</em> #else <em>default-statement</em>
</pre>
<p>In this alternative form the <em><code>expr</code></em> is required to be a DML
compile-time constant, and
<em><code>cond-expr</code></em> can only depend on compile-time constants, apart
from <em><code>identifier</code></em>. The selection will then be performed by
the DML compiler at compile-time, and code will only be generated for
the selected case.</p>
<p>DML currently only supports <code>#select</code> iteration on <a href="#list-expressions">compile-time list
constants</a>.</p>
<div class="note">
<p><strong>Note:</strong> The <code>select</code> statement has been temporarily removed from DML 1.4 due
to semantic issues, and only the <code>#select</code> form may currently be used.
The <code>select</code> statement will be reintroduced in the near future.</p>
</div>
<h3 id="if-and-else-statements">3.18.16 <a href="#if-and-else-statements">#if and #else Statements</a></h3>
<a id="if-else-statements">
<pre>#if (<em>condition</em>) { <em>true_body</em> } #else { <em>false_body</em> }
</pre>
<p>The <code>#if</code> statement resembles a C <code>if</code> statement. The difference
being that the <code>#if</code> statement must have a constant-valued
<em>condition</em> and the statement is evaluated at compile-time.
The <em>true_body</em> of the <code>#if</code> is only processed
if the condition evaluates to <code>true</code>,
and will be dead-code eliminated otherwise.</p>
<p>Similarly, the <code>#else</code> statement can immediately follow the body of an
<code>#if</code> statement and the <em>false_body</em> will only be processed
if the <em>condition</em> in the preceding <code>#if</code> evaluates to
<code>false</code>.</p>
</a><h2 id="expressions">3.19 <a id="if-else-statements"></a><a href="#expressions">Expressions</a></h2>
<p>All ISO C operators are available in DML, except for certain limitations
on the comma-operator, the <code>sizeof</code> operator, and type casts; see
Section <a href="#comparison-to-c">Comparison to C/C++</a>. Operators have the same
precedences and semantics as in C</p>
<p>DML adds the following expressions:</p>
<h3 id="the-undefined-constant">3.19.1 <a href="#the-undefined-constant">The Undefined Constant</a></h3>
<pre><code>undefined
</code></pre>
<p>The constant <code>undefined</code> is an abstract <em>compile-time
only</em> value, mostly used as a default for parameters that are
intended to optionally be overridden. The <code>undefined</code> expression may only
appear as a parameter value and as argument to
the <code>defined <em>expr</em></code> test (see below).</p>
<h3 id="references">3.19.2 <a href="#references">References</a></h3>
<pre><em>identifier</em>
</pre>
<p>To reference something in the DML object structure, members may be
selected using
<code>.</code> and <code>-&gt;</code> as in C. (However, most objects in the DML
object structure are proper substructures selected with the <code>.</code>
operator.) For example,</p>
<pre><code>this.size # a parameter
dev.bank1 # a bank object
bank1.r0.hard_reset # a method
</code></pre>
<p>The DML object structure is a compile-time construction; references to
certain objects are not considered to be proper values, and result in
compile errors if they occur as standalone expressions.</p>
<p>Some DML objects are proper values, while others are not:</p>
<ul>
<li>
<p><code>session</code>/<code>saved</code> variables are proper values</p>
</li>
<li>
<p>Composite object references (to <code>bank</code>, <code>group</code>, <code>register</code>, etc.) are not
proper values unless cast to a <a href="#templates-as-types">template type</a>.</p>
</li>
<li>
<p>Inside an object array, the index variable (named <code>i</code> by
default) may evaluate to an <em>unknown index</em> if accessed
from a location where the index is not statically known. For
instance, in <code>group g[i &lt; 4] { #if (i == 0) { ... } }</code>,
the <code>#if</code> statement is invoked once, statically, across all
indices, meaning that the <code>i</code> reference is an unknown
index, and will yield a compile error.</p>
</li>
<li>
<p>A reference to a <code>param</code> member is a proper value
only if the parameter value is a proper value: A parameter value
can be a reference to an object, an object array, a list,
the <code>undefined</code> expression, or a static index (discussed
above), in which case the parameter is not allowed as a standalone
expression.</p>
</li>
<li>
<p>When the object structure contains an array of objects,
e.g. <code>register r[4] { ... }</code>, then a reference to the array
itself (i.e. <code>r</code> as opposed to <code>r[0]</code>), is not
considered a proper value.</p>
</li>
</ul>
<p>If a DML object is not a proper value, then a reference to the object
will give a compile error unless it appears in one of the following contexts:</p>
<ul>
<li>
<p>As the left operand of the <code>.</code> operator</p>
</li>
<li>
<p>As the definition of a <code>param</code></p>
</li>
<li>
<p>As a list element in a compile-time list</p>
</li>
<li>
<p>As the operand of the <code>defined</code> operator</p>
</li>
<li>
<p>A <code>method</code> object may be called</p>
</li>
<li>
<p>An object array may appear in an index
expression <code><em>array</em>[<em>index</em>]</code></p>
</li>
<li>
<p>An unknown index may be used as an index to an object array; in the
resulting object reference, the corresponding index variable of
the object array will have an unknown value.</p>
</li>
</ul>
<h3 id="method-references-as-function-pointers">3.19.3 <a href="#method-references-as-function-pointers">Method References as Function Pointers</a></h3>
<p>It is possible to retrieve a function pointer for a method by using the prefix
operator <code>&amp;</code> with a reference to that method. The methods this is possible with
are subject to the same restrictions as with the <a href="#export-declarations"><code>export</code> object
statement</a>: it's not possible to retrieve a function
pointer to any inline method, shared method, method that throws, method with
more than one return argument, or method declared inside an object array.</p>
<p>For example, with the following method in DML:</p>
<pre><code>method my_method(int x) { ... }
</code></pre>
<p>then the expression <code>&amp;my_method</code> will be a function pointer of type:</p>
<pre><code>void (*)(conf_object_t *, int);
</code></pre>
<p>The <code>conf_object_t *</code> parameter corresponds to the device instance, and is
omitted when the referenced method is <a href="#independent-methods">independent</a>.</p>
<p>Note that due to the precedence rules of <code>&amp;</code>, if you want to immediately call a
method reference converted to a function pointer, then you will need to wrap
parentheses around the converted method reference. An example of where this may
be useful is in order to call a non-independent method from within an
independent method:</p>
<pre><code>independent method callback(int i, void *aux) {
  local conf_object_t *obj = aux;
  (&amp;my_method)(obj, i);
}
</code></pre>
<h3 id="new-expressions">3.19.4 <a href="#new-expressions">New Expressions</a></h3>
<pre>new <em>type</em>

new <em>type</em>[<em>count</em>]
</pre>
<p>Allocates a chunk of memory large enough for a value of the specified
type.  If the second form is used, memory for <em>count</em> values will
be allocated.  The result is a pointer to the allocated memory. (The
pointer is never null; if allocation should fail, the Simics
application will be terminated.)</p>
<p>When the memory is no longer needed, it should be deallocated using a
<code>delete</code> statement.</p>
<h3 id="cast-expressions">3.19.5 <a href="#cast-expressions">Cast Expressions</a></h3>
<pre>cast(<em>expr</em>, <em>type</em>)
</pre>
<p>Type casts in DML must be written with the above explicit <code>cast</code>
operator, for syntactical reasons.</p>
<p>Semantically, <code>cast(<em>expr</em>, <em>type</em>)</code> is equivalent to
the C expression <code>(<em>type</em>) <em>expr</em></code>.</p>
<h3 id="sizeoftype-expressions">3.19.6 <a href="#sizeoftype-expressions">Sizeoftype Expressions</a></h3>
<pre>sizeoftype <em>type</em>
</pre>
<p>The <code>sizeof</code> operator in DML can only be used on expressions,
not on types, for syntactical reasons. To take the size of a datatype,
the <code>sizeoftype</code> operator must be used, as in</p>
<pre><code>int size = sizeoftype io_memory_interface_t;
</code></pre>
<p>Semantically, <code>sizeoftype <em>type</em></code> is equivalent to the C
expression <code>sizeof (<em>type</em>)</code>.</p>
<p>DML does not know the sizes of all types statically; DML usually regards a
<code>sizeoftype</code> expression as non-constant and delegates size calculations
to the C compiler. DML does evaluate the sizes of integer types, layout types,
and constant-sized arrays thereof, as constants.</p>
<h3 id="defined-expressions">3.19.7 <a href="#defined-expressions">Defined Expressions</a></h3>
<pre>defined <em>expr</em>
</pre>
<p>This compile-time test evaluates to <code>false</code> if
<em><code>expr</code></em> has the value <code>undefined</code>, and to
<code>true</code> otherwise.</p>
<h3 id="each-in-expressions">3.19.8 <a href="#each-in-expressions">Each-In Expressions</a></h3>
<p>An expression <code>each</code>-<code>in</code> is available to traverse all objects
that implement a specific template. This can be used as a generic hook
mechanism for a specific template, e.g. to implement custom reset patterns.
For example, the following can be used to reset all registers in the bank
<code>regs</code>:</p>
<pre><code>foreach obj in (each hard_reset_t in (regs)) {
    obj.hard_reset();
}
</code></pre>
<p>An <code>each</code>-<code>in</code> expression can currently only be used for
iteration in a <code>foreach</code> statement. The expression's type
is <code>sequence(<em>template-name</em>)</code>.</p>
<p>An <code>each</code>-<code>in</code> expression searches recursively in the
object hierarchy for objects implementing the template, but once it
finds such an object, it does not continue searching inside that
subobject. Recursive traversal can be achieved by letting the
template itself contain a method that descends into subobjects; the
implementation of <code>hard_reset</code> in <code>utility.dml</code>
demonstrates how this can be done.</p>
<h3 id="list-expressions">3.19.9 <a href="#list-expressions">List Expressions</a></h3>
<pre>[<em>e1</em>, ..., <em>eN</em>]
</pre>
<p>A list is a <em>compile-time only</em> value, and is an ordered sequence
of zero or more compile-time constant values. Lists are in particular
used in combination with <code>foreach</code> and <code>select</code>
statements.</p>
<p>A list expression may only appear in the following contexts:</p>
<ul>
<li>
<p>As the list to iterate over in a <code>#foreach</code>
or <code>#select</code> statement</p>
</li>
<li>
<p>As the value in a <code>param</code> or <code>constant</code> declaration</p>
</li>
<li>
<p>As a list element in another compile-time list</p>
</li>
<li>
<p>In an index expression, <code><em>list</em>[<em>index</em>]</code></p>
</li>
<li>
<p>As the operand of the <code>defined</code> operator</p>
</li>
</ul>
<h3 id="length-expressions">3.19.10 <a href="#length-expressions">Length Expressions</a></h3>
<pre><em>list</em>.len

<em>sequence</em>.len

<em>object-array</em>.len

<em>value-array</em>.len
</pre>
<p>Used to obtain the length of a <em><code>list</code></em>,
<em><code>sequence</code></em>, <em><code>object-array</code></em>,
or <em><code>value-array</code></em> expression.
This expression is constant for each form but <em><code>sequence</code></em>
expressions.</p>
<p>The <em><code>value-array</code></em> form can only be used with arrays of known
constant size: it can't be used with pointers, arrays of unknown size,
or variable-length arrays.</p>
<h3 id="bit-slicing-expressions">3.19.11 <a href="#bit-slicing-expressions">Bit Slicing Expressions</a></h3>
<pre><em>expr</em>[<em>e1</em>:<em>e2</em>]

<em>expr</em>[<em>e1</em>:<em>e2</em>, <em>bitorder</em>]

<em>expr</em>[<em>e1</em>]

<em>expr</em>[<em>e1</em>, <em>bitorder</em>]
</pre>
<p>If <em><code>expr</code></em> is of integer type, then the above
<em>bit-slicing</em> syntax can be used in DML to simplify extracting or
updating particular bit fields of the integer. Bit slice syntax can be
used both as an expression producing a value, or as the target of an
assignment (an L-value), e.g., on the left-hand side of an <code>=</code>
operator.</p>
<p>Both <em><code>e1</code></em> and <em><code>e2</code></em> must be integers. The
syntax <code><em>expr</em>[<em>e1</em>]</code> is a short-hand for
<code><em>expr</em>[<em>e1</em>:<em>e1</em>]</code> (but only evaluating
<em><code>e1</code></em> once).</p>
<p>The <em><code>bitorder</code></em> part is optional, and selects the bit
numbering scheme (the "endianness") used to interpret the values of
<em><code>e1</code></em> and <em><code>e2</code></em>. If present, it must be one
of the identifiers <code>be</code> or <code>le</code>, just as in the
<code>bitorder</code> device-level declaration.  If no
<em><code>bitorder</code></em> is given in the expression, the global bit
numbering (as defined by the <code>bitorder</code> declaration) is used.</p>
<p>The first bit index <em><code>e1</code></em> always indicates the <em>most
significant bit</em> of the <a href="#field-declarations">field</a>,
regardless of the bit numbering scheme. If the default
little-endian bit numbering is used, the least significant bit of the
integer has index zero, and the most significant bit of the integer has
index <em>n</em> - 1, where <em>n</em> is the width of the integer type.</p>
<p>If big-endian bit numbering is used, e.g., due to a <code>bitorder be;</code> declaration in the file, or using a specific local bit
numbering as in <code><em>expr</em>[<em>e1</em>:<em>e2</em>, be]</code>, then
the bit corresponding to the little-endian bit number <em>n</em> - 1 has
index zero, and the least significant bit has the index <em>n</em> - 1,
where <em>n</em> is the bit width of <em><code>expr</code></em>.  Note that
big-endian numbering is illegal if <em><code>expr</code></em> isn't a simple
expression with a well-defined bit width.  This means that only local
variables, method parameters, device variables (registers, data etc),
and explicit cast expressions are allowed.  For little-endian
numbering, any expressions are allowed, since there is never any doubt
that bit 0 is the least significant bit.</p>
<p>If the bit-slicing expression results in a zero or negative sized
range of bits, the behavior is undefined.</p>
<h3 id="stringify-expressions">3.19.12 <a href="#stringify-expressions">Stringify Expressions</a></h3>
<pre>stringify(<em>expr</em>)
</pre>
<p>Translates the value of <em><code>expr</code></em> (which must be a
compile-time constant) into a string constant. This is similar to the
use of <code>#</code> in the C preprocessor, but is performed on the level
of compile time values, not tokens. The result is often used with the
<code>+</code> string operator.</p>
<h3 id="string-concatenation-expressions">3.19.13 <a href="#string-concatenation-expressions">String Concatenation Expressions</a></h3>
<pre><em>expr1</em> + <em>expr2</em>
</pre>
<p>If both <em><code>expr1</code></em> and <em><code>expr2</code></em> are compile-time
string constants, the expression <code><em>expr1</em> + <em>expr2</em></code>
concatenates the two strings at compile time. This is often used in
combination with the <code>#</code> operator, or to break long lines for
source code formatting purposes.</p>
<h3 id="compile-time-conditional-expressions">3.19.14 <a href="#compile-time-conditional-expressions">Compile-Time Conditional Expressions</a></h3>
<pre><em>condition</em> #? <em>expr1</em> #: <em>expr2</em>
</pre>
<p>Similar to the C <code>conditional</code> expression, with the difference
that the <em>condition</em> must have a constant value and the
expression is evaluated at compile-time.
<em>expr1</em> is only processed if the
<em>condition</em> is <code>true</code> and <em>expr2</em> is only processed
if <em>condition</em> is <code>false</code>, so an expression like
<code>false #? 1/0 #: 0</code> is equivalent to <code>0</code>.</p>

<div class="chain">
<a href="running-dmlc.html">2 The DML compiler</a>
<a href="dml-builtins.html">4 Libraries and Built-ins</a>
</div>