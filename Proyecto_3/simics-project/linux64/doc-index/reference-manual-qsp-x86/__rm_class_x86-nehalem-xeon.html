<!doctype html>
<head>
<meta charset="utf-8">
<title>x86-nehalem-xeon</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="__rm_class_x86-nehalem.html">x86-nehalem</a>
<a href="__rm_class_x86-p4-nocona.html">x86-p4-nocona</a>
</div>
<div class="path">
<a href="index.html">Quick-Start Platform x86 Reference Manual</a>
&nbsp;/&nbsp;
<a href="classes.html">4 Classes</a>
&nbsp;/&nbsp;</div>
<h1 class="jdocu"><a class="not-numbered" name="__rm_class_x86-nehalem-xeon">x86-nehalem-xeon</a></h1>
<p>

<a name="x86-nehalem-xeon"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem"><b>Provided By</b></dt><dd class="jdocu_descitem"><a class="jdocu" href="modules.html#__rm_module_x86-intel64">x86-intel64</a>
</dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <b>x86-nehalem-xeon</b> class implements an x86 processor.
</dd>
<dt class="jdocu_descitem"><b>Interfaces Implemented</b></dt><dd class="jdocu_descitem"><a class="jdocu" href="undocumented-interfaces.html#__rm_interface_a20">a20</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_callback_info">callback_info</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_class_disassembly">class_disassembly</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_concurrency_group">concurrency_group</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_concurrency_mode">concurrency_mode</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_conf_object">conf_object</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_context_handler">context_handler</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cpu_cached_instruction">cpu_cached_instruction</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cpu_cached_instruction_once">cpu_cached_instruction_once</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cpu_cached_stream">cpu_cached_stream</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cpu_exception_query">cpu_exception_query</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cpu_instruction_decoder">cpu_instruction_decoder</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cpu_instruction_query">cpu_instruction_query</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cpu_instrumentation_stream">cpu_instrumentation_stream</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cpu_instrumentation_subscribe">cpu_instrumentation_subscribe</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cpu_memory_query">cpu_memory_query</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_cycle">cycle</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_decoder">decoder</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_describe_registers">describe_registers</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_direct_memory_update">direct_memory_update</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_event_delta">event_delta</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_exception">exception</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_exec_trace">exec_trace</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_execute">execute</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_execute_control">execute_control</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_freerun">freerun</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_frequency">frequency</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_frequency_listener">frequency_listener</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_icode">icode</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_instruction_fetch">instruction_fetch</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_instrumentation_order">instrumentation_order</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_int_register">int_register</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_internal_cached_instruction">internal_cached_instruction</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_interrupt_ack">interrupt_ack</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_jit_control">jit_control</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_log_object">log_object</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_opcode_info">opcode_info</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_pre_decoder">pre_decoder</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_processor_cli">processor_cli</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_processor_gui">processor_gui</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_processor_info">processor_info</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_processor_info_v2">processor_info_v2</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_processor_internal">processor_internal</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_register_breakpoint">register_breakpoint</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_save_state">save_state</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_simulator_cache">simulator_cache</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_smm_instrumentation_subscribe">smm_instrumentation_subscribe</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_stall">stall</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_stc">stc</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_step">step</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_step_cycle_ratio">step_cycle_ratio</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_step_event_instrumentation">step_event_instrumentation</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_step_info">step_info</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_telemetry">telemetry</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_virtual_data_breakpoint">virtual_data_breakpoint</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_virtual_instruction_breakpoint">virtual_instruction_breakpoint</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_vmp">vmp</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_vmp_internal">vmp_internal</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_vmx_instrumentation_subscribe">vmx_instrumentation_subscribe</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86">x86</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_access_type">x86_access_type</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_address_query">x86_address_query</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_cpuid_query">x86_cpuid_query</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_cstate">x86_cstate</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_exception">x86_exception</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_exception_query">x86_exception_query</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_instruction_query">x86_instruction_query</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_instrumentation_subscribe">x86_instrumentation_subscribe</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_instrumentation_subscribe_v2">x86_instrumentation_subscribe_v2</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_memory_access">x86_memory_access</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_memory_operation">x86_memory_operation</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_memory_query">x86_memory_query</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_msr">x86_msr</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_reg_access">x86_reg_access</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_smm_state">x86_smm_state</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86_vmp_control">x86_vmp_control</a></dd>
<dt class="jdocu_descitem"><b>Port Objects</b></dt><dd class="jdocu_descitem"><b>vtime.cycles</b> &lt;cycle-counter&gt; : cycle queue<br><b>vtime.ps</b> &lt;ps-clock&gt; : event queue (ps)<br><b>vtime</b> &lt;vtime&gt; : event handler</dd>
<dt class="jdocu_descitem"><b>Port Interfaces</b></dt><dd class="jdocu_descitem">IGNNE (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_signal">signal</a>) : IGNNE signal<br>INIT (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_signal">signal</a>) : INIT signal<br>NMI (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_signal">signal</a>) : NMI signal<br>RESET (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_signal">signal</a>) : RESET signal<br>SMI (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_signal">signal</a>) : SMI signal<br>cpu_frequency (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_simple_dispatcher">simple_dispatcher</a>) : Broadcasts changes in CPU frequency.<br>cpu_internal_counters (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_probe_index">probe_index</a>) : Port for internal counters<br>cpu_internal_intensity_counters (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_probe_index">probe_index</a>) : Port for internal intensity counters<br>extension (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_decoder">decoder</a>) : Instruction set extension decoder<br>step_event_probes (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_probe_index">probe_index</a>, <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_probe_subscribe">probe_subscribe</a>) : Port for event probes.<br>virtual (<a class="jdocu" href="undocumented-interfaces.html#__rm_interface_context_handler">context_handler</a>) : Handler for virtual address context, as opposed to the non-port context_handler which deals with linear addresses.</dd>
</dl><p></p><h2 class="jdocu"><a class="not-numbered" name="Attributes">Attributes</a></h2>
<p></p><dl><dt id="dt:a20_inhibited"><b><i>a20_inhibited</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_a20_inhibited"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
A20 will be always lowered if this flag is set.</dd></dl><p></p><dl><dt id="dt:a20mask"><b><i>a20mask</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_a20mask"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
The a20mask.</dd></dl><p></p><dl><dt id="dt:access_type_name"><b><i>access_type_name</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_access_type_name"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; <b>integer</b> indexed;  indexed type: <code>string</code>.
Get string describing the specified access type (x86_access_type_t).</dd></dl><p></p><dl><dt id="dt:activity_state"><b><i>activity_state</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_activity_state"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Processor activity state.</dd></dl><p></p><dl><dt id="dt:allow_tss_bios_workaround"><b><i>allow_tss_bios_workaround</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_allow_tss_bios_workaround"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If this attribute is set to TRUE, which is the default, then VMP is allowed to modify the initial CPU state slightly in order to work around a BIOS problem causing hard host crashes. The workaround consist of using a 32-bit TSS instead of a 16-bit TSS after CPU reset. If this attribute is set to FALSE, then VMP will be disabled whenever a 16-bit TSS is loaded.</dd></dl><p></p><dl><dt id="dt:apic"><b><i>apic</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_apic"></a></p><dd><b>Required</b> attribute; <b>read/write</b> access; type: <code>object</code>.
Local APIC this cpu is connected to.</dd></dl><p></p><dl><dt id="dt:aprof_views"><b><i>aprof_views</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_aprof_views"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>[[o,i]*]</code>.
((<i>address profiler</i>, <i>view</i>)*) Address profiler views selected for this processor. Affects only the display of profiling information, and has nothing to do with collecting it.
<p>
This attribute should contain a list of lists: one list for each address profiler view you want to select (in the order they are to appear), each containing first the address profiler object, then the index of the desired view.</p></dd></dl><p></p><dl><dt id="dt:auto_hyper_enabled"><b><i>auto_hyper_enabled</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_auto_hyper_enabled"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Enables automatic detection of loops which can be hypersimulated.</dd></dl><p></p><dl><dt id="dt:auto_hyper_loops"><b><i>auto_hyper_loops</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_auto_hyper_loops"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>[[iis]*]</code>.
{ffwd_steps, addr, precond} Information on automatically found hypersim loops.</dd></dl><p></p><dl><dt id="dt:block_init"><b><i>block_init</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_block_init"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
INIT will be blocked if this flag is set.</dd></dl><p></p><dl><dt id="dt:block_nmi"><b><i>block_nmi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_block_nmi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
NMI will be blocked if this flag is set.</dd></dl><p></p><dl><dt id="dt:block_smi"><b><i>block_smi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_block_smi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
SMI will be blocked if this flag is set.</dd></dl><p></p><dl><dt id="dt:block_virtual_nmi"><b><i>block_virtual_nmi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_block_virtual_nmi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Virtual NMIs blocking.</dd></dl><p></p><dl><dt id="dt:break_on_triple_fault"><b><i>break_on_triple_fault</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_break_on_triple_fault"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If TRUE, the model will stop execution if there is a triple fault. Set to FALSE to not stop on triple fault.</dd></dl><p></p><dl><dt id="dt:cache_flush_handler"><b><i>cache_flush_handler</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cache_flush_handler"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
Object implementing the x86_cache_flush interface.</dd></dl><p></p><dl><dt id="dt:cell"><b><i>cell</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cell"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
Cell</dd></dl><p></p><dl><dt id="dt:cpl"><b><i>cpl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpl"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Current privilege level.</dd></dl><p></p><dl><dt id="dt:cpuid_2_eax"><b><i>cpuid_2_eax</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_2_eax"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Value returned in EAX for CPUID when input EAX == 2.</dd></dl><p></p><dl><dt id="dt:cpuid_2_ebx"><b><i>cpuid_2_ebx</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_2_ebx"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Value returned in EBX for CPUID when input EAX == 2.</dd></dl><p></p><dl><dt id="dt:cpuid_2_ecx"><b><i>cpuid_2_ecx</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_2_ecx"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Value returned in ECX for CPUID when input EAX == 2.</dd></dl><p></p><dl><dt id="dt:cpuid_2_edx"><b><i>cpuid_2_edx</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_2_edx"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Value returned in EDX for CPUID when input EAX == 2.</dd></dl><p></p><dl><dt id="dt:cpuid_brand_id"><b><i>cpuid_brand_id</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_brand_id"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Brand ID for CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_clflush_size"><b><i>cpuid_clflush_size</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_clflush_size"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Size of CLFLUSH as reported by CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_core_level_apic_id_shift_count"><b><i>cpuid_core_level_apic_id_shift_count</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_core_level_apic_id_shift_count"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Number of bits for APIC ID shift at the core level in CPUID. The shift count at the thread level will be added to calculate the second 0xB sub-leaf shift count. If left at the default value of 0, a count just large enough to represent the cores in the package.</dd></dl><p></p><dl><dt id="dt:cpuid_extended_family"><b><i>cpuid_extended_family</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_extended_family"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Extended family for CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_extended_model"><b><i>cpuid_extended_model</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_extended_model"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Extended model for CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_family"><b><i>cpuid_family</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_family"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Family for CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_l2_cache_assoc"><b><i>cpuid_l2_cache_assoc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_l2_cache_assoc"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Level 2 cache information returned by CPUID function 8000.0006.</dd></dl><p></p><dl><dt id="dt:cpuid_l2_cache_line_size"><b><i>cpuid_l2_cache_line_size</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_l2_cache_line_size"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Level 2 cache information returned by CPUID function 8000.0006.</dd></dl><p></p><dl><dt id="dt:cpuid_l2_cache_lines_per_tag"><b><i>cpuid_l2_cache_lines_per_tag</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_l2_cache_lines_per_tag"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Level 2 cache information returned by CPUID function 8000.0006.</dd></dl><p></p><dl><dt id="dt:cpuid_l2_cache_size_kb"><b><i>cpuid_l2_cache_size_kb</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_l2_cache_size_kb"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Level 2 cache information returned by CPUID function 8000.0006.</dd></dl><p></p><dl><dt id="dt:cpuid_lahf64"><b><i>cpuid_lahf64</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_lahf64"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>boolean</code>.
LAHF/SAHF support in 64-bit mode. Reported through CPUID function 80000001 in ECX bit 0.</dd></dl><p></p><dl><dt id="dt:cpuid_list"><b><i>cpuid_list</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_list"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[o*]</code>.
List of objects implementing the x86_cpuid interface. These objects are called in the order of registration after the magic instruction handler but before internal CPUID implementation</dd></dl><p></p><dl><dt id="dt:cpuid_logical_processor_count"><b><i>cpuid_logical_processor_count</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_logical_processor_count"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Count of logical processors for CPUID. Setting this to non-zero will enable the HTT feature bit (bit 28).</dd></dl><p></p><dl><dt id="dt:cpuid_model"><b><i>cpuid_model</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_model"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Model for CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_monitor"><b><i>cpuid_monitor</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_monitor"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
Support for MONITOR. Reported through CPUID function 1 ECX bit 3.</dd></dl><p></p><dl><dt id="dt:cpuid_monitor_max_size"><b><i>cpuid_monitor_max_size</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_monitor_max_size"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Largest monitor granularity. This is reported through CPUID, but not used in the implementation.</dd></dl><p></p><dl><dt id="dt:cpuid_monitor_min_size"><b><i>cpuid_monitor_min_size</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_monitor_min_size"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Smallest monitor granularity. This is the size used in the monitor implementation.</dd></dl><p></p><dl><dt id="dt:cpuid_mwait_int_break_support"><b><i>cpuid_mwait_int_break_support</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_mwait_int_break_support"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Support for MWAIT break on interrupts even if disabled.</dd></dl><p></p><dl><dt id="dt:cpuid_physical_apic_id"><b><i>cpuid_physical_apic_id</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_physical_apic_id"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Physical local APIC ID for CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_processor_name"><b><i>cpuid_processor_name</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_processor_name"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>string</code>.
Processor name for CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_sse3"><b><i>cpuid_sse3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_sse3"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
Support for SSE3. Reported through CPUID function 1 ECX bit 0.</dd></dl><p></p><dl><dt id="dt:cpuid_sse4_1"><b><i>cpuid_sse4_1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_sse4_1"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
Support for SSE4.1. Reported through CPUID function 1 ECX bit 19.</dd></dl><p></p><dl><dt id="dt:cpuid_sse4_2"><b><i>cpuid_sse4_2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_sse4_2"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
Support for SSE4.2. Reported through CPUID function 1 ECX bit 20.</dd></dl><p></p><dl><dt id="dt:cpuid_ssse3"><b><i>cpuid_ssse3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_ssse3"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
Support for SSSE3. Reported through CPUID function 1 ECX bit 9.</dd></dl><p></p><dl><dt id="dt:cpuid_stepping"><b><i>cpuid_stepping</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_stepping"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Stepping for CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_thread_level_apic_id_shift_count"><b><i>cpuid_thread_level_apic_id_shift_count</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_thread_level_apic_id_shift_count"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Number of bits for APIC ID shift at the thread level in CPUID. If left at the default value of 0, a count just large enough to represent the threads in the core will be used.</dd></dl><p></p><dl><dt id="dt:cpuid_vendor_id"><b><i>cpuid_vendor_id</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_vendor_id"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>string</code>.
Vendor ID string for CPUID.</dd></dl><p></p><dl><dt id="dt:cpuid_vmx"><b><i>cpuid_vmx</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cpuid_vmx"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
VMX feature as reported through CPUID function 1 ECX bit 5.</dd></dl><p></p><dl><dt id="dt:cr0"><b><i>cr0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cr0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Control register 0.</dd></dl><p></p><dl><dt id="dt:cr2"><b><i>cr2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cr2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Control register 2.</dd></dl><p></p><dl><dt id="dt:cr3"><b><i>cr3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cr3"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Control register 3.</dd></dl><p></p><dl><dt id="dt:cr4"><b><i>cr4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cr4"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Control register 4.</dd></dl><p></p><dl><dt id="dt:cr4_extension_mask"><b><i>cr4_extension_mask</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cr4_extension_mask"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Externally implemented cr4 bits.</dd></dl><p></p><dl><dt id="dt:cs"><b><i>cs</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cs"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i{11}]</code>.
X86 segment register. All fields are stored in a list of integers as follows: <code>(</code><i>selector</i><code>, </code><i>d</i><code>, </code><i>dpl</i><code>, </code><i>g</i><code>, </code><i>p</i><code>, </code><i>s</i><code>, </code><i>type</i><code>, </code><i>base</i><code>, </code><i>limit</i><code>, </code><i>valid</i><code>, </code><i>l</i><code>)</code> The limit field always specifies the limit in bytes.</dd></dl><p></p><dl><dt id="dt:cstar"><b><i>cstar</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cstar"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:cstate"><b><i>cstate</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cstate"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[ii]</code>.
C-state</dd></dl><p></p><dl><dt id="dt:cstate_listeners"><b><i>cstate_listeners</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cstate_listeners"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[o*]</code>.
List of all devices to be notified on C-state change. Must implement the x86_cstate_notification interface.</dd></dl><p></p><dl><dt id="dt:current_context"><b><i>current_context</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_current_context"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
Current context object</dd></dl><p></p><dl><dt id="dt:current_virtual_context"><b><i>current_virtual_context</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_current_virtual_context"></a></p><dd><b>Session</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
Current context relating to addresses before segmentation.</dd></dl><p></p><dl><dt id="dt:current_vmcs_ptr"><b><i>current_vmcs_ptr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_current_vmcs_ptr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
VMX mode current VMCS pointer.</dd></dl><p></p><dl><dt id="dt:cycles"><b><i>cycles</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_cycles"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Time measured in cycles from machine start.</dd></dl><p></p><dl><dt id="dt:debug_len_10b_8_bytes"><b><i>debug_len_10b_8_bytes</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_debug_len_10b_8_bytes"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If this attribute is set to TRUE (FALSE is the default), then the 10b length encoding in DR7 is taken to mean 8 bytes. If it is false, then 10b means 8 bytes in long mode, but only one byte in legacy mode.</dd></dl><p></p><dl><dt id="dt:disable_block_merge"><b><i>disable_block_merge</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_disable_block_merge"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Internal.</dd></dl><p></p><dl><dt id="dt:disabled_breakpoints_update_dr6"><b><i>disabled_breakpoints_update_dr6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_disabled_breakpoints_update_dr6"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Set to non-zero if you want debug breakpoints that are not enabled either through DR7.L nor DR7.G to still set the B bits in DR6.</dd></dl><p></p><dl><dt id="dt:do_not_schedule"><b><i>do_not_schedule</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_do_not_schedule"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Set to TRUE to prevent this object from being scheduled by the cell.</dd></dl><p></p><dl><dt id="dt:dr0"><b><i>dr0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_dr0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Debug register 0.</dd></dl><p></p><dl><dt id="dt:dr1"><b><i>dr1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_dr1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Debug register 1.</dd></dl><p></p><dl><dt id="dt:dr2"><b><i>dr2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_dr2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Debug register 2.</dd></dl><p></p><dl><dt id="dt:dr3"><b><i>dr3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_dr3"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Debug register 3.</dd></dl><p></p><dl><dt id="dt:dr6"><b><i>dr6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_dr6"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Debug register 6.</dd></dl><p></p><dl><dt id="dt:dr7"><b><i>dr7</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_dr7"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Debug register 7.</dd></dl><p></p><dl><dt id="dt:ds"><b><i>ds</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ds"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i{11}]</code>.
X86 segment register. All fields are stored in a list of integers as follows: <code>(</code><i>selector</i><code>, </code><i>d</i><code>, </code><i>dpl</i><code>, </code><i>g</i><code>, </code><i>p</i><code>, </code><i>s</i><code>, </code><i>type</i><code>, </code><i>base</i><code>, </code><i>limit</i><code>, </code><i>valid</i><code>, </code><i>l</i><code>)</code> The limit field always specifies the limit in bytes.</dd></dl><p></p><dl><dt id="dt:eflags"><b><i>eflags</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_eflags"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Flag register.</dd></dl><p></p><dl><dt id="dt:enable_effective_memory_type_calculation"><b><i>enable_effective_memory_type_calculation</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_enable_effective_memory_type_calculation"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If TRUE, the effective memory type field of memory transactions will always be calculated for all non-inquiry accesses. If FALSE, the effective memory type field may be left as X86_None.</dd></dl><p></p><dl><dt id="dt:enabled_flag"><b><i>enabled_flag</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_enabled_flag"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
TRUE if the processor is enabled. If FALSE, it will see time (cycles) pass but not execute steps.</dd></dl><p></p><dl><dt id="dt:es"><b><i>es</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_es"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i{11}]</code>.
X86 segment register. All fields are stored in a list of integers as follows: <code>(</code><i>selector</i><code>, </code><i>d</i><code>, </code><i>dpl</i><code>, </code><i>g</i><code>, </code><i>p</i><code>, </code><i>s</i><code>, </code><i>type</i><code>, </code><i>base</i><code>, </code><i>limit</i><code>, </code><i>valid</i><code>, </code><i>l</i><code>)</code> The limit field always specifies the limit in bytes.</dd></dl><p></p><dl><dt id="dt:event_desc"><b><i>event_desc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_event_desc"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; <b>integer</b> indexed;  indexed type: <code>[[o|n,s,i]*]</code>.
 ((<i>object</i>, <i>description</i>, <i>time</i>)*). All events in queue with a human-readable description. The attribute is indexed by queue (Sim_Queue_Step/Time).</dd></dl><p></p><dl><dt id="dt:exception_description"><b><i>exception_description</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_exception_description"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>string</code> or <code>nil</code>.
Description of current exception. Only valid when read from the <code>Core_Exception</code> hap. The value can be <code>Nil</code> in which case the exception number, source, and optional error code can be used to gain an understanding of why the exception triggered.</dd></dl><p></p><dl><dt id="dt:exception_error_code"><b><i>exception_error_code</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_exception_error_code"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
Error code for the current exception. Only valid when read from the <code>Core_Exception</code> hap. This attribute is undefined for exceptions that do not have an error code.</dd></dl><p></p><dl><dt id="dt:ext"><b><i>ext</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ext"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
A bit indicating if the current exception is external.</dd></dl><p></p><dl><dt id="dt:far_call_jmp_64"><b><i>far_call_jmp_64</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_far_call_jmp_64"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If this attribute is set to TRUE, far call and jmp instructions will have a 64-bit offset when the operand size is 64-bits. If FALSE, then the offset will be 32-bits with both 32-bit and 64-bit operand size.</dd></dl><p></p><dl><dt id="dt:ferr_status"><b><i>ferr_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ferr_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Status for the ferr output pin.</dd></dl><p></p><dl><dt id="dt:ferr_target"><b><i>ferr_target</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ferr_target"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
Object to which the FERR pin (used for external x87 exception emulation) is connected.</dd></dl><p></p><dl><dt id="dt:fpu_control"><b><i>fpu_control</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_control"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x87 FPU control register.</dd></dl><p></p><dl><dt id="dt:fpu_fopcode_compatibility_mode"><b><i>fpu_fopcode_compatibility_mode</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_fopcode_compatibility_mode"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Fopcode compatibility sub-mode.</dd></dl><p></p><dl><dt id="dt:fpu_last_instr_pointer"><b><i>fpu_last_instr_pointer</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_last_instr_pointer"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
FPU instruction pointer offset.</dd></dl><p></p><dl><dt id="dt:fpu_last_instr_selector"><b><i>fpu_last_instr_selector</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_last_instr_selector"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
FPU instruction pointer selector.</dd></dl><p></p><dl><dt id="dt:fpu_last_opcode"><b><i>fpu_last_opcode</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_last_opcode"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
FPU instruction opcode.</dd></dl><p></p><dl><dt id="dt:fpu_last_operand_pointer"><b><i>fpu_last_operand_pointer</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_last_operand_pointer"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
FPU operand pointer offset.</dd></dl><p></p><dl><dt id="dt:fpu_last_operand_selector"><b><i>fpu_last_operand_selector</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_last_operand_selector"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
FPU operand pointer selector.</dd></dl><p></p><dl><dt id="dt:fpu_regs"><b><i>fpu_regs</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_regs"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[[i{11}]{8}]</code>.
((empty, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9){8}). X86 floating point registers. The 8 80-bits registers is stored as a list of 11 bytes. The first byte tells if the register is empty (1) or not (0). The other bytes contain the register value with the lowest (least significant) bits in b0 and the highest (most significant bits in b9.</dd></dl><p></p><dl><dt id="dt:fpu_status"><b><i>fpu_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x87 FPU status register.</dd></dl><p></p><dl><dt id="dt:fpu_tag"><b><i>fpu_tag</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fpu_tag"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x87 FPU tag word.</dd></dl><p></p><dl><dt id="dt:freerun_enabled"><b><i>freerun_enabled</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_freerun_enabled"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Freerun mode enabled</dd></dl><p></p><dl><dt id="dt:freerun_max_ips"><b><i>freerun_max_ips</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_freerun_max_ips"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>float</code>.
Maximum allowed value for the number of instructions executed per virtual second, expressed as a fraction of the current CPU frequency.</dd></dl><p></p><dl><dt id="dt:freerun_min_ips"><b><i>freerun_min_ips</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_freerun_min_ips"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>float</code>.
Minimum allowed value for the number of instructions executed per virtual second, expressed as a fraction of the current CPU frequency.</dd></dl><p></p><dl><dt id="dt:freerun_speed"><b><i>freerun_speed</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_freerun_speed"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>float</code>.
Freerun speed. A value of 1.0 means realtime.</dd></dl><p></p><dl><dt id="dt:freq_mhz"><b><i>freq_mhz</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_freq_mhz"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>float</code> or <code>integer</code>.
Processor clock frequency in MHz.</dd></dl><p></p><dl><dt id="dt:frequency"><b><i>frequency</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_frequency"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[ii]</code>, <code>[os]</code>, or <code>object</code>.
Processor clock frequency in Hz, as a rational number [numerator, denominator], or as a frequency provider implementing the <code>frequency</code>. The legacy <code>simple_dispatcher</code> is also supported.</dd></dl><p></p><dl><dt id="dt:fs"><b><i>fs</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_fs"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i{11}]</code>.
X86 segment register. All fields are stored in a list of integers as follows: <code>(</code><i>selector</i><code>, </code><i>d</i><code>, </code><i>dpl</i><code>, </code><i>g</i><code>, </code><i>p</i><code>, </code><i>s</i><code>, </code><i>type</i><code>, </code><i>base</i><code>, </code><i>limit</i><code>, </code><i>valid</i><code>, </code><i>l</i><code>)</code> The limit field always specifies the limit in bytes.</dd></dl><p></p><dl><dt id="dt:gdtr_base"><b><i>gdtr_base</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_gdtr_base"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Global descriptor table base.</dd></dl><p></p><dl><dt id="dt:gdtr_limit"><b><i>gdtr_limit</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_gdtr_limit"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Global descriptor table limit.</dd></dl><p></p><dl><dt id="dt:gs"><b><i>gs</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_gs"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i{11}]</code>.
X86 segment register. All fields are stored in a list of integers as follows: <code>(</code><i>selector</i><code>, </code><i>d</i><code>, </code><i>dpl</i><code>, </code><i>g</i><code>, </code><i>p</i><code>, </code><i>s</i><code>, </code><i>type</i><code>, </code><i>base</i><code>, </code><i>limit</i><code>, </code><i>valid</i><code>, </code><i>l</i><code>)</code> The limit field always specifies the limit in bytes.</dd></dl><p></p><dl><dt id="dt:ia32_aperf"><b><i>ia32_aperf</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_aperf"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Actual Performance Frequency Clock Count</dd></dl><p></p><dl><dt id="dt:ia32_bios_sign_id"><b><i>ia32_bios_sign_id</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_bios_sign_id"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
BIOS Update Signature ID</dd></dl><p></p><dl><dt id="dt:ia32_bios_updt_trig"><b><i>ia32_bios_updt_trig</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_bios_updt_trig"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
BIOS Update Trigger Register</dd></dl><p></p><dl><dt id="dt:ia32_clock_modulation"><b><i>ia32_clock_modulation</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_clock_modulation"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Clock Modulation</dd></dl><p></p><dl><dt id="dt:ia32_cr_pat"><b><i>ia32_cr_pat</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_cr_pat"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
IA32_CR_PAT</dd></dl><p></p><dl><dt id="dt:ia32_debugctl"><b><i>ia32_debugctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_debugctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Debug Control</dd></dl><p></p><dl><dt id="dt:ia32_ds_area"><b><i>ia32_ds_area</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ds_area"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
DS Save Area</dd></dl><p></p><dl><dt id="dt:ia32_efer"><b><i>ia32_efer</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_efer"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Extended Feature Enables</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_cur_count"><b><i>ia32_ext_xapic_cur_count</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_cur_count"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Current Count register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_div_conf"><b><i>ia32_ext_xapic_div_conf</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_div_conf"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Divide Configuration register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_eoi"><b><i>ia32_ext_xapic_eoi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_eoi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC EOI register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_esr"><b><i>ia32_ext_xapic_esr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_esr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Error Status register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_icr"><b><i>ia32_ext_xapic_icr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_icr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Interrupt Command register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_init_count"><b><i>ia32_ext_xapic_init_count</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_init_count"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Initial Count register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_irr0"><b><i>ia32_ext_xapic_irr0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_irr0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Interrupt Request register bits [31:0]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_irr1"><b><i>ia32_ext_xapic_irr1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_irr1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Interrupt Request register bits [63:32]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_irr2"><b><i>ia32_ext_xapic_irr2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_irr2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Interrupt Request register bits [95:64]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_irr3"><b><i>ia32_ext_xapic_irr3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_irr3"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Interrupt Request register bits [127:96]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_irr4"><b><i>ia32_ext_xapic_irr4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_irr4"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Interrupt Request register bits [159:128]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_irr5"><b><i>ia32_ext_xapic_irr5</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_irr5"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Interrupt Request register bits [191:160]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_irr6"><b><i>ia32_ext_xapic_irr6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_irr6"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Interrupt Request register bits [223:192]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_irr7"><b><i>ia32_ext_xapic_irr7</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_irr7"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Interrupt Request register bits [255:224]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_isr0"><b><i>ia32_ext_xapic_isr0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_isr0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC In-Service register bits [31:0]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_isr1"><b><i>ia32_ext_xapic_isr1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_isr1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC In-Service register bits [63:32]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_isr2"><b><i>ia32_ext_xapic_isr2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_isr2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC In-Service register bits [95:64]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_isr3"><b><i>ia32_ext_xapic_isr3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_isr3"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC In-Service register bits [127:96]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_isr4"><b><i>ia32_ext_xapic_isr4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_isr4"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC In-Service register bits [159:128]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_isr5"><b><i>ia32_ext_xapic_isr5</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_isr5"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC In-Service register bits [191:160]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_isr6"><b><i>ia32_ext_xapic_isr6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_isr6"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC In-Service register bits [223:192]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_isr7"><b><i>ia32_ext_xapic_isr7</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_isr7"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC In-Service register bits [255:224]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_ldr"><b><i>ia32_ext_xapic_ldr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_ldr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Logical Destination register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_lvt_cmci"><b><i>ia32_ext_xapic_lvt_cmci</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_lvt_cmci"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC LVT Corrected Machine Check Interrupt register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_lvt_error"><b><i>ia32_ext_xapic_lvt_error</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_lvt_error"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC LVT Error register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_lvt_lint0"><b><i>ia32_ext_xapic_lvt_lint0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_lvt_lint0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC LVT LINT0 register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_lvt_lint1"><b><i>ia32_ext_xapic_lvt_lint1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_lvt_lint1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC LVT LINT1 register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_lvt_pmi"><b><i>ia32_ext_xapic_lvt_pmi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_lvt_pmi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC LVT Performance Monitor register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_lvt_thermal"><b><i>ia32_ext_xapic_lvt_thermal</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_lvt_thermal"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC LVT Thermal Sensor Interrupt register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_lvt_timer"><b><i>ia32_ext_xapic_lvt_timer</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_lvt_timer"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC LVT Timer Interrupt register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_ppr"><b><i>ia32_ext_xapic_ppr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_ppr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Processor Priority register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_self_ipi"><b><i>ia32_ext_xapic_self_ipi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_self_ipi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Self IPI register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_sivr"><b><i>ia32_ext_xapic_sivr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_sivr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Spurious Interrupt Vector register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_tmr0"><b><i>ia32_ext_xapic_tmr0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_tmr0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Trigger Mode register bits [31:0]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_tmr1"><b><i>ia32_ext_xapic_tmr1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_tmr1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Trigger Mode register bits [63:32]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_tmr2"><b><i>ia32_ext_xapic_tmr2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_tmr2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Trigger Mode register bits [95:64]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_tmr3"><b><i>ia32_ext_xapic_tmr3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_tmr3"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Trigger Mode register bits [127:96]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_tmr4"><b><i>ia32_ext_xapic_tmr4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_tmr4"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Trigger Mode register bits [159:128]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_tmr5"><b><i>ia32_ext_xapic_tmr5</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_tmr5"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Trigger Mode register bits [191:160]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_tmr6"><b><i>ia32_ext_xapic_tmr6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_tmr6"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Trigger Mode register bits [223:192]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_tmr7"><b><i>ia32_ext_xapic_tmr7</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_tmr7"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Trigger Mode register bits [255:224]</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_tpr"><b><i>ia32_ext_xapic_tpr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_tpr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Task Priority register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapic_version"><b><i>ia32_ext_xapic_version</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapic_version"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC Version register</dd></dl><p></p><dl><dt id="dt:ia32_ext_xapicid"><b><i>ia32_ext_xapicid</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_ext_xapicid"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
x2APIC ID register</dd></dl><p></p><dl><dt id="dt:ia32_feature_control"><b><i>ia32_feature_control</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_feature_control"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Control Features in Intel64 processor</dd></dl><p></p><dl><dt id="dt:ia32_fixed_ctr0"><b><i>ia32_fixed_ctr0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_fixed_ctr0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Fixed-Function Performance Counter Register 0</dd></dl><p></p><dl><dt id="dt:ia32_fixed_ctr1"><b><i>ia32_fixed_ctr1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_fixed_ctr1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Fixed-Function Performance Counter Register 1</dd></dl><p></p><dl><dt id="dt:ia32_fixed_ctr2"><b><i>ia32_fixed_ctr2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_fixed_ctr2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Fixed-Function Performance Counter Register 2</dd></dl><p></p><dl><dt id="dt:ia32_fixed_ctr_ctrl"><b><i>ia32_fixed_ctr_ctrl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_fixed_ctr_ctrl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Fixed-Function-Counter Control Register</dd></dl><p></p><dl><dt id="dt:ia32_fmask"><b><i>ia32_fmask</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_fmask"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
System Call Flag Mask</dd></dl><p></p><dl><dt id="dt:ia32_fs_base"><b><i>ia32_fs_base</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_fs_base"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Map of BASE Address of FS</dd></dl><p></p><dl><dt id="dt:ia32_gs_base"><b><i>ia32_gs_base</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_gs_base"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Map of BASE Address of GS</dd></dl><p></p><dl><dt id="dt:ia32_kernel_gs_base"><b><i>ia32_kernel_gs_base</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_kernel_gs_base"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Swap Target of BASE Address of GS</dd></dl><p></p><dl><dt id="dt:ia32_lstar"><b><i>ia32_lstar</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_lstar"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
IA-32e Mode System Call Target Address</dd></dl><p></p><dl><dt id="dt:ia32_mc0_addr"><b><i>ia32_mc0_addr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc0_addr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC0_ADDR</dd></dl><p></p><dl><dt id="dt:ia32_mc0_ctl"><b><i>ia32_mc0_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc0_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC0_CTL</dd></dl><p></p><dl><dt id="dt:ia32_mc0_ctl2"><b><i>ia32_mc0_ctl2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc0_ctl2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc0_status"><b><i>ia32_mc0_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc0_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC0_STATUS</dd></dl><p></p><dl><dt id="dt:ia32_mc1_addr"><b><i>ia32_mc1_addr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc1_addr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC1_ADDR</dd></dl><p></p><dl><dt id="dt:ia32_mc1_ctl"><b><i>ia32_mc1_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc1_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC1_CTL</dd></dl><p></p><dl><dt id="dt:ia32_mc1_ctl2"><b><i>ia32_mc1_ctl2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc1_ctl2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc1_status"><b><i>ia32_mc1_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc1_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC1_STATUS</dd></dl><p></p><dl><dt id="dt:ia32_mc2_addr"><b><i>ia32_mc2_addr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc2_addr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC2_ADDR</dd></dl><p></p><dl><dt id="dt:ia32_mc2_ctl"><b><i>ia32_mc2_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc2_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC2_CTL</dd></dl><p></p><dl><dt id="dt:ia32_mc2_ctl2"><b><i>ia32_mc2_ctl2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc2_ctl2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc2_status"><b><i>ia32_mc2_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc2_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC2_STATUS</dd></dl><p></p><dl><dt id="dt:ia32_mc3_ctl2"><b><i>ia32_mc3_ctl2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc3_ctl2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc4_ctl2"><b><i>ia32_mc4_ctl2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc4_ctl2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc5_ctl2"><b><i>ia32_mc5_ctl2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc5_ctl2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc6_ctl2"><b><i>ia32_mc6_ctl2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc6_ctl2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc7_ctl2"><b><i>ia32_mc7_ctl2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc7_ctl2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc7_status"><b><i>ia32_mc7_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc7_status"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc8_ctl2"><b><i>ia32_mc8_ctl2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc8_ctl2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mc8_status"><b><i>ia32_mc8_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mc8_status"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_mcg_cap"><b><i>ia32_mcg_cap</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mcg_cap"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Global Machine Check Capability</dd></dl><p></p><dl><dt id="dt:ia32_mcg_status"><b><i>ia32_mcg_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mcg_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Global Machine Check Status</dd></dl><p></p><dl><dt id="dt:ia32_misc_enable"><b><i>ia32_misc_enable</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_misc_enable"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Enable Misc. Processor Features</dd></dl><p></p><dl><dt id="dt:ia32_monitor_filter_size"><b><i>ia32_monitor_filter_size</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_monitor_filter_size"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Monitor/Mwait Address Range Determination</dd></dl><p></p><dl><dt id="dt:ia32_mperf"><b><i>ia32_mperf</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mperf"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Maximum Performance Frequency Clock Count</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_def_type"><b><i>ia32_mtrr_def_type</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_def_type"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Default Memory Types</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_16k_80000"><b><i>ia32_mtrr_fix_16k_80000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_16k_80000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix16K_80000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_16k_a0000"><b><i>ia32_mtrr_fix_16k_a0000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_16k_a0000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix16K_A0000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_4k_c0000"><b><i>ia32_mtrr_fix_4k_c0000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_4k_c0000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix4K_C0000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_4k_c8000"><b><i>ia32_mtrr_fix_4k_c8000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_4k_c8000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix4K_C8000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_4k_d0000"><b><i>ia32_mtrr_fix_4k_d0000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_4k_d0000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix4K_D0000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_4k_d8000"><b><i>ia32_mtrr_fix_4k_d8000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_4k_d8000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix4K_D8000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_4k_e0000"><b><i>ia32_mtrr_fix_4k_e0000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_4k_e0000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix4K_E0000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_4k_e8000"><b><i>ia32_mtrr_fix_4k_e8000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_4k_e8000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix4K_E8000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_4k_f0000"><b><i>ia32_mtrr_fix_4k_f0000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_4k_f0000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix4K_F0000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_4k_f8000"><b><i>ia32_mtrr_fix_4k_f8000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_4k_f8000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix4K_F8000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_fix_64k_00000"><b><i>ia32_mtrr_fix_64k_00000</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_fix_64k_00000"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRfix64K_00000</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physbase0"><b><i>ia32_mtrr_physbase0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physbase0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysBase0</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physbase1"><b><i>ia32_mtrr_physbase1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physbase1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysBase1</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physbase2"><b><i>ia32_mtrr_physbase2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physbase2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysBase2</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physbase3"><b><i>ia32_mtrr_physbase3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physbase3"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysBase3</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physbase4"><b><i>ia32_mtrr_physbase4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physbase4"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysBase4</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physbase5"><b><i>ia32_mtrr_physbase5</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physbase5"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysBase5</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physbase6"><b><i>ia32_mtrr_physbase6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physbase6"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysBase6</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physbase7"><b><i>ia32_mtrr_physbase7</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physbase7"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysBase7</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physmask0"><b><i>ia32_mtrr_physmask0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physmask0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysMask0</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physmask1"><b><i>ia32_mtrr_physmask1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physmask1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysMask1</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physmask2"><b><i>ia32_mtrr_physmask2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physmask2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysMask2</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physmask3"><b><i>ia32_mtrr_physmask3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physmask3"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysMask3</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physmask4"><b><i>ia32_mtrr_physmask4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physmask4"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysMask4</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physmask5"><b><i>ia32_mtrr_physmask5</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physmask5"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysMask5</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physmask6"><b><i>ia32_mtrr_physmask6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physmask6"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysMask6</dd></dl><p></p><dl><dt id="dt:ia32_mtrr_physmask7"><b><i>ia32_mtrr_physmask7</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrr_physmask7"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRRphysMask7</dd></dl><p></p><dl><dt id="dt:ia32_mtrrcap"><b><i>ia32_mtrrcap</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_mtrrcap"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MTRR Capability</dd></dl><p></p><dl><dt id="dt:ia32_p5_mc_addr"><b><i>ia32_p5_mc_addr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_p5_mc_addr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_p5_mc_type"><b><i>ia32_p5_mc_type</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_p5_mc_type"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_pebs_enable"><b><i>ia32_pebs_enable</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_pebs_enable"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
PEBS Control</dd></dl><p></p><dl><dt id="dt:ia32_perf_capabilities"><b><i>ia32_perf_capabilities</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_perf_capabilities"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_perf_ctl"><b><i>ia32_perf_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_perf_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_perf_global_ctrl"><b><i>ia32_perf_global_ctrl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_perf_global_ctrl"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Global Performance Counter Control</dd></dl><p></p><dl><dt id="dt:ia32_perf_global_status"><b><i>ia32_perf_global_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_perf_global_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Global Performance Counter Status</dd></dl><p></p><dl><dt id="dt:ia32_perf_status"><b><i>ia32_perf_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_perf_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_perfevtsel0"><b><i>ia32_perfevtsel0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_perfevtsel0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Performance Event Select Register 0</dd></dl><p></p><dl><dt id="dt:ia32_perfevtsel1"><b><i>ia32_perfevtsel1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_perfevtsel1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Performance Event Select Register 1</dd></dl><p></p><dl><dt id="dt:ia32_perfevtsel2"><b><i>ia32_perfevtsel2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_perfevtsel2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_perfevtsel3"><b><i>ia32_perfevtsel3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_perfevtsel3"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_platform_id"><b><i>ia32_platform_id</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_platform_id"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Platform ID</dd></dl><p></p><dl><dt id="dt:ia32_pmc0"><b><i>ia32_pmc0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_pmc0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Performance counter register</dd></dl><p></p><dl><dt id="dt:ia32_pmc1"><b><i>ia32_pmc1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_pmc1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Performance counter register</dd></dl><p></p><dl><dt id="dt:ia32_pmc2"><b><i>ia32_pmc2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_pmc2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Performance counter register</dd></dl><p></p><dl><dt id="dt:ia32_pmc3"><b><i>ia32_pmc3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_pmc3"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Performance counter register</dd></dl><p></p><dl><dt id="dt:ia32_reserved_194"><b><i>ia32_reserved_194</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_reserved_194"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Reserved MSR at 0x194</dd></dl><p></p><dl><dt id="dt:ia32_smrr_physbase"><b><i>ia32_smrr_physbase</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_smrr_physbase"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_smrr_physmask"><b><i>ia32_smrr_physmask</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_smrr_physmask"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:ia32_star"><b><i>ia32_star</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_star"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
System Call Target Address</dd></dl><p></p><dl><dt id="dt:ia32_sysenter_cs"><b><i>ia32_sysenter_cs</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_sysenter_cs"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
SYSENTER_CS_MSR</dd></dl><p></p><dl><dt id="dt:ia32_sysenter_eip"><b><i>ia32_sysenter_eip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_sysenter_eip"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
SYSENTER_EIP_MSR</dd></dl><p></p><dl><dt id="dt:ia32_sysenter_esp"><b><i>ia32_sysenter_esp</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_sysenter_esp"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
SYSENTER_ESP_MSR</dd></dl><p></p><dl><dt id="dt:ia32_therm_interrupt"><b><i>ia32_therm_interrupt</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_therm_interrupt"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Thermal Interrupt Control</dd></dl><p></p><dl><dt id="dt:ia32_therm_status"><b><i>ia32_therm_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_therm_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Thermal Monitor Status</dd></dl><p></p><dl><dt id="dt:ia32_time_stamp_counter"><b><i>ia32_time_stamp_counter</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_time_stamp_counter"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Time-Stamp Counter</dd></dl><p></p><dl><dt id="dt:ia32_tsc_aux"><b><i>ia32_tsc_aux</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_tsc_aux"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
AUXILIARY TSC Signature</dd></dl><p></p><dl><dt id="dt:ia32_unknown_130"><b><i>ia32_unknown_130</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_130"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x130</dd></dl><p></p><dl><dt id="dt:ia32_unknown_131"><b><i>ia32_unknown_131</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_131"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x131</dd></dl><p></p><dl><dt id="dt:ia32_unknown_178"><b><i>ia32_unknown_178</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_178"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x178</dd></dl><p></p><dl><dt id="dt:ia32_unknown_19d"><b><i>ia32_unknown_19d</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_19d"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x19d</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1a4"><b><i>ia32_unknown_1a4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1a4"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1a4</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1a7"><b><i>ia32_unknown_1a7</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1a7"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1a7</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1aa"><b><i>ia32_unknown_1aa</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1aa"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1aa</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1ac"><b><i>ia32_unknown_1ac</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1ac"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1ac</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1c6"><b><i>ia32_unknown_1c6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1c6"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1c6</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1db"><b><i>ia32_unknown_1db</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1db"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1db</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1dc"><b><i>ia32_unknown_1dc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1dc"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1dc</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1f0"><b><i>ia32_unknown_1f0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1f0"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1f0</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1f1"><b><i>ia32_unknown_1f1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1f1"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1f1</dd></dl><p></p><dl><dt id="dt:ia32_unknown_1fc"><b><i>ia32_unknown_1fc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_1fc"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x1fc</dd></dl><p></p><dl><dt id="dt:ia32_unknown_2a"><b><i>ia32_unknown_2a</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_2a"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x2a</dd></dl><p></p><dl><dt id="dt:ia32_unknown_2d"><b><i>ia32_unknown_2d</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_2d"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x2d</dd></dl><p></p><dl><dt id="dt:ia32_unknown_2e"><b><i>ia32_unknown_2e</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_2e"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x2e</dd></dl><p></p><dl><dt id="dt:ia32_unknown_2e0"><b><i>ia32_unknown_2e0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_2e0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x2e0</dd></dl><p></p><dl><dt id="dt:ia32_unknown_300"><b><i>ia32_unknown_300</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_300"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x300</dd></dl><p></p><dl><dt id="dt:ia32_unknown_33"><b><i>ia32_unknown_33</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_33"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x33</dd></dl><p></p><dl><dt id="dt:ia32_unknown_35"><b><i>ia32_unknown_35</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_35"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x35</dd></dl><p></p><dl><dt id="dt:ia32_unknown_398"><b><i>ia32_unknown_398</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_398"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x398</dd></dl><p></p><dl><dt id="dt:ia32_unknown_399"><b><i>ia32_unknown_399</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_399"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x399</dd></dl><p></p><dl><dt id="dt:ia32_unknown_39a"><b><i>ia32_unknown_39a</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_39a"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x39a</dd></dl><p></p><dl><dt id="dt:ia32_unknown_3d0"><b><i>ia32_unknown_3d0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_3d0"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x3d0</dd></dl><p></p><dl><dt id="dt:ia32_unknown_3d1"><b><i>ia32_unknown_3d1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_3d1"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x3d1</dd></dl><p></p><dl><dt id="dt:ia32_unknown_3d8"><b><i>ia32_unknown_3d8</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_3d8"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x3d8</dd></dl><p></p><dl><dt id="dt:ia32_unknown_3d9"><b><i>ia32_unknown_3d9</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_3d9"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x3d9</dd></dl><p></p><dl><dt id="dt:ia32_unknown_3fe"><b><i>ia32_unknown_3fe</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_3fe"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x3fe</dd></dl><p></p><dl><dt id="dt:ia32_unknown_4b"><b><i>ia32_unknown_4b</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_4b"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x4b</dd></dl><p></p><dl><dt id="dt:ia32_unknown_9b"><b><i>ia32_unknown_9b</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_9b"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0x9b</dd></dl><p></p><dl><dt id="dt:ia32_unknown_e2"><b><i>ia32_unknown_e2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_e2"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0xe2</dd></dl><p></p><dl><dt id="dt:ia32_unknown_e4"><b><i>ia32_unknown_e4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_unknown_e4"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Unknown MSR at 0xe4</dd></dl><p></p><dl><dt id="dt:ia32_vmx_basic"><b><i>ia32_vmx_basic</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_basic"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Reporting Register of Basic VMX Capabilities</dd></dl><p></p><dl><dt id="dt:ia32_vmx_cr0_fixed0"><b><i>ia32_vmx_cr0_fixed0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_cr0_fixed0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of CR0 Bits Fixed to 0</dd></dl><p></p><dl><dt id="dt:ia32_vmx_cr0_fixed1"><b><i>ia32_vmx_cr0_fixed1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_cr0_fixed1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of CR0 Bits Fixed to 1</dd></dl><p></p><dl><dt id="dt:ia32_vmx_cr4_fixed0"><b><i>ia32_vmx_cr4_fixed0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_cr4_fixed0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of CR4 Bits Fixed to 0</dd></dl><p></p><dl><dt id="dt:ia32_vmx_cr4_fixed1"><b><i>ia32_vmx_cr4_fixed1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_cr4_fixed1"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of CR4 Bits Fixed to 1</dd></dl><p></p><dl><dt id="dt:ia32_vmx_entry_ctls"><b><i>ia32_vmx_entry_ctls</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_entry_ctls"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of VM-entry Controls</dd></dl><p></p><dl><dt id="dt:ia32_vmx_ept_vpid_cap"><b><i>ia32_vmx_ept_vpid_cap</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_ept_vpid_cap"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of EPT and VPID</dd></dl><p></p><dl><dt id="dt:ia32_vmx_exit_ctls"><b><i>ia32_vmx_exit_ctls</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_exit_ctls"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of VM-exit Controls</dd></dl><p></p><dl><dt id="dt:ia32_vmx_misc"><b><i>ia32_vmx_misc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_misc"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Reporting Register of Miscellaneous VMX Capabilities</dd></dl><p></p><dl><dt id="dt:ia32_vmx_pinbased_ctls"><b><i>ia32_vmx_pinbased_ctls</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_pinbased_ctls"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of Pin-based VM-execution Controls</dd></dl><p></p><dl><dt id="dt:ia32_vmx_procbased_ctls"><b><i>ia32_vmx_procbased_ctls</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_procbased_ctls"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of Primary Processor-based VM-execution Controls</dd></dl><p></p><dl><dt id="dt:ia32_vmx_procbased_ctls2"><b><i>ia32_vmx_procbased_ctls2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_procbased_ctls2"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of Secondary Processor-based VM-execution Controls</dd></dl><p></p><dl><dt id="dt:ia32_vmx_true_entry_ctls"><b><i>ia32_vmx_true_entry_ctls</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_true_entry_ctls"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of VM-entry Controls</dd></dl><p></p><dl><dt id="dt:ia32_vmx_true_exit_ctls"><b><i>ia32_vmx_true_exit_ctls</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_true_exit_ctls"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of VM-exit Controls</dd></dl><p></p><dl><dt id="dt:ia32_vmx_true_pinbased_ctls"><b><i>ia32_vmx_true_pinbased_ctls</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_true_pinbased_ctls"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of Pin-based VM-execution Controls</dd></dl><p></p><dl><dt id="dt:ia32_vmx_true_procbased_ctls"><b><i>ia32_vmx_true_procbased_ctls</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_true_procbased_ctls"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of Primary Processor-based VM-execution Controls</dd></dl><p></p><dl><dt id="dt:ia32_vmx_vmcs_enum"><b><i>ia32_vmx_vmcs_enum</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ia32_vmx_vmcs_enum"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Capability Reporting Register of VMCS Field Enumeration</dd></dl><p></p><dl><dt id="dt:idtr_base"><b><i>idtr_base</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_idtr_base"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Interrupt descriptor table base.</dd></dl><p></p><dl><dt id="dt:idtr_limit"><b><i>idtr_limit</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_idtr_limit"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Interrupt descriptor table limit.</dd></dl><p></p><dl><dt id="dt:ignne_status"><b><i>ignne_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ignne_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Status for the ignne input pin.</dd></dl><p></p><dl><dt id="dt:ignore_page_failed_before"><b><i>ignore_page_failed_before</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ignore_page_failed_before"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If TRUE, the model will keep trying to cache memory through direct memory even if it fails.</dd></dl><p></p><dl><dt id="dt:in_smm"><b><i>in_smm</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_in_smm"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Set iff the processor is in system management mode.</dd></dl><p></p><dl><dt id="dt:init_vm_monitor"><b><i>init_vm_monitor</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_init_vm_monitor"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Setting this attribute to true enables the use of virtual machine monitor acceleration. The attribute will flag it as an illegal value if the virtual machine monitor kernel module could not be found, or if there was an error opening a connection to it (the attribute reads back as false in those cases). Acceleration will not be used unless the use_vm_monitor attribute is also set to true.</dd></dl><p></p><dl><dt id="dt:inject_vmexit"><b><i>inject_vmexit</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_inject_vmexit"></a></p><dd><b>Pseudo</b> attribute; <b>write-only</b> access; type: <code>integer</code>.
Force a VMEXIT from VMX mode.</dd></dl><p></p><dl><dt id="dt:is_stalling"><b><i>is_stalling</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_is_stalling"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
TRUE if the processor is currently stalling by request of a timing-model.</dd></dl><p></p><dl><dt id="dt:lar_ldt_lm_invalid"><b><i>lar_ldt_lm_invalid</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_lar_ldt_lm_invalid"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If this attribute is set to TRUE (FALSE is the default), then the LDT segment type will not be considered valid for the LAR instruction while operating in long mode.</dd></dl><p></p><dl><dt id="dt:last_io"><b><i>last_io</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_last_io"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[iiii]</code>.
Information about last IO instruction (pc, lin_addr, iinfo, step_count).</dd></dl><p></p><dl><dt id="dt:latch_init"><b><i>latch_init</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_latch_init"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
INIT is currently latched.</dd></dl><p></p><dl><dt id="dt:latch_nmi"><b><i>latch_nmi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_latch_nmi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
NMI is currently latched.</dd></dl><p></p><dl><dt id="dt:latch_smi"><b><i>latch_smi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_latch_smi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
SMI is currently latched.</dd></dl><p></p><dl><dt id="dt:ldtr"><b><i>ldtr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ldtr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i{11}]</code>.
X86 segment register. All fields are stored in a list of integers as follows: <code>(</code><i>selector</i><code>, </code><i>d</i><code>, </code><i>dpl</i><code>, </code><i>g</i><code>, </code><i>p</i><code>, </code><i>s</i><code>, </code><i>type</i><code>, </code><i>base</i><code>, </code><i>limit</i><code>, </code><i>valid</i><code>, </code><i>l</i><code>)</code> The limit field always specifies the limit in bytes.</dd></dl><p></p><dl><dt id="dt:load_far_ptr_64"><b><i>load_far_ptr_64</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_load_far_ptr_64"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If TRUE, the load far pointer instructions are extended to 64-bit when executed with a 64-bit operand size. The default is FALSE, which treats 64-bit and 32-bit operand size the same.</dd></dl><p></p><dl><dt id="dt:ma_prot"><b><i>ma_prot</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ma_prot"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>string</code>.
MP protocol. One of {'msi', 'ww', 'wwp'}</dd></dl><p></p><dl><dt id="dt:mc0_misc"><b><i>mc0_misc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_mc0_misc"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:mc1_misc"><b><i>mc1_misc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_mc1_misc"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:mca_concurrency_mode"><b><i>mca_concurrency_mode</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_mca_concurrency_mode"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Multicore Accelerator mode used by processor. One of Sim_Concurrency_Mode_Serialized (1), Sim_Concurrency_Mode_Serialized_Memory (2), or Sim_Concurrency_Mode_Full (4)</dd></dl><p></p><dl><dt id="dt:min_cacheline_size"><b><i>min_cacheline_size</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_min_cacheline_size"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
The minimum size (in bytes) of a cache line that can be represented by Simics (when connecting a cache memhier).</dd></dl><p></p><dl><dt id="dt:monitor_info"><b><i>monitor_info</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_monitor_info"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[bbi]</code>.
(armed, fired, address). Information about MONITOR. The MONITOR is armed if the first element in the list is true. The last element in the list contains the monitored physical address, and the second element indicates if the monitor has fired which means that the CPU should wake up.</dd></dl><p></p><dl><dt id="dt:mov_default32"><b><i>mov_default32</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_mov_default32"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If TRUE, movs to or from control and debug registers will default to 32-bits in 64-bit mode. If FALSE (which is the default value), such moves will be fixed at 64-bits.</dd></dl><p></p><dl><dt id="dt:msr_aperf"><b><i>msr_aperf</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_aperf"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Value of the APERF MSR.</dd></dl><p></p><dl><dt id="dt:msr_core_c3_residency"><b><i>msr_core_c3_residency</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_core_c3_residency"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_core_c6_residency"><b><i>msr_core_c6_residency</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_core_c6_residency"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_gq_snoop_mesf"><b><i>msr_gq_snoop_mesf</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_gq_snoop_mesf"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_0_from_ip"><b><i>msr_lastbranch_0_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_0_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 0 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_0_to_ip"><b><i>msr_lastbranch_0_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_0_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 0 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_10_from_ip"><b><i>msr_lastbranch_10_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_10_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 10 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_10_to_ip"><b><i>msr_lastbranch_10_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_10_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 10 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_11_from_ip"><b><i>msr_lastbranch_11_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_11_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 11 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_11_to_ip"><b><i>msr_lastbranch_11_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_11_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 11 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_12_from_ip"><b><i>msr_lastbranch_12_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_12_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 12 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_12_to_ip"><b><i>msr_lastbranch_12_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_12_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 12 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_13_from_ip"><b><i>msr_lastbranch_13_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_13_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 13 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_13_to_ip"><b><i>msr_lastbranch_13_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_13_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 13 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_14_from_ip"><b><i>msr_lastbranch_14_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_14_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 14 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_14_to_ip"><b><i>msr_lastbranch_14_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_14_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 14 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_15_from_ip"><b><i>msr_lastbranch_15_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_15_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 15 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_15_to_ip"><b><i>msr_lastbranch_15_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_15_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 15 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_1_from_ip"><b><i>msr_lastbranch_1_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_1_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 1 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_1_to_ip"><b><i>msr_lastbranch_1_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_1_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 1 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_2_from_ip"><b><i>msr_lastbranch_2_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_2_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 2 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_2_to_ip"><b><i>msr_lastbranch_2_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_2_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 2 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_3_from_ip"><b><i>msr_lastbranch_3_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_3_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 3 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_3_to_ip"><b><i>msr_lastbranch_3_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_3_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 3 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_4_from_ip"><b><i>msr_lastbranch_4_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_4_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 4 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_4_to_ip"><b><i>msr_lastbranch_4_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_4_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 4 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_5_from_ip"><b><i>msr_lastbranch_5_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_5_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 5 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_5_to_ip"><b><i>msr_lastbranch_5_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_5_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 5 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_6_from_ip"><b><i>msr_lastbranch_6_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_6_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 6 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_6_to_ip"><b><i>msr_lastbranch_6_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_6_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 6 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_7_from_ip"><b><i>msr_lastbranch_7_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_7_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 7 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_7_to_ip"><b><i>msr_lastbranch_7_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_7_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 7 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_8_from_ip"><b><i>msr_lastbranch_8_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_8_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 8 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_8_to_ip"><b><i>msr_lastbranch_8_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_8_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 8 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_9_from_ip"><b><i>msr_lastbranch_9_from_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_9_from_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 9 From IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_9_to_ip"><b><i>msr_lastbranch_9_to_ip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_9_to_ip"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record 9 To IP</dd></dl><p></p><dl><dt id="dt:msr_lastbranch_tos"><b><i>msr_lastbranch_tos</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lastbranch_tos"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record Stack TOS</dd></dl><p></p><dl><dt id="dt:msr_lbr_select"><b><i>msr_lbr_select</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_lbr_select"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Branch Record Filtering Select Register</dd></dl><p></p><dl><dt id="dt:msr_ler_from_lip"><b><i>msr_ler_from_lip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_ler_from_lip"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Exception Record From Linear IP</dd></dl><p></p><dl><dt id="dt:msr_ler_to_lip"><b><i>msr_ler_to_lip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_ler_to_lip"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Last Exception Record To Linear IP</dd></dl><p></p><dl><dt id="dt:msr_mc3_addr"><b><i>msr_mc3_addr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc3_addr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC3_ADDR</dd></dl><p></p><dl><dt id="dt:msr_mc3_ctl"><b><i>msr_mc3_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc3_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC3_CTL</dd></dl><p></p><dl><dt id="dt:msr_mc3_status"><b><i>msr_mc3_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc3_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC3_STATUS</dd></dl><p></p><dl><dt id="dt:msr_mc4_ctl"><b><i>msr_mc4_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc4_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC4_CTL</dd></dl><p></p><dl><dt id="dt:msr_mc4_status"><b><i>msr_mc4_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc4_status"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MC4_STATUS</dd></dl><p></p><dl><dt id="dt:msr_mc5_addr"><b><i>msr_mc5_addr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc5_addr"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc5_ctl"><b><i>msr_mc5_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc5_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc5_misc"><b><i>msr_mc5_misc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc5_misc"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc5_status"><b><i>msr_mc5_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc5_status"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc6_addr"><b><i>msr_mc6_addr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc6_addr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc6_ctl"><b><i>msr_mc6_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc6_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc6_misc"><b><i>msr_mc6_misc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc6_misc"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc6_status"><b><i>msr_mc6_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc6_status"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc7_ctl"><b><i>msr_mc7_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc7_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc8_addr"><b><i>msr_mc8_addr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc8_addr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc8_ctl"><b><i>msr_mc8_ctl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc8_ctl"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mc8_misc"><b><i>msr_mc8_misc</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mc8_misc"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_mperf"><b><i>msr_mperf</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_mperf"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Value of the MPERF MSR.</dd></dl><p></p><dl><dt id="dt:msr_offcore_rspo"><b><i>msr_offcore_rspo</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_offcore_rspo"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Offcore Response Event Select Register</dd></dl><p></p><dl><dt id="dt:msr_pebs_ld_latm"><b><i>msr_pebs_ld_latm</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_pebs_ld_latm"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_pkg_c3_residency"><b><i>msr_pkg_c3_residency</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_pkg_c3_residency"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_pkg_c6_residency"><b><i>msr_pkg_c6_residency</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_pkg_c6_residency"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_pkg_c7_residency"><b><i>msr_pkg_c7_residency</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_pkg_c7_residency"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_platform_info"><b><i>msr_platform_info</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_platform_info"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_temperature_target"><b><i>msr_temperature_target</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_temperature_target"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_turbo_ratio_limit"><b><i>msr_turbo_ratio_limit</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_turbo_ratio_limit"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_addr_opcode_match"><b><i>msr_uncore_addr_opcode_match</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_addr_opcode_match"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_fixed_ctr0"><b><i>msr_uncore_fixed_ctr0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_fixed_ctr0"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_fixed_ctr_ctrl"><b><i>msr_uncore_fixed_ctr_ctrl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_fixed_ctr_ctrl"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perf_global_ctrl"><b><i>msr_uncore_perf_global_ctrl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perf_global_ctrl"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perf_global_ovf_ctrl"><b><i>msr_uncore_perf_global_ovf_ctrl</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perf_global_ovf_ctrl"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perf_global_status"><b><i>msr_uncore_perf_global_status</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perf_global_status"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perfevtsel0"><b><i>msr_uncore_perfevtsel0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perfevtsel0"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perfevtsel1"><b><i>msr_uncore_perfevtsel1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perfevtsel1"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perfevtsel2"><b><i>msr_uncore_perfevtsel2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perfevtsel2"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perfevtsel3"><b><i>msr_uncore_perfevtsel3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perfevtsel3"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perfevtsel4"><b><i>msr_uncore_perfevtsel4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perfevtsel4"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perfevtsel5"><b><i>msr_uncore_perfevtsel5</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perfevtsel5"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perfevtsel6"><b><i>msr_uncore_perfevtsel6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perfevtsel6"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_perfevtsel7"><b><i>msr_uncore_perfevtsel7</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_perfevtsel7"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_pmc0"><b><i>msr_uncore_pmc0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_pmc0"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_pmc1"><b><i>msr_uncore_pmc1</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_pmc1"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_pmc2"><b><i>msr_uncore_pmc2</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_pmc2"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_pmc3"><b><i>msr_uncore_pmc3</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_pmc3"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_pmc4"><b><i>msr_uncore_pmc4</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_pmc4"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_pmc5"><b><i>msr_uncore_pmc5</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_pmc5"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_pmc6"><b><i>msr_uncore_pmc6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_pmc6"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:msr_uncore_pmc7"><b><i>msr_uncore_pmc7</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_msr_uncore_pmc7"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
</dd></dl><p></p><dl><dt id="dt:multicore_accelerator_enabled"><b><i>multicore_accelerator_enabled</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_multicore_accelerator_enabled"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Multicore Accelerator enabled for processor.</dd></dl><p></p><dl><dt id="dt:mwait_extensions"><b><i>mwait_extensions</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_mwait_extensions"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Extensions passed to the MWAIT instruction through ECX.</dd></dl><p></p><dl><dt id="dt:mwait_hints"><b><i>mwait_hints</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_mwait_hints"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Hints passed to the MWAIT instruction through EAX.</dd></dl><p></p><dl><dt id="dt:mxcsr"><b><i>mxcsr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_mxcsr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
XMM control register.</dd></dl><p></p><dl><dt id="dt:mxcsr_mask"><b><i>mxcsr_mask</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_mxcsr_mask"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
MXCSR mask (0 means 0xffbf).</dd></dl><p></p><dl><dt id="dt:near_branches_64"><b><i>near_branches_64</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_near_branches_64"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Determines how near branches are handled in 64-bit mode. If the attribute is TRUE, then the operand size is fixed at 64-bits, while the default value of FALSE allows an override to 16 bits.</dd></dl><p></p><dl><dt id="dt:non_architecturally_disabled"><b><i>non_architecturally_disabled</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_non_architecturally_disabled"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If true, the processor is disabled by explicit user action and will not execute instructions until re-enabled by user. No architectural transitions, such as resets, will re-enable it on their own.</dd></dl><p></p><dl><dt id="dt:null_clear_base_and_limit"><b><i>null_clear_base_and_limit</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_null_clear_base_and_limit"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If TRUE, a load of a NULL selector to a segment register will clear the base and limit values.</dd></dl><p></p><dl><dt id="dt:one_step_per_string_instruction"><b><i>one_step_per_string_instruction</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_one_step_per_string_instruction"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If TRUE, each un-interrupted run of a repeated string instruction (CMPS, LODS, MOVS, SCAS, STOS) will be counted as a single step as compared to each iteration being a step in the default model. Due to how instruction counting works in the hardware performance counters, this attribute must be set to TRUE for VMP to work. Setting this attribute to FALSE will disable VMP.</dd></dl><p></p><dl><dt id="dt:outside_memory_whitelist"><b><i>outside_memory_whitelist</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_outside_memory_whitelist"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i|[ii]|[iii]*]</code>.
((<i>address</i>, <i>length</i>, <i>hits</i>)*).<br><br>List of physical address ranges that do not map to anything. <i>length</i> is the length of each interval in bytes. An interval with both <i>address</i> and <i>length</i> being 0 denotes the entire address space. <i>hits</i> is the number of times that particular interval has been accessed, and can be omitted when set.<br><br> Accesses to physical addresses with no targets will trigger a specific hap whose default action is to break the simulation. However, if the address falls into one of the ranges specified in this whitelist, the hap will <em>not</em> be triggered (but still being counted). The behavior in this scenario is architecture dependent. It may or may not trigger an architecture specific exception, and the simulation may or may not be interrupted.<br><br> See also the <code>Core_Address_Not_Mapped</code> hap.</dd></dl><p></p><dl><dt id="dt:package_group"><b><i>package_group</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_package_group"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
The first Simics processor contained in the same multicore package. Used for shared MSR:s. Needs to point to a processor of the same class.</dd></dl><p></p><dl><dt id="dt:pause_slow_cycles"><b><i>pause_slow_cycles</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pause_slow_cycles"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Stall cycles for the PAUSE instruction. This additional stall is there to allow execution of spin-locks to consume more virtual time per iteration, leading to faster simulation performance. The default for VMP is to stall for 10 micro-seconds.</dd></dl><p></p><dl><dt id="dt:pdpte"><b><i>pdpte</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pdpte"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i{4}]</code>.
PDPTE registers.</dd></dl><p></p><dl><dt id="dt:pending_debug_exception"><b><i>pending_debug_exception</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_debug_exception"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
A debug exception is pending. Additional information about the exception is stored in pending_debug_exception_dr6.</dd></dl><p></p><dl><dt id="dt:pending_debug_exception_dr6"><b><i>pending_debug_exception_dr6</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_debug_exception_dr6"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Valid if pending_debug_exception is non-zero. Attribute has the same format as the DR6 register.</dd></dl><p></p><dl><dt id="dt:pending_exception"><b><i>pending_exception</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_exception"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If this attribute is TRUE, then an exception or interrupt is pending and will be delivered before the next instruction.</dd></dl><p></p><dl><dt id="dt:pending_exception_error_code"><b><i>pending_exception_error_code</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_exception_error_code"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Error code to be delivered on the next pending exception if pending_exception_error_code_valid is set.</dd></dl><p></p><dl><dt id="dt:pending_exception_error_code_valid"><b><i>pending_exception_error_code_valid</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_exception_error_code_valid"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If this attribute is TRUE, then the pending exception has an error code.</dd></dl><p></p><dl><dt id="dt:pending_exception_instruction_length"><b><i>pending_exception_instruction_length</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_exception_instruction_length"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Length of pending trap instruction.</dd></dl><p></p><dl><dt id="dt:pending_exception_set_rf"><b><i>pending_exception_set_rf</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_exception_set_rf"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If this attribute is TRUE, then the resume flag bit will be set in the pushed image of the flag register.</dd></dl><p></p><dl><dt id="dt:pending_exception_type"><b><i>pending_exception_type</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_exception_type"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Type of pending exception. </dd></dl><p></p><dl><dt id="dt:pending_exception_vector"><b><i>pending_exception_vector</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_exception_vector"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Pending interrupt or exception vector. Only valid if pending_exception is set.</dd></dl><p></p><dl><dt id="dt:pending_init"><b><i>pending_init</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_init"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Pending INIT</dd></dl><p></p><dl><dt id="dt:pending_reset"><b><i>pending_reset</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_reset"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Pending RESET</dd></dl><p></p><dl><dt id="dt:pending_start_up"><b><i>pending_start_up</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_start_up"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
If 1, a startup IPI is pending.</dd></dl><p></p><dl><dt id="dt:pending_start_up_address"><b><i>pending_start_up_address</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_pending_start_up_address"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
The address to start on if there is a pending startup IPI.</dd></dl><p></p><dl><dt id="dt:physical_memory"><b><i>physical_memory</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_physical_memory"></a></p><dd><b>Required</b> attribute; <b>read/write</b> access; type: <code>object</code>.
Physical memory space. Must implement memory-space, breakpoint and breakpoint_query interfaces.</dd></dl><p></p><dl><dt id="dt:port_io_slow_cycles"><b><i>port_io_slow_cycles</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_port_io_slow_cycles"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Stall cycles for port-mapped I/O. This additional stall is there to allow I/O poll loops to consume more virtual time per iteration, leading to faster simulation performance. The default for VMP is to stall for 10 micro-seconds.</dd></dl><p></p><dl><dt id="dt:port_space"><b><i>port_space</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_port_space"></a></p><dd><b>Required</b> attribute; <b>read/write</b> access; type: <code>object</code>.
I/O space of the cpu targeted by the IN, INS, OUT, and OUTS instructions. Must implement either the <code>port</code> interface (typically an instance of the <code>port-space</code> class), or the <code>lookup</code> interface (typically an instance of the <code>memory-space</code> class).</dd></dl><p></p><dl><dt id="dt:processor_number"><b><i>processor_number</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_processor_number"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Simics internal number for an instance of the 'processor_info' interface. Each instance must have a unique number. This attribute can only be set as part of an initial configuration.</dd></dl><p></p><dl><dt id="dt:r10"><b><i>r10</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_r10"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:r11"><b><i>r11</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_r11"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:r12"><b><i>r12</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_r12"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:r13"><b><i>r13</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_r13"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:r14"><b><i>r14</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_r14"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:r15"><b><i>r15</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_r15"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:r8"><b><i>r8</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_r8"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:r9"><b><i>r9</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_r9"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:rax"><b><i>rax</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rax"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:rbp"><b><i>rbp</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rbp"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:rbx"><b><i>rbx</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rbx"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:rcx"><b><i>rcx</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rcx"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:rdi"><b><i>rdi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rdi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:rdtsc_slow_cycles"><b><i>rdtsc_slow_cycles</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rdtsc_slow_cycles"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Stall cycles for the RDTSC and RDTSCP instructions. This additional stall is there to allow time expiration loops to consume more virtual time per iteration, leading to faster simulation performance. The default for VMP is to stall for 10 micro-seconds.</dd></dl><p></p><dl><dt id="dt:rdx"><b><i>rdx</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rdx"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:rip"><b><i>rip</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rip"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Instruction pointer.</dd></dl><p></p><dl><dt id="dt:rsi"><b><i>rsi</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rsi"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:rsp"><b><i>rsp</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_rsp"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
General purpose register.</dd></dl><p></p><dl><dt id="dt:seg_push_zero_pad"><b><i>seg_push_zero_pad</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_seg_push_zero_pad"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If this attribute is set to TRUE (which is the default), then segment register push instructions will pad the push with zero bytes up to the width of the push. If false, then that memory will be kept untouched.</dd></dl><p></p><dl><dt id="dt:shared_physical_memory"><b><i>shared_physical_memory</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_shared_physical_memory"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
Points to the object representing the memory space shared between threads/cores. This is used to set up the monitoring to emulate MONITOR/MWAIT. If this is set to Nil, then  MONITOR/MWAIT will time-out at the end of each time-quantum which is likely to result in non-optimal performance especially when the quantum is rather short.</dd></dl><p></p><dl><dt id="dt:simulation_mode"><b><i>simulation_mode</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_simulation_mode"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
The simulation mechanism used for the processor. One of the values of the simulation_mode_t enum.</dd></dl><p></p><dl><dt id="dt:skip_canonical_logical_check"><b><i>skip_canonical_logical_check</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_skip_canonical_logical_check"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If TRUE, no canonical check is performed on the logical address during address translation. A canonical check is always performed on the linear address, regardless of the setting of this attribute. The default value is FALSE, performing canonical checks on both the logical and linear addresses.</dd></dl><p></p><dl><dt id="dt:smi_count"><b><i>smi_count</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_smi_count"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Counts the number of occurrences of the SMM.</dd></dl><p></p><dl><dt id="dt:smm_base"><b><i>smm_base</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_smm_base"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
SMM base.</dd></dl><p></p><dl><dt id="dt:smm_handler"><b><i>smm_handler</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_smm_handler"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[os]</code>, <code>object</code>, or <code>nil</code>.
Object implementing the x86_smm interface.</dd></dl><p></p><dl><dt id="dt:smm_listeners"><b><i>smm_listeners</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_smm_listeners"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[o*]</code>.
List of all devices to be notified on transitions in or out of system management mode (SMM). Must implement the x86_smm_notification interface.</dd></dl><p></p><dl><dt id="dt:sp_mask_non64"><b><i>sp_mask_non64</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_sp_mask_non64"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If this attribute is set to TRUE (FALSE is the default), then the stack pointer will be masked to 32-bits after the 16-byte alignment when an exception is taken from a mode other than 64-bit mode while operating in long mode.</dd></dl><p></p><dl><dt id="dt:ss"><b><i>ss</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ss"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i{11}]</code>.
Segment register. All fields are stored in a list of integers as follows: <code>(</code><i>selector</i><code>, </code><i>b</i><code>, </code><i>dpl</i><code>, </code><i>g</i><code>, </code><i>p</i><code>, </code><i>s</i><code>, </code><i>type</i><code>, </code><i>base</i><code>, </code><i>limit</i><code>, </code><i>valid</i><code>, </code><i>l</i><code>)</code> The limit field always specifies the limit in bytes.</dd></dl><p></p><dl><dt id="dt:stall_time"><b><i>stall_time</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_stall_time"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
The number of cycles the processor will stall</dd></dl><p></p><dl><dt id="dt:stalling_info"><b><i>stalling_info</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_stalling_info"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[iii]</code>.
If is_stalling is set, this contains information about the current memory operation.</dd></dl><p></p><dl><dt id="dt:step_per_cycle_mode"><b><i>step_per_cycle_mode</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_step_per_cycle_mode"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>string</code>.
"constant" indicates a constant finite step/cycle factor; "infinite" means that steps are run without advancing time.</dd></dl><p></p><dl><dt id="dt:step_queue"><b><i>step_queue</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_step_queue"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[[o|n,s,a,s,i]*]</code>.
((<i>object</i>, <i>evclass</i>, <i>value</i>, <i>slot</i>, <i>step</i>)*). Pending step queue events.</dd></dl><p></p><dl><dt id="dt:steps"><b><i>steps</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_steps"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Number steps executed since machine start.</dd></dl><p></p><dl><dt id="dt:system"><b><i>system</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_system"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
System object.</dd></dl><p></p><dl><dt id="dt:telemetry_providers"><b><i>telemetry_providers</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_telemetry_providers"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>[o*]</code>.
List of objects that provides telemetry for this core</dd></dl><p></p><dl><dt id="dt:temporary_interrupt_mask"><b><i>temporary_interrupt_mask</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_temporary_interrupt_mask"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
If non-zero, interrupts are temporarily disabled even though EFLAGS.IF may be set.</dd></dl><p></p><dl><dt id="dt:threads"><b><i>threads</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_threads"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[o{1}]</code>, <code>[o{2}]</code>, <code>[o{3}]</code>, <code>[o{4}]</code>, or <code>nil</code>.
List of Simics processors representing threads in the physical processor core. Needs to point to objects of the same class as for the object where the attribute is being set.</dd></dl><p></p><dl><dt id="dt:time_queue"><b><i>time_queue</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_time_queue"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>[[o|n,s,a,s|n,i]*]</code>.
((<i>object</i>, <i>evclass</i>, <i>value</i>, <i>slot</i>, <i>cycle</i>)*). Pending time queue events.</dd></dl><p></p><dl><dt id="dt:tlb"><b><i>tlb</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_tlb"></a></p><dd><b>Required</b> attribute; <b>read/write</b> access; type: <code>object</code>.
Object handling the TLBs for this CPU.</dd></dl><p></p><dl><dt id="dt:tr"><b><i>tr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_tr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[i{11}]</code>.
X86 segment register. All fields are stored in a list of integers as follows: <code>(</code><i>selector</i><code>, </code><i>d</i><code>, </code><i>dpl</i><code>, </code><i>g</i><code>, </code><i>p</i><code>, </code><i>s</i><code>, </code><i>type</i><code>, </code><i>base</i><code>, </code><i>limit</i><code>, </code><i>valid</i><code>, </code><i>l</i><code>)</code> The limit field always specifies the limit in bytes.</dd></dl><p></p><dl><dt id="dt:tsc_invariant_freq"><b><i>tsc_invariant_freq</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_tsc_invariant_freq"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Rate at which TSC (if TSC invariant feature supported) and IA32_MPERF MSR are incremented in cycles/second.</dd></dl><p></p><dl><dt id="dt:ucode_signature"><b><i>ucode_signature</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ucode_signature"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code> or <code>nil</code>.
Can be either: None - no microcode update has happened since #RESET or an integer - microcode signature after the update.</dd></dl><p></p><dl><dt id="dt:use_halt_steps"><b><i>use_halt_steps</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_use_halt_steps"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Advance the step counter as well as the cycle counter when the CPU is idle. Defaults to FALSE.</dd></dl><p></p><dl><dt id="dt:vm_assert_object"><b><i>vm_assert_object</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_assert_object"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
VMP-mode state-assertion object.</dd></dl><p></p><dl><dt id="dt:vm_autohyper_step_threshold"><b><i>vm_autohyper_step_threshold</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_autohyper_step_threshold"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Do not enter VMP if fewer steps has been executed since last time autohyper triggered (since the execution is likely handled by autohyper again). Default 30 steps.</dd></dl><p></p><dl><dt id="dt:vm_backoff_enabled"><b><i>vm_backoff_enabled</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_backoff_enabled"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
VMP backoff mechanism enable.</dd></dl><p></p><dl><dt id="dt:vm_block_cnt"><b><i>vm_block_cnt</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_block_cnt"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Execution with VMP will be prevented if this attribute is non-zero. This attribute should normally be modified using the x86_vmp_control interface.</dd></dl><p></p><dl><dt id="dt:vm_break_step"><b><i>vm_break_step</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_break_step"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
If set to non-zero, the VM-monitor will silently break execution as soon as possible after the specified step without impacting the normal execution flow.</dd></dl><p></p><dl><dt id="dt:vm_compatible_config"><b><i>vm_compatible_config</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_compatible_config"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
This attribute should be set to TRUE if the machine configuration is VMP compatible.</dd></dl><p></p><dl><dt id="dt:vm_core2_bug"><b><i>vm_core2_bug</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_core2_bug"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>boolean</code>.
Set if the host cpu might be affected by a hardware bug.</dd></dl><p></p><dl><dt id="dt:vm_cpu_migration_dbg"><b><i>vm_cpu_migration_dbg</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_cpu_migration_dbg"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Internal. Used to test state migration between host cpus.</dd></dl><p></p><dl><dt id="dt:vm_debug_trace"><b><i>vm_debug_trace</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_debug_trace"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
If 1, the VMP kernel module will collect VMX traces. If 2, logging will occur to the console or to a file.</dd></dl><p></p><dl><dt id="dt:vm_disable_reason"><b><i>vm_disable_reason</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_disable_reason"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>string</code> or <code>nil</code>.
Reason for using turbo instead of VM acceleration.</dd></dl><p></p><dl><dt id="dt:vm_dump_trace"><b><i>vm_dump_trace</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_dump_trace"></a></p><dd><b>Pseudo</b> attribute; <b>write-only</b> access; type: <code>boolean</code>.
Dump VM-monitor trace information (only collected if vm_debug_trace is set).</dd></dl><p></p><dl><dt id="dt:vm_dump_vmcs"><b><i>vm_dump_vmcs</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_dump_vmcs"></a></p><dd><b>Pseudo</b> attribute; <b>write-only</b> access; type: <code>string</code>.
Dump host VMCS.</dd></dl><p></p><dl><dt id="dt:vm_host_has_vmx"><b><i>vm_host_has_vmx</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_host_has_vmx"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>boolean</code>.
If TRUE, host cpus support the virtual machine extensions (VMX).</dd></dl><p></p><dl><dt id="dt:vm_info"><b><i>vm_info</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_info"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>dictionary</code> or <code>nil</code>.
Internal. Information about VMXMON.</dd></dl><p></p><dl><dt id="dt:vm_monitor_statistics"><b><i>vm_monitor_statistics</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_monitor_statistics"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>[[i*][i*][i*]]</code>.
Internal, used for performance evaluation.</dd></dl><p></p><dl><dt id="dt:vm_pspace_sharable"><b><i>vm_pspace_sharable</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_pspace_sharable"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Set if the physical address space may be shared with the other CPU cores.</dd></dl><p></p><dl><dt id="dt:vm_sched_affinity"><b><i>vm_sched_affinity</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_sched_affinity"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>[b+]</code>.
Wire process to a subset of available hardware threads.</dd></dl><p></p><dl><dt id="dt:vm_step_threshold"><b><i>vm_step_threshold</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_step_threshold"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Threshold below which the monitor is not used.</dd></dl><p></p><dl><dt id="dt:vm_stepi_dbg"><b><i>vm_stepi_dbg</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_stepi_dbg"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
If TRUE set, the VMP kernel module will use CR0.TF to stop execution after each instruction (for debugging purposes).</dd></dl><p></p><dl><dt id="dt:vm_trace_file"><b><i>vm_trace_file</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_trace_file"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>string</code> or <code>nil</code>.
File for storing VM-monitor traces; Used for debugging VMP.</dd></dl><p></p><dl><dt id="dt:vm_use_pspace_sharing"><b><i>vm_use_pspace_sharing</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_use_pspace_sharing"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>boolean</code>.
Set if the physical address space sharing should be used when possible.</dd></dl><p></p><dl><dt id="dt:vm_using_pspace_sharing"><b><i>vm_using_pspace_sharing</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vm_using_pspace_sharing"></a></p><dd><b>Pseudo</b> attribute; <b>read-only</b> access; type: <code>boolean</code>.
Returns TRUE if physical address space sharing is in use.</dd></dl><p></p><dl><dt id="dt:vmcs_content"><b><i>vmcs_content</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vmcs_content"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[[ii]*]</code>.
The register content of the currently loaded Intel® Virtual Machine Control Structure (Intel® VMCS). Not valid if current_vmcs_ptr is not valid. Not all VMCS fields are necessarily present in this attribute since they are not kept in CPU registers. Remaining fields will be in the VMCS memory area.</dd></dl><p></p><dl><dt id="dt:vmcs_launch_state"><b><i>vmcs_launch_state</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vmcs_launch_state"></a></p><dd><b>Pseudo</b> attribute; <b>read/write</b> access; type: <code>string</code> or <code>nil</code>.
VMCS launch state.</dd></dl><p></p><dl><dt id="dt:vmcs_layout"><b><i>vmcs_layout</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vmcs_layout"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[[isiii]*]</code>.
Exports the implementation specific layout of the Intel® Virtual Machine Control Structure (Intel® VMCS) area. This information can be used to display the current VMCS status, as well as to track changes in the VMCS. Sublist format (<i>index</i>, <i>name</i>, <i>size</i>, <i>offset</i>, <i>attr</i>). A field is stored as a <i>size</i> byte integer at <i>offset</i> in the VMCS.</dd></dl><p></p><dl><dt id="dt:vmx_mode"><b><i>vmx_mode</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vmx_mode"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
VMX mode. 0: Not in VMX operation. 1: In VMX root operation. 2: In VMX non-root operation.</dd></dl><p></p><dl><dt id="dt:vmx_pending_exit"><b><i>vmx_pending_exit</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vmx_pending_exit"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code> or <code>nil</code>.
Pending VMX exit reason. See appendix A of the VMX specification for encoding. Nil if no VMX exit is pending.</dd></dl><p></p><dl><dt id="dt:vmxon_ptr"><b><i>vmxon_ptr</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_vmxon_ptr"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
VMXON pointer.</dd></dl><p></p><dl><dt id="dt:waiting_device"><b><i>waiting_device</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_waiting_device"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>object</code> or <code>nil</code>.
The device that requested the waiting interrupt. Only valid when waiting_interrupt is non-zero.</dd></dl><p></p><dl><dt id="dt:waiting_interrupt"><b><i>waiting_interrupt</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_waiting_interrupt"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
If an interrupt is requested, but it cannot be immediately handled because interrupts are masked.</dd></dl><p></p><dl><dt id="dt:xcr0"><b><i>xcr0</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_xcr0"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>integer</code>.
Extended control register 0 (XCR0).</dd></dl><p></p><dl><dt id="dt:xmm"><b><i>xmm</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_xmm"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[[ii]*]</code>.
((<i>xmm_0_low</i>, <i>xmm_0_high</i>), ..., (<i>xmm_n_low</i>, <i>xmm_n_high</i>)). Each list represents one xmm register. The high quad word (bits 64-127) is in <i>xmmi_high</i> and the low quad word (bits 0-63) is in <i>xmmi_low</i>.</dd></dl><p></p><dl><dt id="dt:ymmu"><b><i>ymmu</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_ymmu"></a></p><dd><b>Optional</b> attribute; <b>read/write</b> access; type: <code>[[ii]*]</code>.
((<i>ymmu0_low</i>, <i>ymm0_high</i>), ..., (<i>ymmu15_low</i>, <i>ymmu15_high</i>)). Each list represents the two upper  quad words of an ymm register. register. The high quad word (bits 192-255) is in <i>ymmi_high</i> and the low quad word (bits 128-191) is in <i>ymmi_low</i>.</dd></dl><p>
</p><h2 class="jdocu"><a class="not-numbered" name="Class-Attributes">Class Attributes</a></h2>
<p>

</p><dl><dt id="dt:architecture"><b><i>architecture</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_architecture"></a></p><dd><b>Pseudo</b> <b>class</b> attribute; <b>read-only</b> access; type: <code>string</code>.
Implemented architecture (x86-64)</dd></dl><p></p><dl><dt id="dt:physical_bits"><b><i>physical_bits</i></b></dt><p><a name="__rm_attribute_x86-nehalem-xeon_physical_bits"></a></p><dd><b>Pseudo</b> <b>class</b> attribute; <b>read-only</b> access; type: <code>integer</code>.
Number of physical address bits.</dd></dl><p>
</p><h2 class="jdocu"><a class="not-numbered" name="Command-List">Command List</a></h2>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem"><b>Commands defined by interface <a class="jdocu" href="undocumented-interfaces.html#__rm_interface_x86">x86</a></b></dt><dd class="jdocu_descitem"><a class="jdocu" href="namespace-commands-by-interface.html#__rm_command__lt_x86_gt_.break-vmread">break-vmread</a>, <a class="jdocu" href="namespace-commands-by-interface.html#__rm_command__lt_x86_gt_.break-vmwrite">break-vmwrite</a>, <a class="jdocu" href="namespace-commands-by-interface.html#__rm_command__lt_x86_gt_.trace-vmread">trace-vmread</a>, <a class="jdocu" href="namespace-commands-by-interface.html#__rm_command__lt_x86_gt_.trace-vmwrite">trace-vmwrite</a>, <a class="jdocu" href="namespace-commands-by-interface.html#__rm_command__lt_x86_gt_.unbreak-vmread">unbreak-vmread</a>, <a class="jdocu" href="namespace-commands-by-interface.html#__rm_command__lt_x86_gt_.unbreak-vmwrite">unbreak-vmwrite</a>, <a class="jdocu" href="namespace-commands-by-interface.html#__rm_command__lt_x86_gt_.untrace-vmread">untrace-vmread</a>, <a class="jdocu" href="namespace-commands-by-interface.html#__rm_command__lt_x86_gt_.untrace-vmwrite">untrace-vmwrite</a></dd>
<dt class="jdocu_descitem"><b>Commands</b></dt><dd class="jdocu_descitem"><table>

<tbody><tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.aprof-views">aprof-views</a></b></td><td class="jdocu_noborder">manipulate list of selected address profiling views</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.break-processor-reset">break-processor-reset</a></b></td><td class="jdocu_noborder">break on processor reset</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.break-segreg">break-segreg</a></b></td><td class="jdocu_noborder">break on control register updates</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.info">info</a></b></td><td class="jdocu_noborder">print information about the object</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.memory-configuration">memory-configuration</a></b></td><td class="jdocu_noborder">print memory configuration</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.msrs">msrs</a></b></td><td class="jdocu_noborder">print MSRs</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.pregs-fpu">pregs-fpu</a></b></td><td class="jdocu_noborder">print the x87 registers</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.pregs-sse">pregs-sse</a></b></td><td class="jdocu_noborder">print the sse registers</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.print-acpi-tables">print-acpi-tables</a></b></td><td class="jdocu_noborder">print ACPI tables</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.print-gdt">print-gdt</a></b></td><td class="jdocu_noborder">print GDT</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.print-idt">print-idt</a></b></td><td class="jdocu_noborder">print IDT</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.print-mp-tables">print-mp-tables</a></b></td><td class="jdocu_noborder">print MP tables</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.print-tss">print-tss</a></b></td><td class="jdocu_noborder">print TSS</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.print-vmcs">print-vmcs</a></b></td><td class="jdocu_noborder">print VMCS</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.print-vmx-cap">print-vmx-cap</a></b></td><td class="jdocu_noborder">print VMX capabilities of CPU</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.status">status</a></b></td><td class="jdocu_noborder">print status of the object</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.tablewalk">tablewalk</a></b></td><td class="jdocu_noborder">address translation tablewalk</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.trace-segreg">trace-segreg</a></b></td><td class="jdocu_noborder">trace segment register updates</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.unbreak-processor-reset">unbreak-processor-reset</a></b></td><td class="jdocu_noborder">stop breaking on processor reset</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.unbreak-segreg">unbreak-segreg</a></b></td><td class="jdocu_noborder">break on control register updates</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.untrace-segreg">untrace-segreg</a></b></td><td class="jdocu_noborder">trace segment register updates</td></tr>

<tr><td class="jdocu_noborder"><b><a class="jdocu" href="namespace-commands-by-class.html#__rm_command__lt_x86-nehalem-xeon_gt_.wait-for-processor-reset">wait-for-processor-reset</a></b></td><td class="jdocu_noborder">wait for a processor reset</td></tr>

</tbody></table>
</dd>
</dl><p>
</p>
<div class="chain">
<a href="__rm_class_x86-nehalem.html">x86-nehalem</a>
<a href="__rm_class_x86-p4-nocona.html">x86-p4-nocona</a>
</div>