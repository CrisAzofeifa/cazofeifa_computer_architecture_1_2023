<!doctype html>
<head>
<meta charset="utf-8">
<title>3.3 Device API Functions</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="device-api-data-types.html">3.2 Device API Data Types</a>
<a href="obsolete-device-api-types-and-functions.html">3.4 Obsolete Device API Types and Functions</a>
</div>
<div class="path">
<a href="index.html">API Reference Manual</a>
&nbsp;/&nbsp;
<a href="device-api.html">3 Device API</a>
&nbsp;/&nbsp;</div>
<h1 class="jdocu"><a name="Device-API-Functions">3.3 Device API Functions</a></h1>
<p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Attribute-Values">Attribute Values</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_alloc_attr_dict">SIM_alloc_attr_dict()</a></h3>
<p>

<a name="SIM_alloc_attr_dict2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_alloc_attr_dict"></a><b>SIM_alloc_attr_dict</b> — create empty attribute dictionary</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_alloc_attr_dict(unsigned length);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type
  dict with size <i>len</i>. The dictionary
  elements are initialized to invalid values.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_alloc_attr_list</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_alloc_attr_list">SIM_alloc_attr_list()</a></h3>
<p>

<a name="SIM_alloc_attr_list2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_alloc_attr_list"></a><b>SIM_alloc_attr_list</b> — create uninitialized attribute list</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_alloc_attr_list(unsigned length);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type
  list with size <i>length</i>. The list
  elements are initialized to invalid values.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_make_attr_list</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_attr_copy">SIM_attr_copy()</a></h3>
<p>

<a name="SIM_attr_copy2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attr_copy"></a><b>SIM_attr_copy</b> — copy attribute value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_attr_copy(attr_value_t val);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a deep copy of <i>val</i>. The caller obtains ownership
   of the copy and needs to free it after use; the argument is not modified.
<p>
   This function is not available from Python.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_attr_free</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_attr_dict_resize">SIM_attr_dict_resize()</a></h3>
<p>

<a name="SIM_attr_dict_resize2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attr_dict_resize"></a><b>SIM_attr_dict_resize</b> — resize dict attribute value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_dict_resize(attr_value_t *NOTNULL attr, unsigned newsize);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Resize <i>attr</i>, which must be of dict type, to
   <i>newsize</i> elements. New elements are marked invalid.
   Dropped elements are freed.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_attr_dict_set_item">SIM_attr_dict_set_item()</a></h3>
<p>

<a name="SIM_attr_dict_set_item2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attr_dict_set_item"></a><b>SIM_attr_dict_set_item</b> — set dict attribute element</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_dict_set_item(attr_value_t *NOTNULL attr, unsigned index,
                       attr_value_t key, attr_value_t value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the element numbered <i>index</i> of the dict
   <i>attr</i> to <i>key</i> and <i>value</i>. The
   previous key and value at that position are freed. The ownership for
   <i>key</i> and <i>value</i> is transferred from the caller to
   <i>attr</i>. The <i>key</i> must be of integer, string or
   object type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_attr_free">SIM_attr_free()</a></h3>
<p>

<a name="SIM_attr_free2"></a><a name="SIM_free_attribute"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attr_free"></a><b>SIM_attr_free</b><b>, SIM_free_attribute</b> — free attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_free(attr_value_t *NOTNULL value);
</pre><p></p><pre class="jdocu_small">void
SIM_free_attribute(attr_value_t value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Free the memory allocation used by the value pointed to by
   <i>value</i>. For values of list or dict type, this recursively
   frees all contents; for string or data values, the allocation containing the
   payload is freed. It is an error to use the value or any sub-part of it
   after it has been freed.
<p>
   <b><i>SIM_attr_free</i></b> is the preferred call because it changes the type
   of the argument variable to Invalid, preventing accidental use after
   freeing. <b><i>SIM_free_attribute</i></b> only differs in how the argument is
   passed, but cannot change the argument variable as it is passed by value.
</p><p>
   </p><div class="note">
<b>Note:</b>
These functions are not available in Python; memory
   allocation is managed automatically there.</div></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_attr_integer">SIM_attr_integer()</a></h3>
<p>

<a name="SIM_attr_integer2"></a><a name="SIM_attr_boolean"></a><a name="SIM_attr_string"></a><a name="SIM_attr_string_detach"></a><a name="SIM_attr_floating"></a><a name="SIM_attr_object"></a><a name="SIM_attr_object_or_nil"></a><a name="SIM_attr_data_size"></a><a name="SIM_attr_data"></a><a name="SIM_attr_list_size"></a><a name="SIM_attr_list_item"></a><a name="SIM_attr_list"></a><a name="SIM_attr_dict_size"></a><a name="SIM_attr_dict_key"></a><a name="SIM_attr_dict_value"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attr_integer"></a><b>SIM_attr_integer</b><b>, SIM_attr_boolean</b><b>, SIM_attr_string</b><b>, SIM_attr_string_detach</b><b>, SIM_attr_floating</b><b>, SIM_attr_object</b><b>, SIM_attr_object_or_nil</b><b>, SIM_attr_data_size</b><b>, SIM_attr_data</b><b>, SIM_attr_list_size</b><b>, SIM_attr_list_item</b><b>, SIM_attr_list</b><b>, SIM_attr_dict_size</b><b>, SIM_attr_dict_key</b><b>, SIM_attr_dict_value</b> — extract values stored in <code>attr_value_t</code> values</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE int64
SIM_attr_integer(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_boolean(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE const char *
SIM_attr_string(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE char *
SIM_attr_string_detach(attr_value_t *attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE double
SIM_attr_floating(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE conf_object_t *
SIM_attr_object(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE conf_object_t *
SIM_attr_object_or_nil(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE unsigned
SIM_attr_data_size(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE const uint8 *
SIM_attr_data(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE unsigned
SIM_attr_list_size(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_attr_list_item(attr_value_t attr, unsigned index);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t *
SIM_attr_list(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE unsigned
SIM_attr_dict_size(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_attr_dict_key(attr_value_t attr, unsigned index);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_attr_dict_value(attr_value_t attr, unsigned index);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Extract a value encapsulated in <i>attr</i>. It is an error to
     call an accessor function with an <i>attr</i> of the wrong type.
<p>
     <b><i>SIM_attr_integer</i></b> returns the integer attribute value
     modulo-reduced to the interval
     [−2<sup>63</sup>,2<sup>63</sup>−1].
     (Converting the return value to <code>uint64</code> gives the integer
     attribute value modulo-reduced to [0,2<sup>64</sup>−1].)
</p><p>
     <b><i>SIM_attr_string()</i></b>, <b><i>SIM_attr_data()</i></b> and
     <b><i>SIM_attr_list()</i></b> return values owned by <i>attr</i>. 
     Ownership is not transferred to the caller.
     </p><p>
     <b><i>SIM_attr_string_detach()</i></b> returns the string
     in <i>attr</i> and changes the value pointed to by
     <i>attr</i> into a nil attribute. Ownership of the string is
     transferred to the caller.
     </p><p>
     <b><i>SIM_attr_object_or_nil</i></b> accepts an <i>attr</i> parameter
     of either object or nil type. In case of a nil attribute, the function
     returns NULL.
     </p><p>
     <b><i>SIM_attr_list_size()</i></b> and <b><i>SIM_attr_dict_size</i></b> return
     the number of items in the list and key-value pairs in the dict
     respectively. <b><i>SIM_attr_data_size()</i></b> returns the number of bytes
     in the data value.
     </p><p>
     <b><i>SIM_attr_list_item()</i></b> returns the item at <i>index</i>.
     The index must be less than the number of items in the list. The item
     returned is still owned by <i>attr</i>. Ownership is not
     transferred to the caller.
     </p><p>
     <b><i>SIM_attr_list()</i></b> returns a pointer directly into the internal
     array of the attribute value; it is mainly present as an optimisation. Use
     <b><i>SIM_attr_list_item()</i></b> and <b><i>SIM_attr_list_set_item()</i></b>
     for type-safety instead.
     </p><p>
     <b><i>SIM_attr_dict_key()</i></b> and <b><i>SIM_attr_dict_value()</i></b> return
     the key and value at <i>index</i>. The index must be less than the
     number of items in the dict. The value returned is still owned by
     <i>attr</i>. Ownership is not transferred to the caller.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
     </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_attr_is_integer">SIM_attr_is_integer()</a></h3>
<p>

<a name="SIM_attr_is_integer2"></a><a name="SIM_attr_is_boolean"></a><a name="SIM_attr_is_string"></a><a name="SIM_attr_is_floating"></a><a name="SIM_attr_is_object"></a><a name="SIM_attr_is_invalid"></a><a name="SIM_attr_is_data"></a><a name="SIM_attr_is_list"></a><a name="SIM_attr_is_dict"></a><a name="SIM_attr_is_nil"></a><a name="SIM_attr_is_int64"></a><a name="SIM_attr_is_uint64"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attr_is_integer"></a><b>SIM_attr_is_integer</b><b>, SIM_attr_is_boolean</b><b>, SIM_attr_is_string</b><b>, SIM_attr_is_floating</b><b>, SIM_attr_is_object</b><b>, SIM_attr_is_invalid</b><b>, SIM_attr_is_data</b><b>, SIM_attr_is_list</b><b>, SIM_attr_is_dict</b><b>, SIM_attr_is_nil</b><b>, SIM_attr_is_int64</b><b>, SIM_attr_is_uint64</b> — <code>attr_value_t</code> type predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_integer(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_boolean(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_string(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_floating(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_object(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_invalid(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_data(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_list(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_dict(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_nil(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_int64(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_uint64(attr_value_t attr);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Indicates whether the value stored in <i>attr</i> is of the specified
     type. <b><i>SIM_attr_is_int64</i></b> and <b><i>SIM_attr_is_uint64</i></b> 
     additionally test whether the integer value would fit in the given C type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_attr_list_resize">SIM_attr_list_resize()</a></h3>
<p>

<a name="SIM_attr_list_resize2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attr_list_resize"></a><b>SIM_attr_list_resize</b> — resize list attribute value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_list_resize(attr_value_t *NOTNULL attr, unsigned newsize);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Resize <i>attr</i>, which must be of list type,
   to <i>newsize</i> elements.
   New elements are set to invalid value.
   Dropped elements are freed.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_attr_list_set_item">SIM_attr_list_set_item()</a></h3>
<p>

<a name="SIM_attr_list_set_item2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attr_list_set_item"></a><b>SIM_attr_list_set_item</b> — set list attribute element</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_list_set_item(attr_value_t *NOTNULL attr, unsigned index,
                       attr_value_t elem);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the element numbered <i>index</i> of the list
   <i>attr</i> to <i>elem</i>. The previous value at
   that position is freed. The ownership for <i>elem</i> is transferred
   from the caller to <i>attr</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_attr_scanf">SIM_attr_scanf()</a></h3>
<p>

<a name="SIM_attr_scanf2"></a><a name="SIM_ascanf"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attr_scanf"></a><b>SIM_attr_scanf</b><b>, SIM_ascanf</b> — parse list attribute values</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_attr_scanf(attr_value_t *NOTNULL list, const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">bool
SIM_ascanf(attr_value_t *NOTNULL list,
           const char *NOTNULL fmt, ...) __attribute__((alias("SIM_attr_scanf")));
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Reads and converts entries in <i>list</i> according to the format
   string <i>fmt</i>. Returns <code>true</code> if all elements were
   successfully converted, <code>false</code> otherwise.
<p>
   The characters in the format string mean:
</p><p>
   <span class="jdocu_smaller">
   <table>

    <tbody><tr>
     <td class="jdocu_border"><b>format char</b></td>
     <td class="jdocu_border"><b>argument type</b></td>
     <td class="jdocu_border"><b>element must be</b></td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>i</code></td>
     <td class="jdocu_border"><code>int64 *</code></td>
     <td class="jdocu_border">integer</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>b</code></td>
     <td class="jdocu_border"><code>int *</code></td>
     <td class="jdocu_border">boolean</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>f</code></td>
     <td class="jdocu_border"><code>double *</code></td>
     <td class="jdocu_border">floating</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>s</code></td>
     <td class="jdocu_border"><code>const char **</code></td>
     <td class="jdocu_border">string</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>S</code></td>
     <td class="jdocu_border"><code>const char **</code></td>
     <td class="jdocu_border">string or nil</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>o</code></td>
     <td class="jdocu_border"><code>conf_object_t **</code></td>
     <td class="jdocu_border">object</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>O</code></td>
     <td class="jdocu_border"><code>conf_object_t **</code></td>
     <td class="jdocu_border">object or nil</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>l</code></td>
     <td class="jdocu_border"><code>attr_value_t **</code></td>
     <td class="jdocu_border">list</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>d</code></td>
     <td class="jdocu_border"><code>attr_value_t **</code></td>
     <td class="jdocu_border">data</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>a</code></td>
     <td class="jdocu_border"><code>attr_value_t **</code></td>
     <td class="jdocu_border">any except invalid</td>
    </tr>

   </tbody></table>
   </span>
</p><p>
   The <i>fmt</i> string may also include a period (<code>.</code>) at the end,
   taken to mean that more elements may follow. If the period is not present,
   the length of the list must equal the number of specified elements.
</p><p>
   Converted values of type <code>attr_value_t *</code> and
   <code>const char *</code> are still owned by <i>list</i>.
</p><p>
   <b><i>SIM_ascanf</i></b> is an alias of <b><i>SIM_attr_scanf</i></b>
   and will be deprecated.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_attr_boolean">SIM_make_attr_boolean()</a></h3>
<p>

<a name="SIM_make_attr_boolean2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_attr_boolean"></a><b>SIM_make_attr_boolean</b> — make boolean attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_boolean(bool b);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of boolean type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_attr_data">SIM_make_attr_data()</a></h3>
<p>

<a name="SIM_make_attr_data2"></a><a name="SIM_make_attr_data_adopt"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_attr_data"></a><b>SIM_make_attr_data</b><b>, SIM_make_attr_data_adopt</b> — create raw data attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_make_attr_data(size_t size, const void *data);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_data_adopt(size_t size, void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type data using
     <i>size</i> and <i>data</i> for the binary data. 
<p>
     <b><i>SIM_make_attr_data</i></b> will make a copy of the argument data.
</p><p>
     <b><i>SIM_make_attr_data_adopt</i></b> is mainly provided for compatibility;
     it will assume ownership of the argument data, which must have been
     allocated using one of the <b><i>MM_MALLOC</i></b> functions.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
     </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_attr_floating">SIM_make_attr_floating()</a></h3>
<p>

<a name="SIM_make_attr_floating2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_attr_floating"></a><b>SIM_make_attr_floating</b> — make floating point attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t 
SIM_make_attr_floating(double d);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of floating type with value
     <i>d</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_attr_int64">SIM_make_attr_int64()</a></h3>
<p>

<a name="SIM_make_attr_int642"></a><a name="SIM_make_attr_uint64"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_attr_int64"></a><b>SIM_make_attr_int64</b><b>, SIM_make_attr_uint64</b> — make integer attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_int64(int64 i);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_uint64(uint64 i);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of integer type with value
     <i>i</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_attr_invalid">SIM_make_attr_invalid()</a></h3>
<p>

<a name="SIM_make_attr_invalid2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_attr_invalid"></a><b>SIM_make_attr_invalid</b> — make invalid attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_invalid(void);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of invalid type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_attr_list">SIM_make_attr_list()</a></h3>
<p>

<a name="SIM_make_attr_list2"></a><a name="SIM_make_attr_list_vararg"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_attr_list"></a><b>SIM_make_attr_list</b><b>, SIM_make_attr_list_vararg</b> — make list attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_make_attr_list(unsigned length, ...);
</pre><p></p><pre class="jdocu_small">attr_value_t
SIM_make_attr_list_vararg(unsigned length, va_list va);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type list
   with size <i>length</i>. The list is filled with data from the
   arguments following, which should be of type <code>attr_value_t</code>.
<p>
   This function must be called with exactly <i>length</i>+1 arguments.
   The attribute parameters should all be valid attributes; e.g.,
   attributes of invalid type are not allowed.
   The <i>length</i> argument must be a constant expression.
</p><p>
   The newly created list assumes ownership of the passed parameters, which
   therefore should not be freed.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_alloc_attr_list</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_attr_nil">SIM_make_attr_nil()</a></h3>
<p>

<a name="SIM_make_attr_nil2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_attr_nil"></a><b>SIM_make_attr_nil</b> — make nil attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_nil(void);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type nil.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_attr_object">SIM_make_attr_object()</a></h3>
<p>

<a name="SIM_make_attr_object2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_attr_object"></a><b>SIM_make_attr_object</b> — make object attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_object(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of object type
     with value <i>obj</i>. Returns a nil value if
     <i>obj</i> is <code>NULL</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_attr_string">SIM_make_attr_string()</a></h3>
<p>

<a name="SIM_make_attr_string2"></a><a name="SIM_make_attr_string_adopt"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_attr_string"></a><b>SIM_make_attr_string</b><b>, SIM_make_attr_string_adopt</b> — make string attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_make_attr_string(const char *str);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_string_adopt(char *str);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type string with value
     <i>str</i>. Returns Nil if <i>str</i> is <code>NULL</code>.
<p>
     <b><i>SIM_make_attr_string</i></b> will make a copy of the argument string.
</p><p>
     <b><i>SIM_make_attr_string_adopt</i></b> is mainly provided for 
     compatibility; it will assume ownership of the argument string, which
     must have been allocated using one the <b><i>MM_MALLOC</i></b> functions.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
     </dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Configuration">Configuration</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_attribute_error">SIM_attribute_error()</a></h3>
<p>

<a name="SIM_attribute_error2"></a><a name="SIM_c_attribute_error"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_attribute_error"></a><b>SIM_attribute_error</b><b>, SIM_c_attribute_error</b> — specify reason for attribute error</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attribute_error(const char *NOTNULL msg);
</pre><p></p><pre class="jdocu_small">void
SIM_c_attribute_error(const char *NOTNULL msg, ...);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
When used inside an attribute <b><i>set_attr</i></b>/<b><i>get_attr</i></b>
   method, indicates why it failed to set or retrieve the attribute.
   This function only serves to give an informative message to the user.
   The object or attribute names need not be mentioned in the
   <i>msg</i> argument; Simics will supply this automatically.
   <b><i>SIM_c_attribute_error</i></b> is similar but the <i>msg</i>
   argument and those following it are used for string formatting in the
   same way as in the standard <b><i>sprintf</i></b> function. This function
   is not available from Python.
<p>
   The error message supplied will be attached to any frontend exception
   generated by the attribute access.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_register_attribute">SIM_register_attribute</a>, <a class="jdocu" href="simulator-api-functions.html#__jdocu_seealso_SIM_get_attribute">
   SIM_get_attribute</a>, <a class="jdocu" href="simulator-api-functions.html#__jdocu_seealso_SIM_set_attribute"> SIM_set_attribute</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_class_port">SIM_class_port()</a></h3>
<p>

<a name="SIM_class_port2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_class_port"></a><b>SIM_class_port</b> — check if class has specified port object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_class_port(const conf_class_t *NOTNULL cls, const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the class of objects on the port named <i>name</i>,
   or NULL if no such port is registered.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_register_port">
     SIM_register_port</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_simple_port"> SIM_register_simple_port
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_copy_class">SIM_copy_class()</a></h3>
<p>

<a name="SIM_copy_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_copy_class"></a><b>SIM_copy_class</b> — create a copy of an existing class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_copy_class(const char *NOTNULL name, const conf_class_t *NOTNULL src_cls,
               const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function creates a copy of the class <i>src_class</i>
   named <i>name</i>.
<p>
   Additional attributes and interfaces can be registered on the
   newly created class.
</p><p>
   The new class is described by <i>desc</i> unless
   this parameter is NULL which means that the original class description
   should be used.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The newly created class is returned.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_extend_class">
        SIM_extend_class</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_class"> SIM_register_class
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_create_class">SIM_create_class()</a></h3>
<p>

<a name="SIM_create_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_create_class"></a><b>SIM_create_class</b> — create class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_create_class(const char *NOTNULL name,
                 const class_info_t *NOTNULL class_info);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function creates a new class that can be instantiated by
   calling the <b><i>SIM_create_object</i></b> function.  It is a 
   replacement for <b><i>SIM_register_class</i></b> and should be
   used in all new code. 
<p>
   The <i>name</i> can contain upper and lower case ASCII letters,
   hyphens, underscores, and digits. It must not begin with a digit or a hyphen
   and must not end with a hyphen.
</p><p>
   <i>class_info</i> may be freed when the function has returned.
   
   
</p><pre class="jdocu_small">typedef enum {
        Sim_Class_Kind_Vanilla, /* object is saved at checkpoints */
        Sim_Class_Kind_Session, /* object is saved as part of a
                                 * session only */
        Sim_Class_Kind_Pseudo,  /* object is never saved */

        Sim_Class_Kind_Extension, /* extension class (see SIM_extend_class) */
} class_kind_t;</pre><p>

   
</p><pre class="jdocu_small">typedef struct class_info {
        conf_object_t *(*alloc)(conf_class_t *cls);
        lang_void *(*init)(conf_object_t *obj);
        void (*finalize)(conf_object_t *obj);
        void (*objects_finalized)(conf_object_t *obj);

        void (*deinit)(conf_object_t *obj);
        void (*dealloc)(conf_object_t *obj);

        const char           *description;
        const char           *short_desc;
        class_kind_t          kind;
} class_info_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Class structure, or
   <code>NULL</code> on error.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_register_class_alias">
     SIM_register_class_alias</a>, <a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_class_info_t"> class_info_t
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_describe_notifier">SIM_describe_notifier()</a></h3>
<p>

<a name="SIM_describe_notifier2"></a><a name="SIM_notifier_description"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_describe_notifier"></a><b>SIM_describe_notifier</b><b>, SIM_notifier_description</b> — set short description</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_describe_notifier(notifier_type_t type, const char *NOTNULL generic_desc);
</pre><p></p><pre class="jdocu_small">const char *
SIM_notifier_description(notifier_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_describe_notifier</i></b> sets <i>generic_desc</i> as the short,
   generic description of the notification specified by the <i>type</i>
   argument. If a description already exists for <i>type</i> it will be
   overwritten.
<p>
   The text is displayed when no description has been given using the
   <b><i>SIM_register_notifier</i></b> or <b><i>SIM_register_tracked_notifier</i></b>
   functions.
</p><p>
   <b><i>SIM_notifier_description</i></b> returns the short, generic description
   for the notification specified by the <i>type</i> argument, or the empty
   string if no description has been set.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_ensure_partial_attr_order">SIM_ensure_partial_attr_order()</a></h3>
<p>

<a name="SIM_ensure_partial_attr_order2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_ensure_partial_attr_order"></a><b>SIM_ensure_partial_attr_order</b> — ensure attribute order</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_ensure_partial_attr_order(conf_class_t *NOTNULL cls,
                              const char *NOTNULL before,
                              const char *NOTNULL after);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Attribute initialization order is guaranteed to be identical to the order
   in which the attributes were registered. In some cases a particular order
   is required in order for a model to work correctly.
<p>
   This function checks the registration order of the attributes
   <i>before</i> and <i>after</i> in the class
   <i>cls</i>. If <i>before</i> is not registered
   before <i>after</i>, or if at least one of the two are not
   registered at all, an ASSERT is triggered.
</p><p>
   Use this function to ensure that e.g. code refactoring does not break
   a required attribute order.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_register_attribute">SIM_register_attribute</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_extend_class">SIM_extend_class()</a></h3>
<p>

<a name="SIM_extend_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_extend_class"></a><b>SIM_extend_class</b> — extend class with contents from an extension class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_extend_class(conf_class_t *NOTNULL cls, conf_class_t *NOTNULL ext);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The function extends the class <i>cls</i> with attributes,
   interfaces, port objects and port interfaces defined by the
   extension class <i>ext</i>.
<p>
   The extension class must be of the type
   <code>Sim_Class_Kind_Extension</code> and must not define any attributes
   or interfaces which have already been defined by the class being
   augmented.
</p><p>
   Besides normal object initialization, the <b><i>init_object</i></b>
   method for the extension class, will be called when
   <i>cls</i> is instantiated. The pointer returned by
   <b><i>init_object</i></b> can be retrieved using
   <b><i>SIM_extension_data</i></b>. The <b><i>init_object</i></b> method
   may return NULL if no private data pointer is needed; this does
   not signify an error condition for extension classes.
</p><p>
   The <b><i>finalize_instance</i></b> method defined by the extension class
   will be called before the <b><i>finalize_instance</i></b> method is called for
   the class being extended.
</p><p>
   The <b><i>SIM_extension_class</i></b> function is intended to be used
   to extend a class with generic functionality, common to multiple
   classes.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_create_class">
     SIM_create_class</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_class"> SIM_register_class</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_extension_data"> SIM_extension_data
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_extension_data">SIM_extension_data()</a></h3>
<p>

<a name="SIM_extension_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_extension_data"></a><b>SIM_extension_data</b> — get class extension data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void *
SIM_extension_data(conf_object_t *obj, conf_class_t *ext_cls);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the private data pointer of an object associated
   with the extension class <i>ext_cls</i>. The returned pointer is
   the value returned by the <b><i>init_object</i></b> method called
   for the extension class <i>ext_cls</i>.
<p>
   The object <i>obj</i> must be an instance of a class
   which has been extended with the extension class <i>ext_cls</i>
   using the <b><i>SIM_extend_class</i></b> function.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_object_data">
      SIM_object_data</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_class"> SIM_register_class</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_extend_class"> SIM_extend_class
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_class">SIM_get_class()</a></h3>
<p>

<a name="SIM_get_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_class"></a><b>SIM_get_class</b> — get class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_get_class(const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the configuration class called <i>name</i>.
   <a name="conf_class_t"></a>
<p>
   If it finds no class called <i>name</i>, <b><i>SIM_get_class</i></b>
   will load a module implementing that class, if any can be found, and return
   the newly created class.
</p><p>
   Note that loading a module can not be done during the simulation execution:
   in that case, <b><i>SIM_get_class</i></b> will trigger an error instead. If
   you encounter this problem, a simple work-around is to make sure that all
   necessary modules are loaded before starting the execution.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Opaque pointer referencing the class,
   or NULL if not found.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the class has not been registered.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context, except when loading a module.
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_get_class_name">
     SIM_get_class_name
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_class_data">SIM_get_class_data()</a></h3>
<p>

<a name="SIM_get_class_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_class_data"></a><b>SIM_get_class_data</b> — get class data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">lang_void *
SIM_get_class_data(conf_class_t *cls);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Obtain the class data that was set using <b><i>SIM_set_class_data</i></b>. This
   can be called at any time during the object initialisation process.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_set_class_data">SIM_set_class_data</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_class_name">SIM_get_class_name()</a></h3>
<p>

<a name="SIM_get_class_name2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_class_name"></a><b>SIM_get_class_name</b> — get class name</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_get_class_name(const conf_class_t *NOTNULL class_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the name of the class. Simics retains ownership of the returned
   string; it must not be modified or freed by the caller.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_get_class">
     SIM_get_class
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_interface">SIM_get_interface()</a></h3>
<p>

<a name="SIM_get_interface2"></a><a name="SIM_c_get_interface"></a><a name="SIM_get_class_interface"></a><a name="SIM_c_get_class_interface"></a><a name="SIM_get_port_interface"></a><a name="SIM_c_get_port_interface"></a><a name="SIM_get_class_port_interface"></a><a name="SIM_c_get_class_port_interface"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_interface"></a><b>SIM_get_interface</b><b>, SIM_c_get_interface</b><b>, SIM_get_class_interface</b><b>, SIM_c_get_class_interface</b><b>, SIM_get_port_interface</b><b>, SIM_c_get_port_interface</b><b>, SIM_get_class_port_interface</b><b>, SIM_c_get_class_port_interface</b> — get interface</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const void *
SIM_get_interface(const conf_object_t *NOTNULL obj, const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">const void *
SIM_c_get_interface(const conf_object_t *NOTNULL obj, const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">const void *
SIM_get_class_interface(const conf_class_t *NOTNULL cls, 
                        const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">const void *
SIM_c_get_class_interface(const conf_class_t *NOTNULL cls, 
                          const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">const void *
SIM_get_port_interface(const conf_object_t *NOTNULL obj, 
                       const char *NOTNULL name, const char *portname);
</pre><p></p><pre class="jdocu_small">const void *
SIM_c_get_port_interface(const conf_object_t *NOTNULL obj, 
                         const char *NOTNULL name, 
                         const char *portname);
</pre><p></p><pre class="jdocu_small">const void *
SIM_get_class_port_interface(const conf_class_t *NOTNULL cls,
                             const char *NOTNULL name, 
                             const char *portname);
</pre><p></p><pre class="jdocu_small">const void *
SIM_c_get_class_port_interface(const conf_class_t *NOTNULL cls,
                               const char *NOTNULL name, 
                               const char *portname);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Get the interface with name <i>name</i> from object
   <i>obj</i>. Returns NULL, and raises an exception if
   <i>obj</i> does not implement the interface.
<p>
   <b><i>SIM_get_port_interface</i></b> returns a port interface
   instance as registered with
   <b><i>SIM_register_port_interface</i></b>. The
   <i>portname</i> selects a particular implementation of the
   interface by <i>obj's</i> class. If no port name is supplied,
   the function behaves as <b><i>SIM_get_interface</i></b>.
</p><p>
   <b><i>SIM_get_class_interface</i></b> and
   <b><i>SIM_get_class_port_interface</i></b> are similar but return the
   interface for a class instead of an object.
</p><p>
   <b><i>SIM_c_get_interface</i></b>,
   <b><i>SIM_c_get_port_interface</i></b>,
   <b><i>SIM_c_get_class_interface</i></b> and
   <b><i>SIM_c_get_class_port_interface</i></b> are similar to their respective
   counterparts but never raise an exception, nor do they accept dashes
   inside <i>name</i> or <i>portname</i> instead of 
   underscores.
</p><p>
   The <b><i>SIM_C_GET_INTERFACE</i></b> macro is a useful type-safe replacement
   for SIM_c_get_interface. The macro takes an object and the name of the
   interface without quotes. Compare the three forms:
   </p><pre class="jdocu_small">SIM_c_get_interface(obj, PCI_DEVICE_INTERFACE);
SIM_c_get_interface(obj, "pci_device");
SIM_C_GET_INTERFACE(obj, pci_device);
   </pre><p>
</p><p>
   The data the result points to is owned by Simics. The caller
   must not deallocate or modify it.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to interface, or NULL if not found.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Lookup</b> Thrown if the interface is not implemented by
   <i>obj's</i> class.<br>
<p>
   <b>SimExc_General</b> Thrown if the interface name is illegal.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_register_interface">
     SIM_register_interface
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_is_loading_micro_checkpoint">SIM_is_loading_micro_checkpoint()</a></h3>
<p>

<a name="SIM_is_loading_micro_checkpoint2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_is_loading_micro_checkpoint"></a><b>SIM_is_loading_micro_checkpoint</b> — check if micro checkpoint is being loaded</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_is_loading_micro_checkpoint(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This indicates if a persistent state or a micro checkpoint is being loaded,
   and is therefore equivalent to <pre class="jdocu_small">(SIM_object_is_configured(obj) and
   SIM_is_restoring_state(obj))</pre><p>.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_object_is_configured">
      SIM_object_is_configured</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_is_restoring_state">
      SIM_is_restoring_state</a>, <a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_is_restoring_state">SIM_is_restoring_state()</a></h3>
<p>

<a name="SIM_is_restoring_state2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_is_restoring_state"></a><b>SIM_is_restoring_state</b> — check if state restoring phase</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_is_restoring_state(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns true if the configuration system is currently restoring the saved
   state for the object <code>obj</code> when reading a checkpoint, applying a
   persistent state or restoring a reverse execution bookmark.
<p>
   <b><i>SIM_is_restoring_state</i></b> is typically used to prevent side effects
   in attribute set methods that only should run when the attribute is set
   manually, for example when hot plugging.
</p><p>
   <table>

   <tbody><tr><td class="jdocu_noborder"></td>
       <td class="jdocu_noborder"><b><i>SIM_object_is_configured</i></b></td>
       <td class="jdocu_noborder"><b><i>SIM_is_restoring_state</i></b></td></tr>

   <tr><td class="jdocu_noborder">Creating object</td>          <td class="jdocu_noborder">false</td> <td class="jdocu_noborder">false</td></tr>

   <tr><td class="jdocu_noborder">Loading checkpoint</td>       <td class="jdocu_noborder">false</td> <td class="jdocu_noborder">true</td></tr>

   <tr><td class="jdocu_noborder">Loading persistent state</td> <td class="jdocu_noborder">true</td>  <td class="jdocu_noborder">true</td></tr>

   <tr><td class="jdocu_noborder">Loading micro-checkpoint (rev-exec)</td>
       <td class="jdocu_noborder">true</td><td class="jdocu_noborder">true</td></tr>

   <tr><td class="jdocu_noborder">Manual attribute access (hot plug)</td>
       <td class="jdocu_noborder">true</td>  <td class="jdocu_noborder">false</td></tr>

   </tbody></table>
</p><p>
   LIMITATION: This function currently returns true for all objects in Simics
   while some state is being restored and not only for the affected objects.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_object_is_configured">SIM_object_is_configured</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_marked_for_deletion">SIM_marked_for_deletion()</a></h3>
<p>

<a name="SIM_marked_for_deletion2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_marked_for_deletion"></a><b>SIM_marked_for_deletion</b> — is object being deleted</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_marked_for_deletion(const conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Indicates if the given object is being deleted. This information can be
   useful by other objects that want to clean up their references.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<code>true</code> if the object is being
   deleted.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="simulator-api-functions.html#__jdocu_seealso_SIM_delete_objects">SIM_delete_objects</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_notifier_type">SIM_notifier_type()</a></h3>
<p>

<a name="SIM_notifier_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_notifier_type"></a><b>SIM_notifier_type</b> — get notifier type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">notifier_type_t
SIM_notifier_type(const char *NOTNULL type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Given a notifier type <i>type</i> specified in the form of a
   string, return a <code>notifier_type_t</code> identifier which uniquely
   corresponds to this type.
<p>
   This function always returns a valid notifier type; if a particular
   type string has not been seen before, then a new notifier type is created
   and associated with this string.
</p><p>
   The string must consist of printable 7-bit ASCII characters, and by
   convention it should be expressed as a noun with words separated by dashes.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_object_clock">SIM_object_clock()</a></h3>
<p>

<a name="SIM_object_clock2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_object_clock"></a><b>SIM_object_clock</b> — get object clock</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_object_clock(const conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve the default clock used by an object. This is set by
   the <i>queue</i> attribute and is used as time reference for the
   object.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_object_data">SIM_object_data()</a></h3>
<p>

<a name="SIM_object_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_object_data"></a><b>SIM_object_data</b> — get object-specific data pointer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">lang_void *
SIM_object_data(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the private data pointer of an object. This pointer is
     available to the class for storing instance-specific state. 
     <p>
     It is initialised to the return value of the <b><i>init</i></b> 
     (from <code>class_info_t</code>) method 
     that is called during object creation.  For classes created using
     the legacy <b><i>SIM_register_class</i></b>, the same functionality
     is provided by the <b><i>init_object</i></b> method .
</p><p>
     For classes implemented in Python, the data (which is then a Python
     value) can also be accessed as <code>obj.object_data</code>.
</p><p>
     For classes written in C, the preferred way to store
     instance-specific state is by co-allocation with the object's
     <code>conf_object_t</code> structure instead of using
     <b><i>SIM_object_data</i></b>.  Such classes should define the
     <b><i>alloc</i></b> method in the <code>class_info_t</code>
     passed to <b><i>SIM_create_class</i></b> for allocating its instance
     data.  For classes using the legacy <b><i>SIM_register_class</i></b> 
     class registration function, they should define the
     <b><i>alloc_object</i></b> method in the <code>class_data_t</code> 
     data structure.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_create_class">
       SIM_create_class</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_class"> SIM_register_class
     </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_object_id">SIM_object_id()</a></h3>
<p>

<a name="SIM_object_id2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_object_id"></a><b>SIM_object_id</b> — get object identifier</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_object_id(const conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the unique identifier for an object. The identifier is a
   string that is guaranteed to be unique and will never change, even
   if the object moves to another hierarchical location.
<p>
   The return value is a static string that should not be modified or
   freed by the caller.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_object_name">SIM_object_name</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_object_is_configured">SIM_object_is_configured()</a></h3>
<p>

<a name="SIM_object_is_configured2"></a><a name="SIM_set_object_configured"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_object_is_configured"></a><b>SIM_object_is_configured</b><b>, SIM_set_object_configured</b> — get/set configured status</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_object_is_configured(const conf_object_t *NOTNULL obj);
</pre><p></p><pre class="jdocu_small">void
SIM_set_object_configured(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_object_is_configured</i></b> indicates whether
     <i>obj</i> is configured. <b><i>SIM_set_object_configured</i></b>
     sets the object as configured.
  <p>
     An object is configured once its <b><i>finalize_instance</i></b> method
     (<b><i>post_init</i></b> in DML) has completed, or
     <b><i>SIM_set_object_configured</i></b> has been called for it. Being
     configured indicates that the object is in a consistent state and is
     ready to be used by other objects.
  </p><p>
     <b><i>SIM_set_object_configured</i></b> is used to avoid circular
     dependencies between objects. It may only be called from the object's
     own <b><i>finalize_instance</i></b> method, when the object is known to
     be in a consistent state.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
<b><i>SIM_object_is_configured</i></b>:
       all contexts (including Threaded Context);
       <b><i>SIM_set_object_configured</i></b>: Global Context
     </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_require_object">
       SIM_require_object</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_class"> SIM_register_class</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_is_restoring_state"> SIM_is_restoring_state
     </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_object_name">SIM_object_name()</a></h3>
<p>

<a name="SIM_object_name2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_object_name"></a><b>SIM_object_name</b> — get object name</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_object_name(const conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the name of an object. This name identifies the object
   uniquely, but may change if the object is moved to another
   hierarchical location.
<p>
   The return value is a string, owned by <code>obj</code>, that should not be
   modified or freed by the caller.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_object_id">SIM_object_id</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_picosecond_clock">SIM_picosecond_clock()</a></h3>
<p>

<a name="SIM_picosecond_clock2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_picosecond_clock"></a><b>SIM_picosecond_clock</b> — get object picosecond clock</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_picosecond_clock(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the picosecond clock used by an object <i>obj</i>.
<p>
   The returned clock uses a cycle period of exactly 1 ps. It
   has full picosecond resolution even if the processor (or clock)
   driving the simulation uses a lower resolution.
   An event posted at a particular picosecond triggers always at that
   precise time, without any rounding issues.
</p><p>
   The returned object is the <b>vtime.ps</b> port object of
   the default clock for the object, and it implements the
   <code>cycle_event</code> interface.
</p><p>
   The API functions <b><i>SIM_event_post_cycle</i></b>,
   <b><i>SIM_event_post_time</i></b>, <b><i>SIM_event_find_next_cycle</i></b>,
   <b><i>SIM_event_cancel_time</i></b>, and <b><i>SIM_cycle_count</i></b>
   can be used directly on the picosecond clock.
</p><p>
   </p><div class="note">
<b>Note:</b>
The function <b><i>SIM_time</i></b> is currently not
   supported for the picosecond clock; it will return
   same value as if the function is invoked on the default clock.
   </div><div class="note">
<b>Note:</b>
The picosecond clock will wrap around after roughly
   200 days of virtual time (2^64 ps).</div></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_object_clock">SIM_object_clock</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_attribute">SIM_register_attribute()</a></h3>
<p>

<a name="SIM_register_attribute2"></a><a name="SIM_register_class_attribute"></a><a name="SIM_register_attribute_with_user_data"></a><a name="SIM_register_class_attribute_with_user_data"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_attribute"></a><b>SIM_register_attribute</b><b>, SIM_register_class_attribute</b><b>, SIM_register_attribute_with_user_data</b><b>, SIM_register_class_attribute_with_user_data</b> — register attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_attribute(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(conf_object_t *),
        set_error_t (*set_attr)(conf_object_t *, attr_value_t *),
        attr_attr_t attr, const char *type, const char *desc);
</pre><p></p><pre class="jdocu_small">void
SIM_register_class_attribute(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(conf_class_t *),
        set_error_t (*set_attr)(conf_class_t *, attr_value_t *),
        attr_attr_t attr, const char *type, const char *desc);
</pre><p></p><pre class="jdocu_small">void
SIM_register_attribute_with_user_data(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(conf_object_t *, lang_void *),
        lang_void *user_data_get,
        set_error_t (*set_attr)(conf_object_t *, attr_value_t *, lang_void *),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *desc);
</pre><p></p><pre class="jdocu_small">void
SIM_register_class_attribute_with_user_data(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(conf_class_t *, lang_void *),
        lang_void *user_data_get,
        set_error_t (*set_attr)(conf_class_t *, attr_value_t *, lang_void *),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add the attribute <i>name</i> to the set of attributes
   of the class <i>cls</i>.
<p>
   For <b><i>SIM_register_attribute</i></b> and
   <b><i>SIM_register_class_attribute</i></b>, the function
   <i>get_attr</i> is called with the object as argument, and returns
   the current value of the attribute. For
   <b><i>SIM_register_attribute_with_user_data</i></b> and
   <b><i>SIM_register_class_attribute_with_user_data</i></b>, the function
   <i>get_attr</i> takes an additional user data argument, which takes
   the value passed as <i>user_data_get</i>.
</p><p>
   On error, <i>get_attr</i> should call
   <b><i>SIM_attribute_error</i></b>. The return value is then ignored; typically,
   <b><i>SIM_make_attr_invalid</i></b> is used to generate an explicitly invalid
   value.
</p><p>
   If <i>get_attr</i> is a null pointer, the attribute will be
   write-only.
</p><p>
   For <b><i>SIM_register_attribute</i></b> and
   <b><i>SIM_register_class_attribute</i></b>, the function
   <i>set_attr</i> is called with the object as argument. For
   <b><i>SIM_register_attribute_with_user_data</i></b> and
   <b><i>SIM_register_class_attribute_with_user_data</i></b>, the function
   <i>set_attr</i> takes an additional user data argument, which takes
   the value passed as <i>user_data_set</i>. The
   <i>set_attr</i> function is called when the attribute is initialised
   or changed. The argument value is owned by the caller, so any data from it
   must be copied.
</p><p>
   The <i>set_attr</i> method should return <code>Sim_Set_Ok</code>
   if the new value could be set. On error, it should return an appropriate
   error code (usually <code>Sim_Set_Illegal_Value</code>), and optionally
   call <b><i>SIM_attribute_error</i></b> with an explanatory message.
</p><p>
   If <i>set_attr</i> is a null pointer, the attribute will be
   read-only.
</p><p>
   The <i>attr</i> parameter is one of
   <code>Sim_Attr_Required</code>, <code>Sim_Attr_Optional</code> or
   <code>Sim_Attr_Pseudo</code>.
</p><p>
   Attributes marked <code>Sim_Attr_Required</code> or
   <code>Sim_Attr_Optional</code> are saved in checkpoints. Both
   <i>set_attr</i> and <i>get_attr</i> must be non-null
   for such attributes.
</p><p>
   All attributes that are marked <code>Sim_Attr_Required</code>
   must be present in all configurations.
</p><p>
   The set of permitted values is encoded in the string <i>type</i>.
</p><p>
   The type strings are composed as follows:
</p><p>
   </p><ul>
     <li>
       Most types are represented by a single letter:
       <table>

         <tbody><tr>
           <td class="jdocu_noborder"><code>i</code></td>
           <td class="jdocu_noborder">integer</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>f</code></td>
           <td class="jdocu_noborder">floating-point</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>s</code></td>
           <td class="jdocu_noborder">string</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>b</code></td>
           <td class="jdocu_noborder">boolean</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>o</code></td>
           <td class="jdocu_noborder">object</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>d</code></td>
           <td class="jdocu_noborder">data</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>n</code></td>
           <td class="jdocu_noborder">nil</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>a</code></td>
           <td class="jdocu_noborder">any type (not valid when the attribute is marked with
               <code>Sim_Attr_Required</code>)</td>
         </tr>

       </tbody></table>
     </li>

     <li>
       The <code>|</code> (vertical bar) operator specifies the union of
       two types; eg, <code>s|o</code> is the type of a string or an object.
     </li>

     <li>
       Lists are defined inside square brackets: <code>[]</code>. There are two
       kinds of list declarations:
<p>
       </p><ul>
         <li>
           A heterogeneous list of fixed length is defined by the types of its
           elements. For example, <code>[ios]</code> specifies a 3-element list
           consisting of an integer, an object and a string, in that order.
         </li>
         <li>
           A homogeneous list of varying length is defined by a single type
           followed by a length modifier:
<p>
           <table>

             <tbody><tr>
               <td class="jdocu_noborder"><code>{</code><i>N</i><code>:</code><i>M</i><code>}</code></td>
               <td class="jdocu_noborder">between <i>N</i> and <i>M</i> elements, inclusive</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>{</code><i>N</i><code>}</code></td>
               <td class="jdocu_noborder">exactly <i>N</i> elements</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>*</code></td>
               <td class="jdocu_noborder">zero or more elements</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>+</code></td>
               <td class="jdocu_noborder">one or more elements</td>
             </tr>

           </tbody></table>
</p><p>
           For example, <code>[i{3,5}]</code> specifies a list of
           3, 4 or 5 integers.
         </p></li>
       </ul>
<p>
       Inside heterogeneous lists, <code>|</code> (union) has higher precedence
       than juxtaposition; ie, <code>[i|so|n]</code> defines a list of two
       elements, the first being an integer or a string and the second
       an object or NIL.
     </p></li>
   </ul>
<p>
   <b><i>SIM_register_class_attribute</i></b> and
   <b><i>SIM_register_class_attribute_with_user_data</i></b> will register a class
   attribute. Class attributes are the same for all instances of the class.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_class">SIM_register_class()</a></h3>
<p>

<a name="SIM_register_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_class"></a><b>SIM_register_class</b> — register class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_register_class(const char *NOTNULL name,
                   const class_data_t *NOTNULL class_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function is considered legacy. New code should use the 
   <b><i>SIM_create_class</i></b> function to create new classes 
   in the Simics simulator. 
<p>
   The function registers a new class that can be instantiated by
   calling the <b><i>SIM_create_object</i></b> function.
</p><p>
   The <i>name</i> can contain upper and lower case ASCII letters,
   hyphens, underscores, and digits. It must not begin with a digit or a hyphen
   and must not end with a hyphen.
</p><p>
   <i>class_data</i> may be freed when the function has returned.
   
   
</p><pre class="jdocu_small">typedef struct class_data {
        conf_object_t *(*alloc_object)(lang_void *data);
        lang_void *(*init_object)(conf_object_t *obj, lang_void *data);
        void (*finalize_instance)(conf_object_t *obj);

        void (*pre_delete_instance)(conf_object_t *obj);
        int (*delete_instance)(conf_object_t *obj);

        const char           *description;
        const char           *class_desc;
        class_kind_t          kind;
} class_data_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Class structure, or
   <code>NULL</code> on error.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_create_class">
     SIM_create_class</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_class_alias"> SIM_register_class_alias</a>, <a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_class_data_t"> class_data_t
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_class_alias">SIM_register_class_alias()</a></h3>
<p>

<a name="SIM_register_class_alias2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_class_alias"></a><b>SIM_register_class_alias</b> — register class alias</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_class_alias(const char *NOTNULL alias, const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register an alias <i>alias</i> for the existing
   class <i>class_name</i>. Using aliases allows the
   <i>read-configuration</i> command to read configuration files that
   define objects of type <i>alias</i>, while the
   <i>write-configuration</i> command always uses <i>class_name</i>.
<p>
   Aliases are used to support compatibility with old class names if a
   class is renamed. They can also be used to allow different modules,
   which define different specific implementations of the same generic
   base class, to read the same configuration files.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_create_class">
     SIM_create_class</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_class"> SIM_register_class
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_clock">SIM_register_clock()</a></h3>
<p>
  
  

<a name="SIM_register_clock2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_clock"></a><b>SIM_register_clock</b> — register mandatory interface and attributes for clock objects</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_register_clock(conf_class_t *NOTNULL cls,
                   const cycle_interface_t *NOTNULL iface);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register the <i>cls</i> class as a class for schedulable clock
   objects. This includes registering the <code>cycle</code> interface
   (<i>iface</i>), in addition to which <b><i>SIM_register_clock</i></b>
   registers the <i>cell</i> attribute required for scheduling the clock
   and some other Simics specific attributes. Simics will be able to schedule
   objects instantiated from the class <i>cls</i>.
<p>
   The return value is 0 if everything works, and non-zero if something
   fails. Depending on the stage that failed, <b><i>SIM_register_clock()</i></b>
   will return the error value provided by <b><i>SIM_register_interface()</i></b>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns non-zero on failure, 0 otherwise.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the <code>cycle</code> interface has
   already been registered for this class.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_register_interface">
     SIM_register_interface</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_attribute">
     SIM_register_attribute
   </a></dd>
</dl><p>

  </p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_compatible_interfaces">SIM_register_compatible_interfaces()</a></h3>
<p>

<a name="SIM_register_compatible_interfaces2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_compatible_interfaces"></a><b>SIM_register_compatible_interfaces</b> — register earlier versions of interface</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_compatible_interfaces(conf_class_t *NOTNULL cls,
                                   const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register any earlier versions of the interface <i>name</i> for class
   <i>cls</i>. The interface <i>name</i> must already be registered for
   the class.
<p>
   When supported, this function lets a module implement a single version of an
   interface while still exporting earlier versions.
</p><p>
   The following interfaces are currently accepted by this function, with the
   additional interfaces that are exported given in parenthesis:
   BREAKPOINT_QUERY_V2 (BREAKPOINT_QUERY), PROCESSOR_INFO_V2 (PROCESSOR_INFO).</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if no interface is registered with the given
   name, if compatible versions of the interface have already been registered,
   or if the interface does not have any earlier versions that this function
   knows about.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_interface">SIM_register_interface()</a></h3>
<p>

<a name="SIM_register_interface2"></a><a name="SIM_register_port_interface"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_interface"></a><b>SIM_register_interface</b><b>, SIM_register_port_interface</b> — register interface</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_register_interface(conf_class_t *NOTNULL cls, const char *NOTNULL name,
                       const void *NOTNULL iface);
</pre><p></p><pre class="jdocu_small">int
SIM_register_port_interface(conf_class_t *NOTNULL cls,
                            const char *NOTNULL name,
                            const void *NOTNULL iface,
                            const char *NOTNULL portname,
                            const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register that <i>cls</i> implements the <i>name</i>
   interface. The interface itself should be supplied in the
   <i>iface</i> argument.
<p>
   <b><i>SIM_register_port_interface</i></b> registers a port instance
   of an interface that must be looked up using
   <b><i>SIM_get_port_interface</i></b>. The <i>portname</i>
   parameter is the name of the port. The port name may not be the
   same as any attribute name used by the class. A short description
   of the port is provided with the <i>desc</i> parameter and should
   be identical for all interfaces for a port.
</p><p>
   The data <i>iface</i> points to must not be deallocated or overwritten
   by the caller. Simics will use that data to store the interface
   structure. It will never be freed or written to by Simics.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns non-zero on failure, 0 otherwise.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the interface name is illegal, or if this
   interface has already been registered for this class.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_get_interface">SIM_get_interface</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_notifier">SIM_register_notifier()</a></h3>
<p>

<a name="SIM_register_notifier2"></a><a name="SIM_register_tracked_notifier"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_notifier"></a><b>SIM_register_notifier</b><b>, SIM_register_tracked_notifier</b> — register notifier</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_notifier(conf_class_t *NOTNULL cls, notifier_type_t type,
                      const char *desc);
</pre><p></p><pre class="jdocu_small">void
SIM_register_tracked_notifier(conf_class_t *NOTNULL cls, notifier_type_t type,
                              const char *desc,
                              void (*subscribed_changed)(conf_object_t *obj,
                                                         notifier_type_t type,
                                                         bool has_subscribers));
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions add the notifier type <i>type</i> to the set of
   notifiers supported by the class <i>cls</i>. <i>desc</i>
   can be used to provide a descriptive string of the role of the notifier
   for the class.
<p>
   <b><i>SIM_register_notifier</i></b> is the base registration function.
</p><p>
   <b><i>SIM_register_tracked_notifier</i></b> provides an additional
   argument <i>subscribed_changed</i>. If not <code>NULL</code>, this
   callback will be called whenever the existence of installed notifiers of type
   <i>type</i> on objects of class <i>cls</i> changes.
</p><p>
   It is legal to register the same notifier multiple times.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_port">SIM_register_port()</a></h3>
<p>

<a name="SIM_register_port2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_port"></a><b>SIM_register_port</b> — register port class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_port(conf_class_t *NOTNULL cls, const char *NOTNULL name,
                  conf_class_t *NOTNULL port_cls, const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add a port named <i>name</i> of class <i>port_cls</i>
   to the set of ports defined by the class <i>cls</i>.
<p>
   The result of this is that whenever an object of class <i>cls</i> is
   created, Simics will automatically create a port object of class
   <code>port_cls</code>. The name of the port object is created by appending
   <code>.</code> followed by the <i>name</i> string to the parent object's
   name.
</p><p>
   If the port name contains dots or brackets, then intermediate port objects
   are registered as well. For instance, the port name <code>x.array[2]</code> will
   implicitly register ports <code>x</code> of class <code>namespace</code>, and
   <code>x.array</code> of class <code>index-map</code>.
</p><p>
   Each port name may be registered at most once in a class. One exception is
   namespace classes: If the port is registered once as class
   <code>namespace</code> and once as some other class, then the <code>namespace</code>
   registration is dropped. Also, if a port is registered twice as class
   <code>index-map</code>, or twice as class <code>namespace</code>, then the second
   registration is dropped.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_register_simple_port">SIM_register_simple_port</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_simple_port">SIM_register_simple_port()</a></h3>
<p>

<a name="SIM_register_simple_port2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_simple_port"></a><b>SIM_register_simple_port</b> — register port</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_register_simple_port(conf_class_t *NOTNULL cls, const char *NOTNULL name,
                         const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add a port named <i>name</i> to the set of
   ports defined by the class <i>cls</i>. The port will be an
   instance of a class named <i>"parent_class_name.portname"</i> where
   <i>portname</i> is the specified name of the port with
   leading namespaces omitted and any array indices removed.
   The port class is created if it does not exist already.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The port class is returned.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_register_port">SIM_register_port</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_typed_attribute">SIM_register_typed_attribute()</a></h3>
<p>

<a name="SIM_register_typed_attribute2"></a><a name="SIM_register_typed_class_attribute"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_typed_attribute"></a><b>SIM_register_typed_attribute</b><b>, SIM_register_typed_class_attribute</b> — register attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_register_typed_attribute(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(lang_void *user_data,
                                 conf_object_t *obj,
                                 attr_value_t *idx),
        lang_void *user_data_get,
        set_error_t (*set_attr)(lang_void *user_data,
                                conf_object_t *obj,
                                attr_value_t *val, attr_value_t *idx),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *idx_type,
        const char *desc);
</pre><p></p><pre class="jdocu_small">int
SIM_register_typed_class_attribute(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(lang_void *ptr,
                                 conf_class_t *c,
                                 attr_value_t *idx),
        lang_void *user_data_get,
        set_error_t (*set_attr)(lang_void *ptr,
                                conf_class_t *c,
                                attr_value_t *val,
                                attr_value_t *idx),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *idx_type,
        const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add the attribute <i>name</i> to the set of attributes
   of the class <i>cls</i>.
<p>
   The function <i>get_attr</i> is called with the object and the value
   from <i>user_data_get</i> as arguments, and returns the current
   value of the attribute.
</p><p>
   On error, <i>get_attr</i> should call
   <b><i>SIM_attribute_error</i></b>. The return value is then ignored; typically,
   <b><i>SIM_make_attr_invalid</i></b> is used to generate an explicitly invalid
   value.
   </p><p>
   If <i>get_attr</i> is a null pointer, the attribute will be
   write-only.
</p><p>
   The function <i>set_attr</i> is called with the object and the value
   from <i>user_data_set</i> as arguments when the attribute is
   initialised or changed. The argument value is owned by the caller, so any
   data from it must be copied.
</p><p>
   The <i>set_attr</i> method should return <code>Sim_Set_Ok</code>
   if the new value could be set. On error, it should return an appropriate
   error code (usually <code>Sim_Set_Illegal_Value</code>), and optionally
   call <b><i>SIM_attribute_error</i></b> with an explanatory message.
</p><p>
   If <i>set_attr</i> is a null pointer, the attribute will be
   read-only.
</p><p>
   The <i>attr</i> parameter is one of
   <code>Sim_Attr_Required</code>, <code>Sim_Attr_Optional</code>,
   <code>Sim_Attr_Session</code> or <code>Sim_Attr_Pseudo</code>.
</p><p>
   Attributes marked <code>Sim_Attr_Required</code> or
   <code>Sim_Attr_Optional</code> are saved in checkpoints. Both
   <i>set_attr</i> and <i>get_attr</i> must be non-null
   for such attributes.
</p><p>
   All attributes that are marked <code>Sim_Attr_Required</code>
   must be present in all configurations.
</p><p>
   The set of permitted values is encoded in the string <i>type</i>,
   and in <i>idx_type</i> for values during indexed access.
   A <code>NULL</code> value for either type string means that values of
   any type are permitted.
</p><p>
   The type strings are composed as follows:
</p><p>
   </p><ul>
     <li>
       Most types are represented by a single letter:
       <table>

         <tbody><tr>
           <td class="jdocu_noborder"><code>i</code></td>
           <td class="jdocu_noborder">integer</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>f</code></td>
           <td class="jdocu_noborder">floating-point</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>s</code></td>
           <td class="jdocu_noborder">string</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>b</code></td>
           <td class="jdocu_noborder">boolean</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>o</code></td>
           <td class="jdocu_noborder">object</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>d</code></td>
           <td class="jdocu_noborder">data</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>n</code></td>
           <td class="jdocu_noborder">nil</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>D</code></td>
           <td class="jdocu_noborder">dictionary</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>a</code></td>
           <td class="jdocu_noborder">any type</td>
         </tr>

       </tbody></table>
     </li>

     <li>
       The <code>|</code> (vertical bar) operator specifies the union of
       two types; eg, <code>s|o</code> is the type of a string or an object.
     </li>

     <li>
       Lists are defined inside square brackets: <code>[]</code>. There are two
       kinds of list declarations:
       <p>
       </p><ul>
         <li>
           A heterogeneous list of fixed length is defined by the types of its
           elements. For example, <code>[ios]</code> specifies a 3-element list
           consisting of an integer, an object and a string, in that order.
         </li>
         <li>
           A homogeneous list of varying length is defined by a single type
           followed by a length modifier:
<p>
           <table>

             <tbody><tr>
               <td class="jdocu_noborder"><code>{</code><i>N</i><code>:</code><i>M</i><code>}</code></td>
               <td class="jdocu_noborder">between <i>N</i> and <i>M</i> elements, inclusive</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>{</code><i>N</i><code>}</code></td>
               <td class="jdocu_noborder">exactly <i>N</i> elements</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>*</code></td>
               <td class="jdocu_noborder">zero or more elements</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>+</code></td>
               <td class="jdocu_noborder">one or more elements</td>
             </tr>

           </tbody></table>
</p><p>
           For example, <code>[i{3,5}]</code> specifies a list of 
           3, 4 or 5 integers.
         </p></li>
       </ul>
<p>
       Inside heterogeneous lists, <code>|</code> (union) has higher precedence
       than juxtaposition; ie, <code>[i|so|n]</code> defines a list of two
       elements, the first being an integer or a string and the second
       an object or NIL.
     </p></li>
   </ul>
<p>
   <b><i>SIM_register_typed_class_attribute</i></b> will register a class
   attribute. Class attributes are the same for all instances of the class.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns zero if successful, and
   non-zero otherwise.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the attribute name is invalid, and if the
   attribute is not a required, optional, session or pseudo attribute.<br>
<p>
   <b>SimExc_AttrNotReadable</b> Thrown if a checkpointed attribute is not
   readable.<br>
</p><p>
   <b>SimExc_AttrNotWritable</b> Thrown if a checkpointed attribute is not
   writable.<br>
   </p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_require_object">SIM_require_object()</a></h3>
<p>

<a name="SIM_require_object2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_require_object"></a><b>SIM_require_object</b> — make sure an object is fully configured</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_require_object(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
If <i>obj</i> has not yet been set as configured, then that
     object's <b><i>finalize</i></b> method (<b><i>post_init</i></b> in
     DML) is run; otherwise, nothing happens. After completion of that
     method, <i>obj</i> will be set as configured.
  <p>
     Each object will have its <b><i>finalize</i></b> method called automatically,
     usually in hierarchical order, during object creation. Since it is only
     permitted to call methods on objects that have been configured,
     <b><i>SIM_require_object</i></b> is a way to allow such calls during
     finalisation by ensuring that those objects are correctly set up. A better
     way to call methods on other objects during finalization is to defer such
     calls to the <b><i>objects_finalized</i></b> method.
  </p><p>
     <b><i>SIM_require_object</i></b> may only be called from the
     <b><i>finalize</i></b> method of another object.
  </p><p>
     Finalisation cycles can occur if two or more objects call
     <b><i>SIM_require_object</i></b> on each other. Such cycles are treated as
     errors. To avoid them, call <b><i>SIM_set_object_configured</i></b> as soon
     as the object has reached a consistent state.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_object_is_configured">
       SIM_object_is_configured</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_create_class">
       SIM_create_class</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_is_restoring_state">
       SIM_is_restoring_state
     </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_attribute_default">SIM_set_attribute_default()</a></h3>
<p>

<a name="SIM_set_attribute_default2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_attribute_default"></a><b>SIM_set_attribute_default</b> — set default value for an attribute in a child object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">set_error_t
SIM_set_attribute_default(conf_object_t *NOTNULL obj, const char *NOTNULL name,
                          attr_value_t val);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_set_attribute_default</i></b> sets the default value
   for attribute <i>name</i> of object <i>obj</i>.
   The default value is used if no explicit value has been provided
   when the object is instantiated.
<p>
   After the call <i>val</i> is still owned by the caller.
</p><p>
   The function may only called while <i>obj</i> is being
   under construction and before its attributes have been set.
   More precisely, it is only legal to use this function from 
   <b><i>init_object</i></b> callbacks or from an attribute setters
   belonging to a hierarchical ancestor of the object.
</p><p>
   The main purpose of this function is setting suitable default
   attribute values for port objects.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns <code>Sim_Set_Ok</code>
   if successful.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_register_port">
     SIM_register_port</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_register_class"> SIM_register_class
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_class_data">SIM_set_class_data()</a></h3>
<p>

<a name="SIM_set_class_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_class_data"></a><b>SIM_set_class_data</b> — set class data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_set_class_data(conf_class_t *cls, lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set extra data for the specified class. This is particularly useful if the
   same class methods are used for multiple distinct classes, for instance for
   generated classes.
<p>
   The class data can be fetched at any time during the object initialisation,
   using <b><i>SIM_get_class_data</i></b>.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_get_class_data">SIM_get_class_data</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Callbacks">Callbacks</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_cbdata_data">SIM_cbdata_data()</a></h3>
<p>

<a name="SIM_cbdata_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_cbdata_data"></a><b>SIM_cbdata_data</b> — get cbdata data pointer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void *
SIM_cbdata_data(const cbdata_t *cbd);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the data pointer of the callback data <i>cbd</i>.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_cbdata_type">SIM_cbdata_type()</a></h3>
<p>

<a name="SIM_cbdata_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_cbdata_type"></a><b>SIM_cbdata_type</b> — get cbdata type pointer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE const cbdata_type_t *
SIM_cbdata_type(const cbdata_t *cbd);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a pointer to the type information of the callback data
     <i>cbd</i>.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_free_cbdata">SIM_free_cbdata()</a></h3>
<p>

<a name="SIM_free_cbdata2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_free_cbdata"></a><b>SIM_free_cbdata</b> — free cbdata</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_free_cbdata(cbdata_t *cbd);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Free the callback data <i>cbd</i> by calling its
     <b><i>dealloc</i></b> function.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_cbdata">SIM_make_cbdata()</a></h3>
<p>

<a name="SIM_make_cbdata2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_cbdata"></a><b>SIM_make_cbdata</b> — create cbdata</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE cbdata_t
SIM_make_cbdata(const cbdata_type_t *type, void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create new callback data of type <i>type</i> and value
     <i>data</i>.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_simple_cbdata">SIM_make_simple_cbdata()</a></h3>
<p>

<a name="SIM_make_simple_cbdata2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_simple_cbdata"></a><b>SIM_make_simple_cbdata</b> — create untyped cbdata</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE cbdata_t
SIM_make_simple_cbdata(void *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create new untyped callback data of value <i>data</i>. An untyped
     callback data has no <b><i>dealloc</i></b> function.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Errors-and-Exceptions">Errors and Exceptions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_clear_exception">SIM_clear_exception()</a></h3>
<p>

<a name="SIM_clear_exception2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_clear_exception"></a><b>SIM_clear_exception</b> — clear pending exception</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sim_exception_t
SIM_clear_exception(void);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Clears the currently pending frontend exception and returns the value of it.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns the exception that was pending before
   the call, or <code>SimExc_No_Exception</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
     </a><b><i>SIM_get_pending_exception</i></b>, <b><i>SIM_last_error</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_describe_pseudo_exception">SIM_describe_pseudo_exception()</a></h3>
<p>

<a name="SIM_describe_pseudo_exception2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_describe_pseudo_exception"></a><b>SIM_describe_pseudo_exception</b> — return pseudo exception description</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_describe_pseudo_exception(exception_type_t ex);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns a descriptive string for the specified
   <code>exception_type_t</code>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Exception description, or
   an error message if input is not a known pseudo-exception.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_exception_type_t">
     exception_type_t
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_pending_exception">SIM_get_pending_exception()</a></h3>
<p>

<a name="SIM_get_pending_exception2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_pending_exception"></a><b>SIM_get_pending_exception</b> — get current pending exception</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sim_exception_t
SIM_get_pending_exception(void);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the exception type of the current pending exception,
   or <code>SimExc_No_Exception</code> if none available.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
     </a><b><i>SIM_clear_exception</i></b>, <b><i>SIM_last_error</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_last_error">SIM_last_error()</a></h3>
<p>

<a name="SIM_last_error2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_last_error"></a><b>SIM_last_error</b> — get error message from last frontend exception</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_last_error(void);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the error message associated with the most recently raised
   frontend exception, even if that exception has been cleared.
<p>
   The returned string is only valid until the next use of the Simics API
   in the same thread.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
     </a><b><i>SIM_clear_exception</i></b>, <b><i>SIM_get_pending_exception</i></b>
   </dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Notifiers">Notifiers</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_add_notifier">SIM_add_notifier()</a></h3>
<p>

<a name="SIM_add_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_add_notifier"></a><b>SIM_add_notifier</b> — add a notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">notifier_handle_t *
SIM_add_notifier(
        conf_object_t *NOTNULL obj,
        notifier_type_t type,
        conf_object_t *subscriber,
        void (*callback)(conf_object_t *subscriber,
                         conf_object_t *NOTNULL notifier,
                         lang_void *data),
        lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_add_notifier</i></b> installs a notifier of type <i>type</i>
   on the object <i>obj</i>.
<p>
   The <i>subscriber</i> argument should be the object listening for
   the notification; this object is passed as the first
   argument to the <i>callback</i> function. The installed callback is
   automatically removed if the subscriber object is deleted.
   It is legal to pass <code>NULL</code> in the <i>subscriber</i>
   argument if there is no object associated with the callback. 
</p><p>
   The <i>data</i> argument is passed as the last argument to the
   <i>callback</i> function.
</p><p>
   The function returns a handle to the installed notifier
   or <code>NULL</code> if the notifier type is not supported by the object.
</p><p>
   Adding a notifier callback from another notifier callback of the same
   notifier type and object does not trigger an immediate callback invocation
   (from the same call to <b><i>SIM_notify</i></b>).</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_class_has_notifier">SIM_class_has_notifier()</a></h3>
<p>

<a name="SIM_class_has_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_class_has_notifier"></a><b>SIM_class_has_notifier</b> — query class for notifier</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_class_has_notifier(conf_class_t *NOTNULL cls, notifier_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>Sim_class_has_notifier</i></b> returns <code>true</code> if the class
   <i>cls</i> supports the notifier specified by <i>type</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_delete_notifier">SIM_delete_notifier()</a></h3>
<p>

<a name="SIM_delete_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_delete_notifier"></a><b>SIM_delete_notifier</b> — delete notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_delete_notifier(conf_object_t *NOTNULL obj, notifier_handle_t *handle);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_delete_notifier</i></b> deletes the notifier callback
   specified by the handle <i>handle</i>.
<p>
   Notifiers callbacks are deleted automatically when
   the subscribing object is deleted.
</p><p>
   Deleting a notifier callback from another notifier callback of the same
   notifier type and object may or may not inhibit the last invocation of the
   deleted callback; this is undefined.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_has_notifier">SIM_has_notifier()</a></h3>
<p>

<a name="SIM_has_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_has_notifier"></a><b>SIM_has_notifier</b> — query object for notifier</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_has_notifier(conf_object_t *NOTNULL obj, notifier_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_has_notifier</i></b> returns <code>true</code> if the object
   <i>obj</i> supports the notifier specified by <i>type</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_notify">SIM_notify()</a></h3>
<p>

<a name="SIM_notify2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_notify"></a><b>SIM_notify</b> — trigger notification callbacks</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_notify(conf_object_t *NOTNULL obj, notifier_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_notify</i></b> function triggers all callbacks
   associated with the notifier <i>notifier</i> which have been
   installed on the object <i>obj</i>.
   <p>
   The order in which notifier callbacks are invoked is undefined, but the same
   order every time.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Global-notifiers">Global notifiers</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_add_global_notifier">SIM_add_global_notifier()</a></h3>
<p>

<a name="SIM_add_global_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_add_global_notifier"></a><b>SIM_add_global_notifier</b> — add a global notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">global_notifier_callback_t *
SIM_add_global_notifier(
        global_notifier_type_t type,
        conf_object_t *subscriber,
        void (*callback)(conf_object_t *subscriber, lang_void *data),
        lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_add_global_notifier</i></b> installs a callback on the global
   notifier of type <i>type</i>. The callback will be executed in
   Global Context. The callback can uninstall itself, using
   <b><i>SIM_delete_global_notifier</i></b>, but must not uninstall any other
   global notifiers.
<p>
   The <i>subscriber</i> argument should be the object listening on
   the notifier; this object is passed as the first
   argument to the callback. The installed callback is automatically
   removed if the subscriber object is deleted.
   It is legal to pass <code>NULL</code> in the <i>subscriber</i>
   argument if there is no object associated with the callback. 
</p><p>
   The function returns a handle to the installed callback
   or <code>NULL</code> if the notifier type is unknown.
</p><p>
   Adding a notifier callback from another notifier callback of the same
   notifier type does not trigger an immediate callback invocation.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_add_global_notifier_once">SIM_add_global_notifier_once()</a></h3>
<p>

<a name="SIM_add_global_notifier_once2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_add_global_notifier_once"></a><b>SIM_add_global_notifier_once</b> — add a global notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">global_notifier_callback_t *
SIM_add_global_notifier_once(
        global_notifier_type_t type,
        conf_object_t *subscriber,
        void (*callback)(conf_object_t *subscriber, lang_void *data),
        lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_add_global_notifier_once</i></b> is similar to
   <b><i>SIM_add_global_notifier</i></b>, except that the notifier will be removed
   automatically after the callback has been called once.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_delete_global_notifier">SIM_delete_global_notifier()</a></h3>
<p>

<a name="SIM_delete_global_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_delete_global_notifier"></a><b>SIM_delete_global_notifier</b> — delete global notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_delete_global_notifier(global_notifier_callback_t *handle);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_delete_global_notifier</i></b> deletes the global notifier callback
   specified by the handle <i>handle</i>.
<p>
   Global notifier callbacks are deleted automatically when
   the subscribing object is deleted.
</p><p>
   Deleting a notifier callback from another notifier callback of the same
   notifier type may or may not inhibit the last invocation of the deleted
   callback; this is undefined.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Haps">Haps</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_hap_add_type">SIM_hap_add_type()</a></h3>
<p>

<a name="SIM_hap_add_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_hap_add_type"></a><b>SIM_hap_add_type</b> — register a new hap type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">hap_type_t
SIM_hap_add_type(const char *NOTNULL hap,
                 const char *NOTNULL params,
                 const char *param_desc,
                 const char *index,
                 const char *desc,
                 int unused);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Creates a run-time defined hap type. 
<p>
   The <i>params</i> parameter specifies the argument that callbacks
   for this hap is called with; e.g., <code>"s"</code> or
   <code>"II"</code>. The first two arguments are always <code>lang_void *</code>
   and <code>conf_object_t *</code> respectively, and should not be included
   in that string. The table below shows which characters may be used, and
   what their meaning is:
</p><p>
   <table>

   <tbody><tr><td class="jdocu_noborder"><code>i</code></td><td class="jdocu_noborder">an int</td></tr>

   <tr><td class="jdocu_noborder"><code>I</code></td><td class="jdocu_noborder">an int64 (64 bit integer)</td></tr>

   <tr><td class="jdocu_noborder"><code>e</code></td><td class="jdocu_noborder">an <code>exception_type_t</code></td></tr>

   <tr><td class="jdocu_noborder"><code>o</code></td><td class="jdocu_noborder">a script specific object; i.e.,
           <code>void *</code> in C and any Python object in Python</td></tr>

   <tr><td class="jdocu_noborder"><code>s</code></td><td class="jdocu_noborder">a string</td></tr>

   <tr><td class="jdocu_noborder"><code>m</code></td><td class="jdocu_noborder">a memory transaction
           (<code>generic_transaction_t *</code> in C)</td></tr>

   <tr><td class="jdocu_noborder"><code>c</code></td><td class="jdocu_noborder">a configuration object
           (<code>conf_object_t *</code> in C)</td></tr>

   </tbody></table>
</p><p>
   <i>param_desc</i> should be a string of space-separated
   parameter names, or NULL if <i>params</i> is the empty
   string. There should be one word in <i>param_desc</i> for each
   character in <i>params</i>.
</p><p>
   <i>index</i> is a string describing the index value for this hap, or
   NULL if there is no index value.
</p><p>
   <i>desc</i> is a description string for the hap.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if hap is already defined.  However, consequent
   calls with the same parameters will be successful, and return the same hap
   type number each time.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The hap type
   number or -1 on error.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_hap_get_name">SIM_hap_get_name()</a></h3>
<p>

<a name="SIM_hap_get_name2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_hap_get_name"></a><b>SIM_hap_get_name</b> — get hap name by number</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_hap_get_name(hap_type_t hap);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the name of <i>hap</i>, or <code>NULL</code> for no
   such hap. The returned value is a static string that should not
   be modified or freed by the caller.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_hap_get_number">SIM_hap_get_number()</a></h3>
<p>

<a name="SIM_hap_get_number2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_hap_get_number"></a><b>SIM_hap_get_number</b> — get hap number by name</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">hap_type_t
SIM_hap_get_number(const char *NOTNULL hap);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the runtime number associated with a hap identifier. All haps are
   listed in the <em>Haps</em> chapter in each reference manual.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Lookup</b> Thrown if no hap is associated with name <i>hap</i>.
<p>
   </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The hap type number, or 0 on failure.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_hap_is_active">SIM_hap_is_active()</a></h3>
<p>

<a name="SIM_hap_is_active2"></a><a name="SIM_hap_is_active_obj"></a><a name="SIM_hap_is_active_obj_idx"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_hap_is_active"></a><b>SIM_hap_is_active</b><b>, SIM_hap_is_active_obj</b><b>, SIM_hap_is_active_obj_idx</b> — check if hap has callbacks</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_hap_is_active(hap_type_t hap);
</pre><p></p><pre class="jdocu_small">bool
SIM_hap_is_active_obj(hap_type_t hap, conf_object_t *NOTNULL obj);
</pre><p></p><pre class="jdocu_small">bool
SIM_hap_is_active_obj_idx(hap_type_t hap, conf_object_t *NOTNULL obj,
                          int64 index);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Indicate whether the hap has any callback functions to be called
   when the hap is triggered with the given arguments (object and
   index). The return value is approximate: if false, no functions
   would be called; if true, there may be functions to call.
<p>
   The <b><i>SIM_hap_is_active</i></b> function should be avoided; it may be
   slower and less precise than the other variants.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_hap_occurred_always">SIM_hap_occurred_always()</a></h3>
<p>

<a name="SIM_hap_occurred_always2"></a><a name="SIM_c_hap_occurred_always_vararg"></a><a name="SIM_c_hap_occurred_always"></a><a name="SIM_hap_occurred"></a><a name="SIM_c_hap_occurred_vararg"></a><a name="SIM_c_hap_occurred"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_hap_occurred_always"></a><b>SIM_hap_occurred_always</b><b>, SIM_c_hap_occurred_always_vararg</b><b>, SIM_c_hap_occurred_always</b><b>, SIM_hap_occurred</b><b>, SIM_c_hap_occurred_vararg</b><b>, SIM_c_hap_occurred</b> — trigger a hap occurrence</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_hap_occurred_always(hap_type_t hap, conf_object_t *obj,
                        int64 value, attr_value_t *NOTNULL list);
</pre><p></p><pre class="jdocu_small">int
SIM_c_hap_occurred_always_vararg(hap_type_t hap, conf_object_t *obj,
                                 int64 value, va_list ap);
</pre><p></p><pre class="jdocu_small">int
SIM_c_hap_occurred_always(hap_type_t hap, conf_object_t *obj,
                          int64 value, ...);
</pre><p></p><pre class="jdocu_small">int
SIM_hap_occurred(hap_type_t hap, conf_object_t *obj,
                 int64 value, attr_value_t *NOTNULL list);
</pre><p></p><pre class="jdocu_small">int
SIM_c_hap_occurred_vararg(hap_type_t hap, conf_object_t *obj,
                          int64 value, va_list ap);
</pre><p></p><pre class="jdocu_small">int
SIM_c_hap_occurred(hap_type_t hap, conf_object_t *obj,
                   int64 value, ...);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions are used to trigger a hap of type <code>hap</code>. When a hap
   triggers, all callback functions installed on the hap are called.
<p>
   The <code>obj</code> argument is the object that the hap triggering is
   associated with. It may be NULL for haps that are not associated with an
   object.
</p><p>
   The <code>value</code> argument is used for filtering out callback functions to
   call based on the index or range that they are installed for. What the
   index or range corresponds to is hap specific, but could for example be the
   exception number for the <code>Core_Exception</code> hap.
</p><p>
   SIM_hap_occurred() will only call the callbacks once every simulated cycle;
   if this hap is triggered several times during one cycle, the callbacks will
   still only be called once. The SIM_hap_occurred_always() function will
   always call the hap callback functions every time. It is recommended that
   SIM_hap_occurred_always() is used.
</p><p>
   These hap triggering functions return whether or not there were any matching
   callback function registered on the hap. This can be useful information when
   one wants a default behavior to be triggered (for example, stopping the
   simulation) if nobody is listening to the hap.
</p><p>
   The hap-specific parameters to the callback function can be passed in
   various ways: The <b><i>SIM_c_hap_occurred...</i></b> functions are only
   available in C/C++ and are variadic or take a <code>va_list</code> as argument.
   <b><i>SIM_hap_occurred</i></b> and <b><i>SIM_hap_occurred_always</i></b> are
   mainly intended to be used from Python, taking the parameters from an
   attribute value of list type, or an empty list (<code>[]</code>) if no
   parameters are passed. In all cases, the number and types of passed
   parameters must agree with the hap type definition.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The return value is 0 if no callbacks are
   registered on the hap and non-zero if there are callbacks registered.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if <code>hap</code> is not a valid hap type or if
   the values in the <code>list</code> argument are of the wrong type.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_hap_remove_type">SIM_hap_remove_type()</a></h3>
<p>

<a name="SIM_hap_remove_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_hap_remove_type"></a><b>SIM_hap_remove_type</b> — remove a hap type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_hap_remove_type(const char *NOTNULL hap);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Remove a run-time defined hap type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Logging">Logging</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_log_info">SIM_log_info()</a></h3>
<p>

<a name="SIM_log_info2"></a><a name="SIM_log_spec_violation"></a><a name="SIM_log_unimplemented"></a><a name="SIM_log_error"></a><a name="SIM_log_critical"></a><a name="SIM_log_message"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_log_info"></a><b>SIM_log_info</b><b>, SIM_log_spec_violation</b><b>, SIM_log_unimplemented</b><b>, SIM_log_error</b><b>, SIM_log_critical</b><b>, SIM_log_message</b> — output log message</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_log_info(int level, conf_object_t *NOTNULL dev, int grp,
             const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_spec_violation(int level, conf_object_t *NOTNULL dev, int grp,
                       const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_unimplemented(int level, conf_object_t *NOTNULL dev, int grp,
                      const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_error(conf_object_t *NOTNULL dev, int grp,
              const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_critical(conf_object_t *NOTNULL dev, int grp,
                 const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_message(conf_object_t *obj, int level, uint64 group_ids,
                log_type_t log_type, const char *message);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These logging functions are used to emit information and error messages.
<p>
   The <i>level</i> parameter indicates the importance; a lower value
   means a more important message. <b><i>SIM_log_error</i></b> 
   has no <i>level</i> parameter and will always emit messages.
</p><p>
   <i>level</i> should be between 1 and 4:
   </p><ol>
     <li>important messages that are always printed</li>
     <li>"high-level" informative messages</li>
     <li>standard debug messages</li>
     <li>detailed information, such as register accesses</li>
   </ol>
<p>
   The <i>grp</i> parameter should have a bit set for each log
   group that the message corresponds to, as defined by the
   <b><i>SIM_log_register_groups</i></b> function, while a value of 0
   equals <i>any</i> group.
</p><p>
   The <i>level</i> and <i>grp</i> parameters allow
   the user to selectively display more or fewer messages using the
   <b>log-level</b>, <b>log-group</b> and <b>log-type</b>
   commands.
</p><p>
   The <i>fmt</i> argument and those following it are used for string
   formatting in the same way as in the standard <b><i>sprintf</i></b> function.
</p><p>
   The logging functions are among the few Simics API functions that may be
   called while a frontend exception is pending.
</p><p>
   Note that the macro versions of these functions, listed below, are
   usually more efficient.
</p><p>
   The use of the different functions is discussed in
   <em>Simics Model Builder User's Guide</em>, section "Logging":
   </p><ul>
     <li><em>info</em>: Normal informational message</li>
     <li><em>error</em>: Unexpected error in the model
         (indicates a bug in the model)</li>
     <li><em>critical</em>: Critical error that will interrupt the simulation
         (indicates a bug that the model may not recover from)</li>
     <li><em>spec_violation</em>: Target program violates the specification</li>
     <li><em>unimplemented</em>: Attempt to use not yet implemented
         functionality</li>
   </ul>
   If the <i>sim-&gt;fail_on_warnings</i> attribute is set to true, for
   example if Simics was started with the <code>-werror</code> command line flag,
   then Simics will exit with an error code when a log message of the
   <em>error</em> type is generated.
<p>
   </p><pre class="jdocu_small">#define SIM_LOG_INFO(level, dev, grp, ...)
#define SIM_LOG_SPEC_VIOLATION(level, dev, grp, ...)
#define SIM_LOG_UNIMPLEMENTED(level, dev, grp, ...)
#define SIM_LOG_ERROR(dev, grp, ...)
#define SIM_LOG_CRITICAL(dev, grp, ...)
#define SIM_LOG_INFO_ONCE(level1, level2, dev, grp, ...)
#define SIM_LOG_SPEC_VIOLATION_ONCE(level1, level2, dev, grp, ...)
#define SIM_LOG_UNIMPLEMENTED_ONCE(level1, level2, dev, grp, ...)
   </pre><p></p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
     </a><b><i>SIM_log_register_groups</i></b>, <b><i>SIM_attribute_error</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_log_level">SIM_log_level()</a></h3>
<p>

<a name="SIM_log_level2"></a><a name="SIM_set_log_level"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_log_level"></a><b>SIM_log_level</b><b>, SIM_set_log_level</b> — set and get log level</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">unsigned
SIM_log_level(const conf_object_t *NOTNULL obj);
</pre><p></p><pre class="jdocu_small">void
SIM_set_log_level(conf_object_t *NOTNULL obj, unsigned level);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or set the log level of an object.
   The level must be in the range 0..4 inclusive.
   Higher values mean more detailed logging.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_log_register_groups">SIM_log_register_groups()</a></h3>
<p>

<a name="SIM_log_register_groups2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_log_register_groups"></a><b>SIM_log_register_groups</b> — register names of log groups</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_log_register_groups(conf_class_t *NOTNULL cls,
                        const char *const *NOTNULL names);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register a list of log groups that an object can
   use to separate messages. The order of the groups in the list defines the
   group ids that should be used in calls to <b><i>SIM_log_info</i></b> and
   similar functions. The <i>group_ids</i> argument to those functions
   should have a bit set corresponding to the group; i.e., a value of 1 for the
   first group, 2 for the second, 4 for the third, etc. <i>names</i>
   should be a <code>NULL</code>-terminated array.
<p>
   A class may have up to 63 user-defined log groups.
</p><p>
   The <code>Default_Log_Group</code> group is present on all classes. It is used
   for log entries where no group is specified.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_log_info</i></b></dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Transaction-Types">Transaction Types</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="atom_id_t">atom_id_t</a></h3>
<p>
     
     
   <a name="atom_id_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_atom_id_t"></a>atom_id_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Each atom type is associated
   with a unique id, the <code>atom_id_t</code>. Most atoms types are
   pre-defined by Simics Core and have static ids, but there are
   also dynamically assigned ids which are used for custom atom types.
<p>
   Atom ids are internal to Simics Core and should never be used explicitly
   by a Simics models. Instead, there are API functions like
   e.g. <b><i>ATOM_size</i></b> or <b><i>ATOM_initiator</i></b> which should be
   used instead.
   </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" name="atom_t">atom_t</a></h3>
<p>
     
     
   <a name="atom_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_atom_t"></a>atom_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>atom_t</code> type is a container
   type for tagged data associated with a transaction. The kind of data
   stored in the atom is determined by the <i>id</i> field, and a pointer
   to the data or the data itself is stored in the <i>ptr</i> field.
<p>
   Atoms should always be initialized using provided constructor functions
   like <b><i>ATOM_flags</i></b> or <b><i>ATOM_size</i></b>. Usage of
   the constructors ensures that the data payload is of the correct type
   and that the <b><i>id</i></b> is set to the correct value.
</p><p>
   Atom lists must be terminated with the special <code>ATOM_LIST_END</code>
   marker.
   </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" name="transaction_completion_t">transaction_completion_t</a></h3>
<p>
     
     
   <a name="transaction_completion_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_transaction_completion_t"></a>transaction_completion_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef exception_type_t (*transaction_completion_t)(
        conf_object_t *obj, transaction_t *t, exception_type_t ex);</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Callback invoked when an asynchronous transaction is completed.
   The callback is stored in a <code>completion</code> atom belonging
   to the transaction <i>t</i>. Similarly, <i>obj</i> is an
   object stored in either an <code>owner</code> atom or an
   <code>initiator</code> atom. The former takes precedence if both are
   present.
<p>
   Completion callbacks are only invoked for transactions monitored
   with either <b><i>SIM_monitor_transaction</i></b> or
   <b><i>SIM_monitor_chained_transaction</i></b>, or for transactions
   deferred with <b><i>SIM_defer_owned_transaction</i></b>.
</p><p>
   The completion status for the operation is given in the
   <i>ex</i> argument, and is usually equal to
   <code>Sim_PE_No_Exception</code>.
</p><p>
   The return value of the callback is the completion status
   for the transaction <i>t</i>. This status is used to complete
   the parent transaction if the transaction is being monitored with
   <b><i>SIM_monitor_chained_transaction</i></b>. The return value is
   also returned by <b><i>SIM_monitor_transaction</i></b> or
   <b><i>SIM_monitor_chained_transaction</i></b> when a transaction is
   completed synchronously.
</p><p>
   If the callback returns <code>Sim_PE_Deferred</code>, then
   the transaction <i>t</i> is left uncompleted. It must then
   be completed later on by an explicit call to
   <b><i>SIM_complete_transaction</i></b>.
</p><p>
   </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" name="transaction_flags_t">transaction_flags_t</a></h3>
<p>
     
     
   <a name="transaction_flags_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_transaction_flags_t"></a>transaction_flags_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef enum {
        Sim_Transaction_Fetch         = 1 &lt;&lt; 0,
        Sim_Transaction_Write         = 1 &lt;&lt; 1,
        Sim_Transaction_Control       = 1 &lt;&lt; 2,

        Sim_Transaction_Inquiry       = 1 &lt;&lt; 8,
        Sim_Transaction_Incoherent    = 1 &lt;&lt; 9,
        Sim_Transaction_Atomic        = 1 &lt;&lt; 10,
} transaction_flags_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>transaction_flags_t</code> type is bitmask
   used to specify the transaction type. It is a combination
   of the following bits:
<p>
   <code>Sim_Transaction_Fetch</code> indicates that the transaction is
   an instruction fetch.
</p><p>
   <code>Sim_Transaction_Write</code> is set if the transaction is a write.
</p><p>
   <code>Sim_Transaction_Control</code> is set if the transaction does not
   actually transfer any data. One example of such transactions is
   cache control operations.
</p><p>
   The <code>Sim_Transaction_Inquiry</code> bit signifies that side
   effects normally triggered by the transaction should be suppressed.
   Examples of side effects include triggering breakpoints and
   clearing "read-to-clear" device registers.
</p><p>
   When neither <code>Sim_Transaction_Fetch</code>
   nor <code>Sim_Transaction_Write</code> is set the transaction is
   a read transaction.
</p><p>
   </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" name="transaction_t">transaction_t</a></h3>
<p>
     
     
   <a name="transaction_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_transaction_t"></a>transaction_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A <code>transaction_t</code>
   represents a memory transaction. The properties of the
   transaction is stored in the form of an atom list, where each
   atom describes a particular aspect of the transaction, like the
   size of the transaction.
<p>
   The field <i>atoms</i> points to the atoms list,
   which must be terminated with the constant <code>ATOM_LIST_END</code>.
</p><p>
   The <i>prev</i> field points to an optional parent transaction.
   If a particular atom is not found in the atoms list, then the
   parent's list of atoms is consulted instead. The <i>prev</i>
   pointer is also used when a chained transaction is monitored
   with <b><i>SIM_monitor_chained_transaction</i></b>.
</p><p>
   Besides the fields above, the transaction contains some internal
   fields that should be initialized to 0. The internal fields should
   not be referenced explicitly since they are likely to change
   in future Simics releases.
</p><p>
   For details, please refer to "Transactions" chapter in
   the Model Builder's User Guide.
</p><p>
   </p></dd>
</dl><p>
    </p><h2 class="jdocu"><a class="not-numbered" name="Transactions">Transactions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="ATOM_flags">ATOM_flags()</a></h3>
<p>

<a name="ATOM_flags2"></a><a name="ATOM_data"></a><a name="ATOM_size"></a><a name="ATOM_initiator"></a><a name="ATOM_completion"></a><a name="ATOM_list_end"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_ATOM_flags"></a><b>ATOM_flags</b><b>, ATOM_data</b><b>, ATOM_size</b><b>, ATOM_initiator</b><b>, ATOM_completion</b><b>, ATOM_list_end</b> — transaction atom's constructor</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">static inline atom_t ATOM_flags(transaction_flags_t val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_data(uint8 *val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_size(uint32 val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_initiator(conf_object_t *val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_completion(transaction_completion_t val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_list_end(int val);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The functions construct transaction atoms.
<p>
   <b><i>ATOM_flags</i></b> returns a transaction atom specifying transaction
   flags (see description of <code>transaction_flags_t</code> for information
   about available transaction flags).
</p><p>
   <b><i>ATOM_data</i></b> returns a transaction atom that holds the pointer
   to a buffer that is used to get the data from (for write transactions)
   to store the data to (for read and instruction fetch transactions).
</p><p>
   <b><i>ATOM_size</i></b> returns a transaction atom that holds
   the size of a transaction.
</p><p>
   <b><i>ATOM_initiator</i></b> returns a transaction atom that holds
   the initiator of a transaction.
</p><p>
   <b><i>ATOM_completion</i></b> creates a completion atom - a special atom
   that holds a callback that is invoked when a transaction is completed
   asynchronously.
</p><p>
   <b><i>ATOM_list_end</i></b> returns a special atom that should end the list
   of transaction atoms. One can use the <code>ATOM_LIST_END</code> macro instead.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
An atom value</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Sample C code to create a 1-byte read transaction:
   <span class="jdocu_small">
   <pre class="jdocu_small">     uint8 val;
     atom_t atoms[] = {
         // the flags atom value specifies the transaction type:
         // - 0 defines a read transaction
         // - Sim_Transaction_Write - a write transaction
         // - Sim_Transaction_Fetch - an instruction fetch transaction
         ATOM_flags(0),

         ATOM_data(&amp;val),
         ATOM_size(sizeof val),
         ATOM_initiator(obj),
         ATOM_LIST_END
     };
     transaction_t t = { atoms };
   </pre><p>
   
   </p></span></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><code>transaction_t</code>, <code>transaction_flags_t</code>,
       <code>transaction_completion_t</code>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_complete_transaction">SIM_complete_transaction()</a></h3>
<p>

<a name="SIM_complete_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_complete_transaction"></a><b>SIM_complete_transaction</b> — complete a deferred transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_complete_transaction(transaction_t *t, exception_type_t status);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_complete_transaction</i></b> completes a previously
   deferred transaction <i>t</i> using the exception status
   <i>status</i>. The transaction <i>t</i> must be the
   return value of a previous call to <b><i>SIM_defer_transaction</i></b>
   or a transaction passed to <b><i>SIM_defer_owned_transaction</i></b>.
<p>
   If the transaction <i>t</i> has not been monitored, then the
   completion code is stored in an internal transaction field
   until the transaction is monitored with <b><i>SIM_monitor_transaction</i></b>
   or <b><i>SIM_monitor_chained_transaction</i></b>, at which time
   the completion callback is invoked using the stored completion code.
</p><p>
   Note that <b><i>SIM_complete_transaction</i></b> is normally only used
   to complete asynchronous transactions. Synchronous transactions are
   completed by returning the appropriate return code directly
   from the <b><i>issue</i></b> method.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
        </a><b><i>SIM_defer_transaction</i></b>,
        <b><i>SIM_monitor_transaction</i></b>,
        <b><i>SIM_monitor_chained_transaction</i></b>,
        <b><i>SIM_poll_transaction</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_defer_owned_transaction">SIM_defer_owned_transaction()</a></h3>
<p>

<a name="SIM_defer_owned_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_defer_owned_transaction"></a><b>SIM_defer_owned_transaction</b> — defer transaction completion using an existing transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">transaction_t *
SIM_defer_owned_transaction(transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
When a transaction cannot be completed immediately in the <b><i>issue</i></b>
   method of the <code>transaction</code> interface, then the completion
   can be deferred to a later time by calling <b><i>SIM_defer_transaction</i></b>
   which allocates a new transaction. One alternative is calling
   <b><i>SIM_defer_owned_transaction</i></b> which allows the caller to
   allocate the deferred transaction explicitly, in which case
   provides a heap-allocated transaction <i>t</i> which is linked
   to the transaction which should be deferred through its <i>prev</i>
   field. The provided transaction should have an <code>owner</code> and a
   <code>completion</code> atoms, which are used when the deferred
   transaction is completed.
<p>
   When a transaction is deferred, the status code
   <code>Sim_PE_Deferred</code> must be returned rom
   the <b><i>issue</i></b> method of the <code>transaction</code> interface.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The transaction <i>t</i>, or <code>NULL</code>
   if the transaction was issued synchronously and cannot be deferred.
   When a transaction cannot be deferred, the <b><i>issue</i></b> method
   may choose to return the error status
   <code>Sim_PE_Async_Required</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_defer_transaction">SIM_defer_transaction()</a></h3>
<p>

<a name="SIM_defer_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_defer_transaction"></a><b>SIM_defer_transaction</b> — defer transaction completion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">transaction_t *
SIM_defer_transaction(conf_object_t *obj, transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
When a transaction cannot be completed immediately in the <b><i>issue</i></b>
   method of the <code>transaction</code> interface, then the completion
   can be deferred to a later time by calling <b><i>SIM_defer_transaction</i></b>
   with the transaction as a parameter.
<p>
   The <b><i>SIM_defer_transaction</i></b> function returns a new transaction
   pointer which is guaranteed to be available until it is completed
   with a call to <b><i>SIM_complete_transaction</i></b>.
   When a transaction is deferred, the status code
   <code>Sim_PE_Deferred</code> must be returned from
   the <b><i>issue</i></b> method of the <code>transaction</code> interface.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Deferred transaction, or <code>NULL</code>
   if the transaction was issued synchronously and cannot be deferred.
   When a transaction cannot be deferred, the <b><i>issue</i></b> method
   may choose to return the error status
   <code>Sim_PE_Async_Required</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_transaction_bytes">SIM_get_transaction_bytes()</a></h3>
<p>

<a name="SIM_get_transaction_bytes2"></a><a name="SIM_get_transaction_bytes_offs"></a><a name="SIM_get_transaction_value_le"></a><a name="SIM_get_transaction_value_be"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_transaction_bytes"></a><b>SIM_get_transaction_bytes</b><b>, SIM_get_transaction_bytes_offs</b><b>, SIM_get_transaction_value_le</b><b>, SIM_get_transaction_value_be</b> — get transaction data payload</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_get_transaction_bytes(const transaction_t *t, buffer_t buf);
</pre><p></p><pre class="jdocu_small">void
SIM_get_transaction_bytes_offs(const transaction_t *t, unsigned offs,
                               buffer_t buf, bool zerofill_holes);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_transaction_value_le(const transaction_t *t);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_transaction_value_be(const transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Copy the data payload from a transaction to the provided buffer
   <i>buf</i>. The size of the buffer must match the size of the
   transaction.
<p>
   <b><i>SIM_get_transaction_bytes_offs</i></b> retrieves
   the bytes of the transaction which starts at offset <i>offs</i>.
   The sum of the offset and the buffer size must not
   exceed the transaction size.
   </p><p>
   <b><i>SIM_get_transaction_value_le</i></b> returns the value obtained
   when the transaction buffer is interpreted as an encoded
   little endian integer. The size of the transaction must
   not exceed 8 for this function to be used.
   </p><p>
   <b><i>SIM_get_transaction_value_be</i></b> returns the value obtained
   when the transaction buffer is interpreted as an encoded
   big endian integer.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_transaction_id">SIM_get_transaction_id()</a></h3>
<p>

<a name="SIM_get_transaction_id2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_transaction_id"></a><b>SIM_get_transaction_id</b> — obtain checkpoint ID for a deferred a transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int64
SIM_get_transaction_id(transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_get_transaction_id</i></b> function is used by objects that
   checkpoint the transaction state. The returned ID uniquely identifies the
   transaction and should be stored in a checkpoint together with the relevant
   state that the object keeps for the transaction. The same ID should then be
   given to <b><i>SIM_reconnect_transaction</i></b> during checkpoint load.
<p>
   This function must only be called on a deferred transaction.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
        </a><b><i>SIM_reconnect_transaction</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_inspect_address_routing">SIM_inspect_address_routing()</a></h3>
<p>

<a name="SIM_inspect_address_routing2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_inspect_address_routing"></a><b>SIM_inspect_address_routing</b> — track the route of a transaction through memory hierarchy</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_inspect_address_routing(const map_target_t *NOTNULL mt,
                            transaction_t *NOTNULL t,
                            uint64 addr,
                            bool (*NOTNULL callback)(
                                    const map_target_t *mt,
                                    const transaction_t *t,
                                    uint64 addr,
                                    uint64 base,
                                    uint64 start,
                                    uint64 size,
                                    access_t access,
                                    translation_flags_t flags,
                                    lang_void *data),
                            lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function allows to track the route of a transaction through memory
   hierarchy. The route is traced as if the transaction <i>t</i> was
   issued at the address <i>addr</i> to the destination represented
   by the map target <i>mt</i>. Note that when this function is used
   the endpoint of the transaction will not be accessed.
<p>
   The transaction <i>t</i> can be of any type: a read, a write, or an
   instruction fetch. Please note that the type of the transaction may affect
   its path through memory hierarchy. The size of the transaction
   <i>t</i> is ignored: when accesses are done larger transactions
   may be split depending on how the memory mapping are set up;
   no such splitting is occurred while the transaction route is traced with
   <b><i>SIM_inspect_address_routing</i></b>. It is allowed to use transactions
   with zero size.
</p><p>
   The <i>callback</i> callback will be called for every device (memory
   spaces and translator objects) encountered on the transaction’s route to the
   destination as well as for the destination device (this is usually a device
   implementing the <code>transaction</code> interface or the
   <code>io_memory</code> interface). The first invocation of
   <i>callback</i> is done with the <i>mt</i> argument itself.
</p><p>
   The arguments passed to the callback are:<br>
</p><p>
   - <i>mt</i> is a map target representing an intermediate device or
     the endpoint. If nothing is mapped then <code>NULL</code> (or <code>None</code>
     in Python) value is passed. The map target value should not be cached
     but it can be inspected<br>
</p><p>
   - <i>t</i> is usually the original transaction, but it can be also a
     new transaction in the case when additional atoms were appended to the
     original transaction via the transaction chaining (see, e.g., the
     documentation for the <code>transaction_translator</code> interface)<br>
</p><p>
   - <i>addr</i> is address inside the intermediate device or the
     endpoint where the transaction is sent<br>
</p><p>
   - <i>base</i>, <i>start</i>, <i>size</i>,
     <i>access</i>, and <i>flags</i> arguments describe
     the mapping which led to the <i>mt</i> map target. These
     arguments (except for <i>access</i>) are the same as
     the fields of the <code>translation_t</code> structure. Please refer to
     the <code>translation_t</code>'s documentation for their description.
     The <i>access</i> argument is a bitmask specifying access types.
     The bit corresponding to the type of the <i>t</i> transaction
     is always set. Other access bits may also be set optionally. But
     the latter is not guaranteed even if read/write/execute accesses
     are routed similarly<br>
</p><p>
   - <i>data</i> is the <i>data</i> argument passed to
     <b><i>SIM_inspect_address_routing</i></b><br>
</p><p>
   The <i>callback</i> callback may return false to stop inspection.
   I.e. if the false value is returned <i>callback</i> will not be
   invoked any more.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The function returns false if
   <i>callback</i> returned false in order to stop the inspection.
   Otherwise, true is returned.</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small"> <pre class="jdocu_small"># The following example shows how one can determine
# the destination of a read transaction sent from a CPU object:

import conf, simics

def get_destination(memory_space, address):
    '''Example function returning destination object for the access
    sent to address in the memory space memory_space.'''
    mt = simics.SIM_new_map_target(memory_space, None, None)
    t = simics.transaction_t()  # read transaction of zero size
    l = [None]  # data for the callback

    def callback(mt, t, addr, base, start, size, access, flags, l):
        l[0] = (simics.SIM_map_target_object(mt)
                if mt is not None
                else None)
        return True

    simics.SIM_inspect_address_routing(mt, t, address, callback, l)

    # We free mt here but it can be saved and reused if needed.
    # Transaction t can also be reused.
    simics.SIM_free_map_target(mt)
    return l[0]

# Please specify here CPU object and address you are interested in:
cpu = simics.SIM_get_processor(0)
address_of_access = 0x1000

dest = get_destination(
    cpu.iface.processor_info_v2.get_physical_memory(),
    address_of_access)

print("Destination: ",
      dest.name if dest is not None else "'nothing is mapped'")
</pre><p>
</p><p>
 </p></pre><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_inspect_breakpoints">SIM_inspect_breakpoints()</a></h3>
<p>

<a name="SIM_inspect_breakpoints2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_inspect_breakpoints"></a><b>SIM_inspect_breakpoints</b> — find out breakpoints that a transaction would trigger</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_inspect_breakpoints(
        const map_target_t *NOTNULL mt,
        transaction_t *NOTNULL t,
        uint64 start,
        uint64 end,
        bool (*NOTNULL callback)(
                conf_object_t *trigger_object,
                breakpoint_set_t bp_set,
                const transaction_t *t,
                uint64 start,
                uint64 end,
                lang_void *data),
        lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The function allows to find out the breakpoints that would be triggered
   if a transaction <i>t</i> would be sent to the address range inside
   the map target <i>mt</i>. The address range is specified by
   the <i>start</i> and <i>end</i> arguments and includes
   both start and end of the range. Only breakpoints matching
   the transaction <i>t</i>'s type (i.e., a read, a write,
   or an instruction fetch) are reported. The size of
   the transaction <i>t</i> is ignored and can be zero.
<p>
   For all matching breakpoints Simics invokes <i>callback</i>.
   The <i>callback</i> function may be called multiple times: with
   different <i>trigger_object</i> objects. The <i>callback</i>
   function gets the following two arguments that describe the breakpoints:<br>
</p><p>
   - <i>trigger_object</i> is the object implementing
     the <code>breakpoint_trigger</code> interface. The interface is used
     during simulation to signal that an access triggers a breakpoint<br>
</p><p>
   - <i>bp_set</i> is a set of breakpoints. The breakpoints
     match the transaction <i>t</i>'s type and intersect
     the [<i>start</i>, <i>end</i>] range within
     the <i>mt</i> map target. <i>Bp_set</i> should
     only be used inside <i>callback</i>. Data ownership is preserved
     by the caller (i.e., Simics)<br>
</p><p>
   Auxiliary information is provided to <i>callback</i> via
   the following arguments:<br>
</p><p>
   - <i>t</i> is usually the original transaction, but it can be also
     a new transaction in the case when additional atoms were appended to the
     original transaction via the transaction chaining (see, e.g., the
     documentation for the <code>transaction_translator</code> interface)<br>
</p><p>
   - <i>callback</i>'s <i>start</i> and <i>end</i>
     arguments specify an address range inside the <i>trigger_object</i>
     Simics object where the accesses to the requested address range inside
     the <i>mt</i> map target would go. The size of the range
     reported to <i>callback</i> may be smaller than the size of
     the requested range. This may occur, e.g., when different parts of
     the original address range are translated to different destinations
     based the memory mappings of the simulated machine<br>
</p><p>
   - <i>callback</i>'s <i>data</i> is
     the <i>data</i> argument passed to
     <b><i>SIM_inspect_breakpoints</i></b><br>
</p><p>
   The <i>callback</i> function may return <code>false</code>
   to stop searching for breakpoints. I.e. if the <code>false</code> value
   is returned <i>callback</i> will not be invoked any more
   even if more breakpoints are present.
</p><p>
   The <b><i>SIM_inspect_breakpoints</i></b> function is an inspection function:
   the endpoint of the transaction is never accessed when the function
   is used.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The function returns <code>false</code> if
   <i>callback</i> returned false in order to stop the inspection.
   Otherwise, <code>true</code> is returned.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_issue_transaction">SIM_issue_transaction()</a></h3>
<p>

<a name="SIM_issue_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_issue_transaction"></a><b>SIM_issue_transaction</b> — issue transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">exception_type_t
SIM_issue_transaction(const map_target_t *NOTNULL mt,
                      transaction_t *NOTNULL t, uint64 addr);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_issue_transaction</i></b> issues the transaction <i>t</i>
   with the address <i>addr</i> to the destination
   represented by the map target <i>mt</i>. In Python, the <i>mt</i>
   argument can also be a <code>conf_object_t</code>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The function returns <code>Sim_PE_Deferred</code> if the transaction was
        deferred for completion at a some later time. The corresponding pseudo
        exception is returned if the transaction completed directly (normally
        <code>Sim_PE_No_Exception</code> or <code>Sim_PE_IO_Not_Taken</code>).
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#__jdocu_seealso_SIM_new_map_target">
        SIM_new_map_target</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_free_map_target"> SIM_free_map_target</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_defer_transaction">
        SIM_defer_transaction</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_complete_transaction"> SIM_complete_transaction</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_monitor_transaction">
        SIM_monitor_transaction</a>, <a class="jdocu" href="#__jdocu_seealso_SIM_transaction_wait"> SIM_transaction_wait
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_monitor_transaction">SIM_monitor_transaction()</a></h3>
<p>

<a name="SIM_monitor_transaction2"></a><a name="SIM_monitor_chained_transaction"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_monitor_transaction"></a><b>SIM_monitor_transaction</b><b>, SIM_monitor_chained_transaction</b> — monitor a transaction for deferred completion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">exception_type_t
SIM_monitor_transaction(transaction_t *t, exception_type_t ex);
</pre><p></p><pre class="jdocu_small">exception_type_t
SIM_monitor_chained_transaction(transaction_t *t, exception_type_t ex);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_monitor_transaction</i></b> function monitors
   an asynchronously issued transaction for completion.
   A transaction is asynchronously issued if it has a
   <code>completion</code> atom with a callback which is
   not <code>NULL</code>. The function should be
   called after the transaction has been issued, and the
   <i>ex</i> status code should be the return value from
   function used to <b><i>issue</i></b> the transaction, for example
   the <b><i>issue</i></b> method of the <code>transaction</code>
   interface.
<p>
   If <i>ex</i> equals <code>Sim_PE_Deferred</code>, then
   <b><i>SIM_monitor_transaction</i></b> will check if the transaction has in
   fact been completed already, and in that case, immediately invoke the
   completion callback. If the transaction is still uncompleted, then it
   will be marked as monitored and a subsequent call to
   <b><i>SIM_complete_transaction</i></b> will immediately complete the
   transaction by invoking the completion callback.
</p><p>
   If <i>ex</i> is not equal to <code>Sim_PE_Deferred</code>, then the
   transaction has been completed synchronously, and the completion
   callback is called using <i>ex</i> as the completion status.
</p><p>
   Note that it is illegal to call <b><i>SIM_monitor_transaction</i></b>
   for transactions that do not have a valid
   <code>completion</code> callback.
</p><p>
   <b><i>SIM_monitor_chained_transaction</i></b> is similar to
   <b><i>SIM_monitor_transaction</i></b> except that when a deferred
   transaction is completed, its parent transaction will be completed too.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Exception code returned by the
   completion function, or <code>Sim_PE_Deferred</code> if the
   transaction is monitored for completion at a later time.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
        </a><b><i>SIM_defer_transaction</i></b>,
        <b><i>SIM_complete_transaction</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_poll_transaction">SIM_poll_transaction()</a></h3>
<p>

<a name="SIM_poll_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_poll_transaction"></a><b>SIM_poll_transaction</b> — check if a transaction has completed</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">exception_type_t
SIM_poll_transaction(transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_poll_transaction</i></b> function checks if the transaction
   <i>t</i> is marked as completed, in which case the associated
   status code is returned and the completion status for the transaction
   is cleared. If the transaction is uncompleted, then
   <i>Sim_PE_Deferred</i> is returned.
<p>
   It is illegal to call <b><i>SIM_poll_transaction</i></b> on a transaction
   which is monitored for completion using e.g. the
   <b><i>SIM_monitor_transaction</i></b> function.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_complete_transaction</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_reconnect_transaction">SIM_reconnect_transaction()</a></h3>
<p>

<a name="SIM_reconnect_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_reconnect_transaction"></a><b>SIM_reconnect_transaction</b> — register that a deferred transaction has been restored</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_reconnect_transaction(transaction_t *t, int64 id);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_reconnect_transaction</i></b> function is used by objects that
   checkpoint the transaction state. It should be called when the relevant
   state has been read from a checkpoint.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
        </a><b><i>SIM_get_transaction_id</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_python_atom_type">SIM_register_python_atom_type()</a></h3>
<p>

<a name="SIM_register_python_atom_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_python_atom_type"></a><b>SIM_register_python_atom_type</b> — register an atom type which takes plain Python objects</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_python_atom_type(const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register an atom type named <i>name</i>. The atom type
   can be used from Python and can hold any Python object.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_replace_transaction">SIM_replace_transaction()</a></h3>
<p>

<a name="SIM_replace_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_replace_transaction"></a><b>SIM_replace_transaction</b> — replace transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_replace_transaction(transaction_t *t_old, transaction_t *t_new);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Replace a transaction <i>t_old</i> with a new transaction
   <i>t_new</i>.
<p>
   A transaction which has been issued and is deferred by
   some downstream device can be replaced with a different
   transaction by initiator. This is mostly useful when a
   transaction is allocated on the stack and it turns out that the
   transaction is not completed synchronously, in which case
   <b><i>SIM_replace_transaction</i></b> can be used to move the
   transaction to e.g. the heap.
</p><p>
   This function ensures that the deferred transaction is
   properly linked with the <i>t_new</i> transaction. It
   is the caller's responsibility to fill in the contents
   of the new transaction, including the <i>prev</i> pointer.
</p><p>
   It is illegal to replace a transaction which has been monitored.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_transaction_bytes">SIM_set_transaction_bytes()</a></h3>
<p>

<a name="SIM_set_transaction_bytes2"></a><a name="SIM_set_transaction_bytes_offs"></a><a name="SIM_set_transaction_value_le"></a><a name="SIM_set_transaction_value_be"></a><a name="SIM_set_transaction_bytes_constant"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_transaction_bytes"></a><b>SIM_set_transaction_bytes</b><b>, SIM_set_transaction_bytes_offs</b><b>, SIM_set_transaction_value_le</b><b>, SIM_set_transaction_value_be</b><b>, SIM_set_transaction_bytes_constant</b> — set transaction data payload</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_set_transaction_bytes(const transaction_t *t, bytes_t bytes);
</pre><p></p><pre class="jdocu_small">void
SIM_set_transaction_bytes_offs(const transaction_t *t, unsigned offs,
                               bytes_t bytes);
</pre><p></p><pre class="jdocu_small">void
SIM_set_transaction_value_le(const transaction_t *t, uint64 value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_transaction_value_be(const transaction_t *t, uint64 value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_transaction_bytes_constant(const transaction_t *t, uint8 value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the data payload of a transaction to the contents provided by
   <i>bytes</i>. The number of provided bytes must match the
   transaction size exactly.
<p>
   The <b><i>SIM_set_transaction_bytes_offs</i></b> function sets
   some bytes of the transaction starting at offset <i>offs</i>.
   The sum of the offset and the number of provided bytes must not
   exceed the transaction size.
</p><p>
   The <b><i>SIM_set_transaction_value_le</i></b> function sets
   the transaction bytes to the little endian representation of 
   <i>value</i>. The size of the transaction must
   not exceed 8 for this function to be used. Similarly,
   <b><i>SIM_set_transaction_value_be</i></b> sets the transaction bytes
   to the big endian representation of the provided value.
   If the transaction is smaller than 8 bytes the functions will truncate
   the representation of the value.
</p><p>
   The <b><i>SIM_set_transaction_bytes_constant</i></b> function can be used
   when an endpoint wants to set all transaction bytes to <i>value</i>.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_transaction_flags">SIM_transaction_flags()</a></h3>
<p>

<a name="SIM_transaction_flags2"></a><a name="SIM_transaction_is_fetch"></a><a name="SIM_transaction_is_write"></a><a name="SIM_transaction_is_read"></a><a name="SIM_transaction_is_inquiry"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_transaction_flags"></a><b>SIM_transaction_flags</b><b>, SIM_transaction_is_fetch</b><b>, SIM_transaction_is_write</b><b>, SIM_transaction_is_read</b><b>, SIM_transaction_is_inquiry</b> — return transaction type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">transaction_flags_t
SIM_transaction_flags(const transaction_t *NOTNULL t);
</pre><p></p><pre class="jdocu_small">bool
SIM_transaction_is_fetch(const transaction_t *NOTNULL t);
</pre><p></p><pre class="jdocu_small">bool
SIM_transaction_is_write(const transaction_t *NOTNULL t);
</pre><p></p><pre class="jdocu_small">bool
SIM_transaction_is_read(const transaction_t *NOTNULL t);
</pre><p></p><pre class="jdocu_small">bool
SIM_transaction_is_inquiry(const transaction_t *NOTNULL t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_transaction_flags</i></b> returns a
   <code>transaction_flags_t</code> bitmap describing transaction
   type. Most of the flags can be queried using
   specific accessors.
<p>
   The <b><i>SIM_transaction_is_fetch</i></b> function returns
   <code>true</code> if the transaction is an instruction fetch.
</p><p>
   The <b><i>SIM_transaction_is_read</i></b> function returns
   <code>true</code> if the transaction is a read operation.
</p><p>
   The <b><i>SIM_transaction_is_write</i></b> function returns
   <code>true</code> if the transaction is a write operation.
</p><p>
   The <b><i>SIM_transaction_is_inquiry</i></b> function returns
   <code>true</code> if the transaction is an inquiry operation.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_transaction_initiator">SIM_transaction_initiator()</a></h3>
<p>

<a name="SIM_transaction_initiator2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_transaction_initiator"></a><b>SIM_transaction_initiator</b> — return transaction initiator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_transaction_initiator(const transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the initiator of the transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_transaction_is_deferrable">SIM_transaction_is_deferrable()</a></h3>
<p>

<a name="SIM_transaction_is_deferrable2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_transaction_is_deferrable"></a><b>SIM_transaction_is_deferrable</b> — check if a transaction can be deferred for later completion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_transaction_is_deferrable(const transaction_t *NOTNULL t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The function allows to check whether a transaction can be deferred (with the
   <b><i>SIM_defer_transaction</i></b> or <b><i>SIM_defer_owned_transaction</i></b>
   function) for later completion which is done with a call
   to <b><i>SIM_complete_transaction</i></b>.
<p>
   Usually, this function is not needed since <b><i>SIM_defer_transaction</i></b>
   and <b><i>SIM_defer_owned_transaction</i></b> return <code>NULL</code>
   for transactions that cannot be deferred.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<code>false</code> if the transaction was issued
   synchronously and cannot be deferred. Otherwise, <code>true</code>.
   When a transaction cannot be deferred, endpoint's <b><i>issue</i></b> method
   of the <code>transaction</code> interface may choose
   to return the error status <code>Sim_PE_Async_Required</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_transaction_size">SIM_transaction_size()</a></h3>
<p>

<a name="SIM_transaction_size2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_transaction_size"></a><b>SIM_transaction_size</b> — return transaction size</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">unsigned
SIM_transaction_size(const transaction_t *NOTNULL t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the size of the transaction, in bytes.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_transaction_wait">SIM_transaction_wait()</a></h3>
<p>

<a name="SIM_transaction_wait2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_transaction_wait"></a><b>SIM_transaction_wait</b> — wait for transaction completion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">exception_type_t
SIM_transaction_wait(transaction_t *t, exception_type_t ex);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_transaction_wait</i></b> waits until an issued transaction
   has completed.
<p>
   The function may only be invoked for transactions which
   have a <code>completion</code> atom containing a <code>NULL</code>
   pointer. The <code>NULL</code> pointer means that the
   initiator will wait for transaction completion using this function.
   Moreover, <b><i>SIM_transaction_wait</i></b> must always be called
   after a transaction has been issued with a <code>NULL</code>
   completion callback.
</p><p>
   The <i>ex</i> argument should be the return value of
   the function or method used to issue the transaction.
</p><p>
   <b><i>SIM_transaction_wait</i></b> will not return until the
   transaction has completed. While waiting, a different
   user-level thread will be activated, which allows
   simulated time to advance.
</p><p>
   Note that checkpointing is not possible while waiting for a
   transaction to complete using this function. Moreover, transaction
   wait is not supported from all contexts. When unsupported, the transaction
   will appear to be issued synchronously.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Completion status of the transaction</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Memory-Transactions">Memory Transactions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_arm_mem_trans_from_generic">SIM_arm_mem_trans_from_generic()</a></h3>
<p>

<a name="SIM_arm_mem_trans_from_generic2"></a><a name="SIM_mips_mem_trans_from_generic"></a><a name="SIM_ppc_mem_trans_from_generic"></a><a name="SIM_x86_mem_trans_from_generic"></a><a name="SIM_pci_mem_trans_from_generic"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_arm_mem_trans_from_generic"></a><b>SIM_arm_mem_trans_from_generic</b><b>, SIM_mips_mem_trans_from_generic</b><b>, SIM_ppc_mem_trans_from_generic</b><b>, SIM_x86_mem_trans_from_generic</b><b>, SIM_pci_mem_trans_from_generic</b> — convert generic transaction to CPU specific</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">struct arm_memory_transaction *
SIM_arm_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">struct mips_memory_transaction *
SIM_mips_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">struct ppc_memory_transaction *
SIM_ppc_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">struct x86_memory_transaction *
SIM_x86_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">struct pci_memory_transaction *
SIM_pci_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Converts a pointer to a generic memory transaction into a pointer
   to a CPU specific memory transaction. The generic memory transaction
   must be part of a CPU specific one for this function to succeed.
   The pointer returned will be the same the input pointer if conversion
   is allowed, and NULL on failure.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Type</b> Thrown if the generic transaction is not part of a CPU
   specific transaction.
   <p>
   </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
New memory transaction pointer, or NULL on
   error.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_c_get_mem_op_value_buf">SIM_c_get_mem_op_value_buf()</a></h3>
<p>

<a name="SIM_c_get_mem_op_value_buf2"></a><a name="SIM_get_mem_op_value_buf"></a><a name="SIM_get_mem_op_value_cpu"></a><a name="SIM_get_mem_op_value_le"></a><a name="SIM_get_mem_op_value_be"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_c_get_mem_op_value_buf"></a><b>SIM_c_get_mem_op_value_buf</b><b>, SIM_get_mem_op_value_buf</b><b>, SIM_get_mem_op_value_cpu</b><b>, SIM_get_mem_op_value_le</b><b>, SIM_get_mem_op_value_be</b> — get value for a memory operation</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_c_get_mem_op_value_buf(const generic_transaction_t *NOTNULL mop,
                           uint8 *NOTNULL dst);
</pre><p></p><pre class="jdocu_small">attr_value_t
SIM_get_mem_op_value_buf(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_mem_op_value_cpu(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_mem_op_value_le(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_mem_op_value_be(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns load or store value for a memory transaction. If the data
   size is 8 bytes or less the <b><i>SIM_get_mem_op_value_be</i></b>
   and <b><i>SIM_get_mem_op_value_le</i></b> functions can be used. For
   reads/writes larger than 8 bytes, the functions
   <b><i>SIM_c_get_mem_op_value_buf</i></b> or
   <b><i>SIM_get_mem_op_value_buf</i></b>
   should be used to get the data.
<p>
   If your model is compiled with one of the
   <code>DEVICE_IS_LITTLE_ENDIAN</code>, <code>DEVICE_IS_BIG_ENDIAN</code>
   pre-processor defines, then the
   <b><i><a name="SIM_get_mem_op_value">SIM_get_mem_op_value</a></i></b> function can be used
   as an alias to the <b><i>SIM_get_mem_op_value_le</i></b> and
   <b><i>SIM_get_mem_op_value_be</i></b> versions.
</p><p>
   The <b><i>SIM_c_get_mem_op_value_buf</i></b> function is only available
   from C/C++. It places the data into the buffer pointed to by <i>dst</i>.
   No endian conversion is performed, i.e. data is returned in target
   endianness. There is no alignment requirement on the <code>dst</code>
   parameter.</p></dd>
<dt class="jdocu_descitem">WARNING</dt><dd>
When called from a memory-hierarchy
   (timing-model) only store values can be retrieved, since the load
   has not yet performed. To get the load value, a <i>snoop-device</i>
   should be used.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_c_get_mem_op_value_buf</i></b> returns nothing. The out
   parameter <i>dst</i> is filled with the data buffer of the memory
   transaction. <b><i>SIM_get_mem_op_value_buf</i></b> returns an
   <code>attr_value_t</code> (type data) containing the data buffer
   of the memory transaction.
   <b><i>SIM_get_mem_op_value_be</i></b> returns the zero-extended value
   in host endian order (interpreted as big endian) for the memory transaction.
   <b><i>SIM_get_mem_op_value_le</i></b> returns the zero-extended value
   in host endian order (interpreted as little endian).
   <b><i>SIM_get_mem_op_value_cpu</i></b> interprets the data in the default
   endian order for the initiating processor. This function can only be used
   for processor initiated memory operations. It is recommended that one of the
   other functions are used instead.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Memory</b> Thrown if the size of the operation is illegal.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_c_set_mem_op_value_buf">SIM_c_set_mem_op_value_buf()</a></h3>
<p>

<a name="SIM_c_set_mem_op_value_buf2"></a><a name="SIM_set_mem_op_value_buf"></a><a name="SIM_set_mem_op_value_cpu"></a><a name="SIM_set_mem_op_value_le"></a><a name="SIM_set_mem_op_value_be"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_c_set_mem_op_value_buf"></a><b>SIM_c_set_mem_op_value_buf</b><b>, SIM_set_mem_op_value_buf</b><b>, SIM_set_mem_op_value_cpu</b><b>, SIM_set_mem_op_value_le</b><b>, SIM_set_mem_op_value_be</b> — set value for a memory operation</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_c_set_mem_op_value_buf(generic_transaction_t *NOTNULL mop,
                           const uint8 *NOTNULL src);
</pre><p></p><pre class="jdocu_small">void
SIM_set_mem_op_value_buf(generic_transaction_t *NOTNULL mop,
                         attr_value_t value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_mem_op_value_cpu(generic_transaction_t *NOTNULL mop, uint64 value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_mem_op_value_le(generic_transaction_t *NOTNULL mop, uint64 value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_mem_op_value_be(generic_transaction_t *NOTNULL mop, uint64 value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the value returned to the requester of a memory operation.
   If the data size is 8 bytes or less the <b><i>SIM_set_mem_op_value_be</i></b>
   and <b><i>SIM_set_mem_op_value_le</i></b> functions can be used. For sizes
   larger than 8 bytes, the functions <b><i>SIM_c_set_mem_op_value_buf</i></b>
   or <b><i>SIM_set_mem_op_value_buf</i></b> should be used to set the data
   as an <code>attr_value_t</code> of data type.
<p>
   If your model is compiled with one of the
   <code>DEVICE_IS_LITTLE_ENDIAN</code>, <code>DEVICE_IS_BIG_ENDIAN</code>
   pre-processor defines, then the
   <b><i><a name="SIM_set_mem_op_value">SIM_set_mem_op_value</a></i></b> function can be used
   as an alias to the <b><i>SIM_set_mem_op_value_le</i></b> and
   <b><i>SIM_set_mem_op_value_be</i></b> versions.
</p><p>
   <b><i>SIM_c_set_mem_op_value_buf</i></b> is only available from C/C++,
   it operates on data in target endian order. There is no alignment
   requirement on the <code>buf</code> parameter.
</p><p>
   <b><i>SIM_set_mem_op_value_be</i></b> takes data in host endian order
   and sets it in big-endian.
</p><p>
   <b><i>SIM_set_mem_op_value_le</i></b> takes data in host endian order
   and sets it in little-endian.
</p><p>
   <b><i>SIM_set_mem_op_value_cpu</i></b> takes data in host endian order
   and sets it in the default endian order for the initiating processor.
   This function can only be used for processor initiated memory operations.
   It is recommended that one of the other functions are used instead.
</p><p>
   The functions that set the memory operation based on a value will
   truncate the representation of that value if the memory operation
   is smaller than 8 bytes.</p></dd>
<dt class="jdocu_descitem">WARNING</dt><dd>
These functions cannot be called from a
   <i>timing-model</i> since the real operation will overwrite the value
   set. They should instead be used from a <i>snoop-device</i>.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Memory</b> Thrown if the size of the operation is illegal.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_mem_op_page_cross">SIM_get_mem_op_page_cross()</a></h3>
<p>

<a name="SIM_get_mem_op_page_cross2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_mem_op_page_cross"></a><b>SIM_get_mem_op_page_cross</b> — detect transaction split</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE unsigned
SIM_get_mem_op_page_cross(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
If a memory transaction was split because it straddled an MMU page,
   return 1 if it is the first part and 2 for the second. If the transaction
   was not split, return zero.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_mem_op_size">SIM_get_mem_op_size()</a></h3>
<p>

<a name="SIM_get_mem_op_size2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_mem_op_size"></a><b>SIM_get_mem_op_size</b> — get transaction size</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE unsigned
SIM_get_mem_op_size(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve the size, in bytes, of a memory transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_mem_op_type">SIM_get_mem_op_type()</a></h3>
<p>

<a name="SIM_get_mem_op_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_mem_op_type"></a><b>SIM_get_mem_op_type</b> — get type of transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE mem_op_type_t
SIM_get_mem_op_type(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the type of the memory transaction.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
    </a><code>generic_transaction_t</code>,
    <b><i>SIM_set_mem_op_type</i></b>
  </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_get_mem_op_type_name">SIM_get_mem_op_type_name()</a></h3>
<p>

<a name="SIM_get_mem_op_type_name2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_get_mem_op_type_name"></a><b>SIM_get_mem_op_type_name</b> — get name of memory operation type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_get_mem_op_type_name(mem_op_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns a string describing <i>type</i> or <code>NULL</code>
   if unknown.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_make_mem_op_write">SIM_make_mem_op_write()</a></h3>
<p>

<a name="SIM_make_mem_op_write2"></a><a name="SIM_make_mem_op_read"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_make_mem_op_write"></a><b>SIM_make_mem_op_write</b><b>, SIM_make_mem_op_read</b> — create a memory transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">generic_transaction_t
SIM_make_mem_op_write(physical_address_t addr, bytes_t data,
                      bool inquiry, conf_object_t *initiator);
</pre><p></p><pre class="jdocu_small">generic_transaction_t
SIM_make_mem_op_read(physical_address_t addr, buffer_t buffer,
                     bool inquiry, conf_object_t *initiator);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create and return a memory transaction for writing <i>data</i> to
     <i>addr</i>, or reading from <i>addr</i> into
     <i>buffer</i>. The number of bytes to transfer is specified by
     <i>data</i> and <i>buffer</i> respectively. The
     <i>initiator</i> is the object issuing the transaction; it may be
     NULL.
<p>
     These functions do not actually perform any memory operation; they just
     construct the <code>generic_transaction_t</code> that can be used in
     other calls.
</p><p>
     The <i>buffer</i> argument must refer to an allocated buffer, and
     <i>data</i> must contain valid data. They must remain valid and
     allocated during the life-time of the returned value.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_ensure_future_visibility">SIM_mem_op_ensure_future_visibility()</a></h3>
<p>

<a name="SIM_mem_op_ensure_future_visibility2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_ensure_future_visibility"></a><b>SIM_mem_op_ensure_future_visibility</b> — request transaction visibility</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_mem_op_ensure_future_visibility(generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Request that future accesses from the same virtual address (using a
   granularity given by the <i>min_cacheline_size</i> processor
   attribute) will be seen by the memory hierarchy. Otherwise, the simulator
   may cache accesses to this address for performance so that they are not seen
   by the memory model.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_is_atomic">SIM_mem_op_is_atomic()</a></h3>
<p>

<a name="SIM_mem_op_is_atomic2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_is_atomic"></a><b>SIM_mem_op_is_atomic</b> — detect transaction atomicity</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_atomic(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return true if the transaction was part of an atomic instruction
   (usually a read followed by a write), false otherwise.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_is_control">SIM_mem_op_is_control()</a></h3>
<p>

<a name="SIM_mem_op_is_control2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_is_control"></a><b>SIM_mem_op_is_control</b> — transaction control predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_control(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is a control transaction (one that does not
  actually transfer any data, such as cache control operations).</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_is_data">SIM_mem_op_is_data()</a></h3>
<p>

<a name="SIM_mem_op_is_data2"></a><a name="SIM_mem_op_is_instruction"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_is_data"></a><b>SIM_mem_op_is_data</b><b>, SIM_mem_op_is_instruction</b> — transaction data/instruction predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_data(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_instruction(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions check whether <code>mem_op</code> is a data or an instruction
  transaction. Currently, the only transactions that are instruction
  transactions are instruction fetches.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_is_from_cache">SIM_mem_op_is_from_cache()</a></h3>
<p>

<a name="SIM_mem_op_is_from_cache2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_is_from_cache"></a><b>SIM_mem_op_is_from_cache</b> — Cache initiated transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_from_cache(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is sent from a cache timing model.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_is_from_cpu">SIM_mem_op_is_from_cpu()</a></h3>
<p>

<a name="SIM_mem_op_is_from_cpu2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_is_from_cpu"></a><b>SIM_mem_op_is_from_cpu</b> — CPU initiated transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_from_cpu(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is sent from a processor.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_is_from_cpu_arch">SIM_mem_op_is_from_cpu_arch()</a></h3>
<p>

<a name="SIM_mem_op_is_from_cpu_arch2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_is_from_cpu_arch"></a><b>SIM_mem_op_is_from_cpu_arch</b> — CPU initiated transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_from_cpu_arch(const generic_transaction_t *NOTNULL mop,
                            ini_type_t arch);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is sent from a processor
  of a specific architecture.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_is_from_device">SIM_mem_op_is_from_device()</a></h3>
<p>

<a name="SIM_mem_op_is_from_device2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_is_from_device"></a><b>SIM_mem_op_is_from_device</b> — Device initiated transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_from_device(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is sent from a device.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_is_prefetch">SIM_mem_op_is_prefetch()</a></h3>
<p>

<a name="SIM_mem_op_is_prefetch2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_is_prefetch"></a><b>SIM_mem_op_is_prefetch</b> — transaction control predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_prefetch(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is prefetch transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_is_read">SIM_mem_op_is_read()</a></h3>
<p>

<a name="SIM_mem_op_is_read2"></a><a name="SIM_mem_op_is_write"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_is_read"></a><b>SIM_mem_op_is_read</b><b>, SIM_mem_op_is_write</b> — transaction read/write predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_read(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_write(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions check whether <code>mem_op</code> is a read or a write
  transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_mem_op_may_stall">SIM_mem_op_may_stall()</a></h3>
<p>

<a name="SIM_mem_op_may_stall2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_mem_op_may_stall"></a><b>SIM_mem_op_may_stall</b> — detect transaction stall possibility</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_may_stall(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
If true, the simulator will allow the transaction to stall execution.
   When false, a memory hierarchy must not attempt any stalling.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_mem_op_exception">SIM_set_mem_op_exception()</a></h3>
<p>

<a name="SIM_set_mem_op_exception2"></a><a name="SIM_get_mem_op_exception"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_mem_op_exception"></a><b>SIM_set_mem_op_exception</b><b>, SIM_get_mem_op_exception</b> — get/set transaction exception</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_exception(generic_transaction_t *NOTNULL mop,
                         exception_type_t exc);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE exception_type_t
SIM_get_mem_op_exception(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or change the transaction exception. If set to a value other
   than <code>Sim_PE_No_Exception</code>, the transaction will be interrupted
   and an exception will be taken.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_mem_op_initiator">SIM_set_mem_op_initiator()</a></h3>
<p>

<a name="SIM_set_mem_op_initiator2"></a><a name="SIM_get_mem_op_initiator"></a><a name="SIM_get_mem_op_ini_type"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_mem_op_initiator"></a><b>SIM_set_mem_op_initiator</b><b>, SIM_get_mem_op_initiator</b><b>, SIM_get_mem_op_ini_type</b> — get/set transaction initiator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_initiator(generic_transaction_t *NOTNULL mop,
                         ini_type_t type, conf_object_t *obj);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE conf_object_t *
SIM_get_mem_op_initiator(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE ini_type_t
SIM_get_mem_op_ini_type(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or change the transaction initiator type and object.
   These two parameters must agree.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_mem_op_inquiry">SIM_set_mem_op_inquiry()</a></h3>
<p>

<a name="SIM_set_mem_op_inquiry2"></a><a name="SIM_get_mem_op_inquiry"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_mem_op_inquiry"></a><b>SIM_set_mem_op_inquiry</b><b>, SIM_get_mem_op_inquiry</b> — get/set transaction inquiry flag</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_inquiry(generic_transaction_t *NOTNULL mop, bool inquiry);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_get_mem_op_inquiry(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or change the transaction inquiry flag. An inquiry read has no
   side-effects. An inquiry write has no other side-effect than changing the
   bytes at the specified address and size.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_mem_op_physical_address">SIM_set_mem_op_physical_address()</a></h3>
<p>

<a name="SIM_set_mem_op_physical_address2"></a><a name="SIM_get_mem_op_physical_address"></a><a name="SIM_set_mem_op_virtual_address"></a><a name="SIM_get_mem_op_virtual_address"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_mem_op_physical_address"></a><b>SIM_set_mem_op_physical_address</b><b>, SIM_get_mem_op_physical_address</b><b>, SIM_set_mem_op_virtual_address</b><b>, SIM_get_mem_op_virtual_address</b> — get or set transaction address</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_physical_address(generic_transaction_t *NOTNULL mop,
                                physical_address_t pa);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE physical_address_t
SIM_get_mem_op_physical_address(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_virtual_address(generic_transaction_t *NOTNULL mop,
                               logical_address_t va);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE logical_address_t
SIM_get_mem_op_virtual_address(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or set the physical or virtual (logical) addresses of a
   memory transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_mem_op_reissue">SIM_set_mem_op_reissue()</a></h3>
<p>

<a name="SIM_set_mem_op_reissue2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_mem_op_reissue"></a><b>SIM_set_mem_op_reissue</b> — request transaction reissue</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_reissue(generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Request that the transaction will be re-issued if a non-zero stall time
   is returned from a memory hierarchy. Otherwise, the memory model
   will not see the transaction again.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_mem_op_type">SIM_set_mem_op_type()</a></h3>
<p>

<a name="SIM_set_mem_op_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_mem_op_type"></a><b>SIM_set_mem_op_type</b> — set type of transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_type(generic_transaction_t *NOTNULL mop, mem_op_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function sets the type of the memory transaction.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
    </a><code>generic_transaction_t</code>,
    <b><i>SIM_get_mem_op_type</i></b>
  </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_set_mem_op_user_data">SIM_set_mem_op_user_data()</a></h3>
<p>

<a name="SIM_set_mem_op_user_data2"></a><a name="SIM_get_mem_op_user_data"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_set_mem_op_user_data"></a><b>SIM_set_mem_op_user_data</b><b>, SIM_get_mem_op_user_data</b> — get/set transaction user data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_user_data(generic_transaction_t *NOTNULL mop,
                         void *data);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE void *
SIM_get_mem_op_user_data(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or change user data associated with the transaction.
   This data is not touched by Simics in any way and its handling and
   interpretation is left to the user. It can be used
   to pass information from a timing model to a snoop device, but the data
   does not survive across a stall.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Device-Translators">Device Translators</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_free_map_target">SIM_free_map_target()</a></h3>
<p>

<a name="SIM_free_map_target2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_free_map_target"></a><b>SIM_free_map_target</b> — free a map target</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_free_map_target(map_target_t *mt);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Releases a map target and all associated resources.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_new_map_target</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_map_target_flush">SIM_map_target_flush()</a></h3>
<p>

<a name="SIM_map_target_flush2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_map_target_flush"></a><b>SIM_map_target_flush</b> — ensure that old translations are not used</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_map_target_flush(const map_target_t *NOTNULL mt,
                     uint64 base, uint64 size, access_t access);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This API function is intended to be used for the implementation
   the <code>translation_flush</code> interface. The documentation for
   the <code>translation_flush</code> interface describes
   how to use this function for the interface implementation.
<p>
   Additionally, this function can be used as a replacement for
   the <b><i>SIM_translation_changed</i></b> function
   to do a more fine-grain invalidation in the case when a previously
   returned translation becomes invalid.
</p><p>
   When a previously returned translation becomes invalid the translator object
   should notify Simics which can have translations cached. To notify Simics
   the translator object can either do the call to
   the <b><i>SIM_translation_changed</i></b> function or, as a potential
   performance optimization, do a more fine-grain invalidation by using
   the <b><i>SIM_map_target_flush</i></b> function.
</p><p>
   The translator object is expected to call
   the <b><i>SIM_map_target_flush</i></b> function for
   all targets of all previously returned translations which became invalid.
   If there are too many translations which are to be invalidated, then,
   performance-wise, it may be better just to do a single call to the
   <b><i>SIM_translation_changed</i></b> function. Also, if,
   during invalidation, any of the calls to the <b><i>SIM_map_target_flush</i></b>
   fails (i.e. the <code>false</code> value is returned by the function) then
   the translator is expected to call
   the <b><i>SIM_translation_changed</i></b> function which always succeeds.
</p><p>
   Please note that there is no need to call
   the <b><i>SIM_map_target_flush</i></b> function for the translations which
   were tagged with the <code>Sim_Translation_Dynamic</code> flag. Either, no
   invalidation is needed for the destinations where nothing is mapped.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_map_target_object">SIM_map_target_object()</a></h3>
<p>

<a name="SIM_map_target_object2"></a><a name="SIM_map_target_port"></a><a name="SIM_map_target_target"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_map_target_object"></a><b>SIM_map_target_object</b><b>, SIM_map_target_port</b><b>, SIM_map_target_target</b> — inspect a map target</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_map_target_object(const map_target_t *NOTNULL mt);
</pre><p></p><pre class="jdocu_small">const char *
SIM_map_target_port(const map_target_t *NOTNULL mt);
</pre><p></p><pre class="jdocu_small">const map_target_t *
SIM_map_target_target(const map_target_t *NOTNULL mt);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Helper functions allowing inspection of the map_target_t objects.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns a Simics object, port, or
   chained target which was used
   for the creation of the <i>mt</i> map target, i.e.,
   the respective argument passed to <b><i>SIM_new_map_target</i></b>
   when the map target was created.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_new_map_target</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_new_map_target">SIM_new_map_target()</a></h3>
<p>

<a name="SIM_new_map_target2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_new_map_target"></a><b>SIM_new_map_target</b> — create a map target</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">map_target_t *
SIM_new_map_target(conf_object_t *NOTNULL obj, const char *port,
                   const map_target_t *chained_target);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create and return a new map target. A map target can be viewed as an opaque
   representation of an object/interface pair which can function
   either as an endpoint for a memory transaction
   or as an address space where a memory transaction can be performed.
<p>
   Map targets are usually used in conjunction with the
   <code>translator</code> interface and can represent anything
   which is mappable in a memory space, e.g., IO banks, RAM, ROM,
   memory spaces, port spaces, bridges, or translators. In order to
   get better performance, we recommend to allocate a map target once
   and reuse it rather than to allocate and delete it every time.
</p><p>
   If the <i>chained_target</i> parameter is null,
   <i>obj</i> is searched for one of the following interfaces:
   <code>ram</code>, <code>rom</code>, <code>io_memory</code>,
   <code>port_space</code>, <code>translator</code>,
   <code>transaction_translator</code>, <code>transaction</code> or
   <code>memory_space</code>. The interfaces are tried in the
   listed order, and the first interface found determines the "type" of the
   map target. For example, if <i>obj</i> implements both the
   <code>io_memory</code> and the <code>translator</code>
   interface, then the created map target will direct memory transactions
   to the <code>io_memory</code> interface.
</p><p>
   If a map target argument is passed in the
   <i>chained_target</i> parameter, then <i>obj</i> must
   implement one of the following interfaces:
   <code>translator</code>, <code>bridge</code>,
   or <code>translate</code>. The chained target contains information
   about a secondary map target used either directly or indirectly
   by the interface. For objects implementing the
   <code>translator</code> interface, the chained
   target is passed as an argument to the <b><i>translate</i></b>
   method. For bridges, the chained target is the target which
   is accessed through the bridge. For objects implementing
   <code>translate</code>, the chained target is used as the target
   of the translation if the <b><i>translate</i></b> method returns null.
</p><p>
   Note: Information about the chained target is encoded in the
   created map target, but no direct references are kept to the argument.
   In other words, ownership is not transferred by this call and
   the caller is responsible for releasing <i>chained_target</i>
   as appropriate.
</p><p>
   If a string is passed in the <i>port</i> parameter, then   
   Simics looks for port interfaces instead of regular interfaces.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns a map target, encoding information
   about the object, the interface, and the chained target, if any.
   NULL is returned if an exception was thrown.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Lookup</b> Thrown if no usable port interface was found.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
   </a><b><i>SIM_free_map_target</i></b>, <code>map_target_t</code>,
   <b><i>SIM_map_target_object</i></b>, <code>translator_interface_t</code>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_translation_changed">SIM_translation_changed()</a></h3>
<p>

<a name="SIM_translation_changed2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_translation_changed"></a><b>SIM_translation_changed</b> — ensure that old translations are not used</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_translation_changed(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Devices implementing the <code>translator</code> interface
   need to call this function whenever a previously returned
   translation becomes invalid; the only exception is
   if all invalid translations were tagged with
   <code>Sim_Translation_Dynamic</code>, in which case this is
   not necessary.
<p>
   Failure to call this function will likely result in Simics
   continuing to use old translations, since those may have been
   cached internally.
   </p><p>
   The object implementing the translator should be passed
   in the <i>obj</i> parameter.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
   </a><code>translator_interface_t</code>
   </dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Time-and-Events">Time and Events</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_cycle_count">SIM_cycle_count()</a></h3>
<p>

<a name="SIM_cycle_count2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_cycle_count"></a><b>SIM_cycle_count</b> — read cycle counter</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">cycles_t  
SIM_cycle_count(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_cycle_count</i></b> returns the current simulated clock cycle
   count at <i>obj</i>.
<p>
   If <i>obj</i> is a cycle counter implementing either the
   <code>cycle_event</code> interface or the <code>cycle</code>
   interface, then the returned count is the number of elapsed
   cycles according to that object. If <i>obj</i> is not a cycle
   counter, then the default clock associated with the object is
   queried for its cycle count.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
     </a><b><i>SIM_object_clock</i></b>
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_cycle_count</i></b> returns the current time in number of
   cycles.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_event_cancel_time">SIM_event_cancel_time()</a></h3>
<p>

<a name="SIM_event_cancel_time2"></a><a name="SIM_event_cancel_step"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_event_cancel_time"></a><b>SIM_event_cancel_time</b><b>, SIM_event_cancel_step</b> — cancel an event before expiration</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_event_cancel_time(conf_object_t *NOTNULL clock,
                      event_class_t *NOTNULL evclass,
                      conf_object_t *NOTNULL obj,
                      int (*pred)(lang_void *data, lang_void *match_data),
                      lang_void *match_data);
</pre><p></p><pre class="jdocu_small">void
SIM_event_cancel_step(conf_object_t *NOTNULL clock,
                      event_class_t *NOTNULL evclass,
                      conf_object_t *NOTNULL obj,
                      int (*pred)(lang_void *data, lang_void *match_data),
                      lang_void *match_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
All unexpired <i>evclass</i> events posted for <i>obj</i>
   on <i>clock</i> for which <i>pred</i> returns nonzero will
   be cancelled and their destructor methods (if any) called.
   <i>pred</i> will be called with the data associated with the event
   and the supplied <i>match_data</i>. If <i>pred</i> is null
   (None in Python), all <i>evclass</i> events for <i>obj</i>
   on <i>clock</i> will be cancelled.
<p>
   There are separate calls for events posted at a point in time (cycle or
   seconds) and on a specific step.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_InterfaceNotFound</b> Thrown by <b><i>SIM_event_cancel_step</i></b>
   if the <i>clock</i> object doesn't implement the <code>step</code>
   interface.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
     </a><b><i>SIM_register_event</i></b>, <b><i>SIM_event_post_time</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_event_find_next_cycle">SIM_event_find_next_cycle()</a></h3>
<p>

<a name="SIM_event_find_next_cycle2"></a><a name="SIM_event_find_next_time"></a><a name="SIM_event_find_next_step"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_event_find_next_cycle"></a><b>SIM_event_find_next_cycle</b><b>, SIM_event_find_next_time</b><b>, SIM_event_find_next_step</b> — find event expiration time</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">cycles_t
SIM_event_find_next_cycle(conf_object_t *NOTNULL clock,
                          event_class_t *NOTNULL evclass,
                          conf_object_t *NOTNULL obj,
                          int (*pred)(lang_void *data, lang_void *match_data),
                          lang_void *match_data);
</pre><p></p><pre class="jdocu_small">double
SIM_event_find_next_time(conf_object_t *NOTNULL clock,
                         event_class_t *NOTNULL evclass,
                         conf_object_t *NOTNULL obj,
                         int (*pred)(lang_void *data, lang_void *match_data),
                         lang_void *match_data);
</pre><p></p><pre class="jdocu_small">pc_step_t
SIM_event_find_next_step(conf_object_t *NOTNULL clock,
                         event_class_t *NOTNULL evclass,
                         conf_object_t *NOTNULL obj,
                         int (*pred)(lang_void *data, lang_void *match_data),
                         lang_void *match_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the number of cycles/seconds/steps to the first event of
   <i>evclass</i> of <i>obj</i> posted on <i>clock</i>
   for which <i>pred</i> is true, or −1 if no event
   matched. <i>pred</i> will be called with the data associated with
   the event and the supplied <i>match_data</i>. If <i>pred</i>
   is null (None in Python), the first <i>evclass</i> event for
   <i>obj</i> on <i>clock</i> will be used.
<p>
   There are separate calls of events posted at a point in time (cycle
   or seconds) and on a specific step. Note that the return value of
   <b><i>SIM_event_find_next_cycle</i></b> is only a preliminary
   estimate; the number of remaining cycles will change if the
   clock's frequency changes dynamically. To handle dynamically
   changing clock frequencies correctly, subscribe to the frequency
   changes via the clock's <code>simple_dispatcher</code> interface.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_InterfaceNotFound</b> Thrown by
   <b><i>SIM_event_find_next_step</i></b> if the <i>clock</i> object
   doesn't implement the <code>step</code> interface: Minus one is returned
   in such a case.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
     </a><b><i>SIM_register_event</i></b>, <b><i>SIM_event_post_time</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_event_post_time">SIM_event_post_time()</a></h3>
<p>

<a name="SIM_event_post_time2"></a><a name="SIM_event_post_cycle"></a><a name="SIM_event_post_step"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_event_post_time"></a><b>SIM_event_post_time</b><b>, SIM_event_post_cycle</b><b>, SIM_event_post_step</b> — post an event</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void 
SIM_event_post_time(conf_object_t *NOTNULL clock,
                    event_class_t *NOTNULL evclass,
                    conf_object_t *NOTNULL obj,
                    double seconds,
                    lang_void *user_data);
</pre><p></p><pre class="jdocu_small">void
SIM_event_post_cycle(conf_object_t *NOTNULL clock,
                     event_class_t *NOTNULL evclass,
                     conf_object_t *NOTNULL obj,
                     cycles_t cycles,
                     lang_void *user_data);
</pre><p></p><pre class="jdocu_small">void
SIM_event_post_step(conf_object_t *NOTNULL clock,
                    event_class_t *NOTNULL evclass,
                    conf_object_t *NOTNULL obj,
                    pc_step_t steps,
                    lang_void *user_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An event of <i>evclass</i> for object <i>obj</i> is posted
   on <i>clock</i> to occur at a given point in the future. The
   <i>user_data</i> will be associated with the event.
<p>
   The <i>clock</i> is the object that should be used for keeping track
   of time for the event. It can be a processor or an instance of the
   <b>clock</b> class.
</p><p>
   If a configuration class was specified when <i>evclass</i> was
   registered, then <i>obj</i> must be an instance of that class.
</p><p>
   The expiration point can be specified in seconds, cycles or steps by using
   the appropriate call, and these values are relative to the current
   state. Events that need to run synchronized
   (<code>Sim_EC_Machine_Sync</code>) can only be posted in seconds or
   cycles, not steps, since synchronization can only be perform in virtual
   time.
</p><p>
   </p><div class="note">
<b>Note:</b>
Events posted with <b><i>SIM_event_post_cycle</i></b> are posted at
   a certain point in time based on the clock's current frequency, not
   at a certain clock cycle. The difference is significant if the
   frequency of the <i>clock</i> object can change dynamically.
   </div></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<dl><dt id="dt:simexc_interfacenotfound"><b>SimExc_InterfaceNotFound</b></dt><dd>Thrown by
   <b><i>SIM_event_post_step</i></b> if the <i>clock</i> object doesn't
   implement the <code>step</code> interface.</dd><dt id="dt:simexc_general"><b>SimExc_General</b></dt><dd>Thrown if the number of steps or time is
   negative or too far ahead, and, for <code>Sim_EC_Machine_Sync</code>
   events, if the event is posted less than a time quantum in the future.</dd></dl><p></p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
     </a><b><i>SIM_register_event</i></b>, <b><i>SIM_event_cancel_time</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_event">SIM_register_event()</a></h3>
<p>

<a name="SIM_register_event2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_event"></a><b>SIM_register_event</b> — register an event</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">event_class_t *
SIM_register_event(
               const char *NOTNULL name,
               conf_class_t *cl,
               event_class_flag_t flags,
               void (*NOTNULL callback)(conf_object_t *obj, lang_void *data),
               void (*destroy)(conf_object_t *obj, lang_void *data),
               attr_value_t (*get_value)(conf_object_t *obj, lang_void *data),
               lang_void *(*set_value)(conf_object_t *obj, attr_value_t value),
               char *(*describe)(conf_object_t *obj, lang_void *data));
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Registers events identified by <i>name</i> and to be posted for
   objects of class <i>cl</i>, and returns the event class to be used
   in other calls. The supplied methods are:
<p>
   </p><dl><dt id="dt:callback"><b><i>callback</i></b></dt><dd>Called when the event expires.</dd><dt id="dt:destroy"><b><i>destroy</i></b></dt><dd>Called when the event is removed from the queue without being called.
       The method is not allowed to use any event API calls; it is mainly
       intended for freeing event data. May be null.</dd><dt id="dt:get_value"><b><i>get_value</i></b></dt><dd>Called to convert the event data into a value that can be saved in a
       configuration. May be null when the event carries no data of
       interest.</dd><dt id="dt:set_value"><b><i>set_value</i></b></dt><dd>Called to convert a configuration value into event data. 
       May be null when the event carries no data of interest.</dd><dt id="dt:describe"><b><i>describe</i></b></dt><dd>Called to generate a human-readable description of the event to be used 
       in the <b>print-event-queue</b> command. If written in C, must
       return an allocated string (using <code>MM_MALLOC</code> or
       <code>MM_STRDUP</code>).
       May be null, in which case the <i>name</i> is used.</dd></dl><p>Null function pointers correspond to the value None when invoked from
   Python.
</p><p>
   The <i>flags</i> is typically either zero or Sim_EC_Notsaved, where
   Sim_EC_Notsaved indicates that the event should not be saved as part of the
   configuration.  In that case, <i>get_value</i> and
   <i>set_value</i> must both be null, and <i>cl</i> may then
   also be null. The other flag bits defined in the event_class_flag_t are
   reserved for internal use in the Simics platform and some tightly coupled
   modules. See the event queue sample code for details of their use.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_event_post_time</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_run_unrestricted">SIM_run_unrestricted()</a></h3>
<p>

<a name="SIM_run_unrestricted2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_run_unrestricted"></a><b>SIM_run_unrestricted</b> — run callback after current instruction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_run_unrestricted(conf_object_t *NOTNULL obj,
                     void (*NOTNULL func)(conf_object_t *obj,
                                          lang_void *param),
                     lang_void *user_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>func</i> functions will be called immediately, if Simics is not
   currently running an instruction, or as soon as the current instruction has
   completed.
<p>
   Note that with the introduction of Multicore Accelerator, if an instruction
   is running when calling <b><i>SIM_run_unrestricted</i></b>, other simulation
   threads may continue for a while until they stop and the callback is
   serviced. This means that an object using <b><i>SIM_run_unrestricted</i></b>
   may receive calls through for example the <code>io_memory</code> interface
   after returning from the scope where <b><i>SIM_run_unrestricted</i></b> is
   called but before the <i>func</i> callback function is called. For more
   information on considerations for Multicore Accelerator, see the
   <em>Simics Model Builder User's Guide</em>.
</p><p>
   If several functions are registered this way before any of them has had a
   chance to run, the functions will be run in their order of registration.
</p><p>
   This call is mainly useful for actions that for various reasons can not be
   done while an instruction is being emulated.
</p><p>
   The <i>obj</i> is an object that has a clock (as defined by
   <b><i>SIM_object_clock</i></b>). This object and <i>user_data</i> are
   passed to the callback function.
</p><p>
   Since the callback is run in Cell Context, simulation threads
   for other cells may be running when the callback is executed. Consequently,
   only objects in the same cell as <i>obj</i> may be accessed from
   the callback.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_run_alone</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts including Threaded Context (call);
   Cell Context (callback)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_step_count">SIM_step_count()</a></h3>
<p>

<a name="SIM_step_count2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_step_count"></a><b>SIM_step_count</b> — get step count</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">pc_step_t
SIM_step_count(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the number of steps executed by the processor <i>obj</i>.
   A step is a completed instruction, an instruction causing a synchronous
   exception, or an asynchronous exception (interrupt).</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_InterfaceNotFound</b> Thrown if the <i>obj</i> object
   doesn't implement the <code>step</code> interface. Minus one is returned
   in such a case.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_time">SIM_time()</a></h3>
<p>

<a name="SIM_time2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_time"></a><b>SIM_time</b> — get current simulated time</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">double
SIM_time(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_time</i></b> returns the current time at <i>obj</i>.
<p>
   The returned time relates to how long the simulation has been
   running, and is usually not very useful in itself, but it can be
   used to compare with other times. The time on a specific processor
   is guaranteed to increase when simulation progresses, even if the
   clock frequency is changed. When adding a processor, it is assigned
   a current time to be synchronized with other processors in the
   simulation, or the time 0.0 if it is the first processor.
</p><p>
   </p><div class="note">
<b>Note:</b>
The precision of the returned value degrades significantly
   with simulated time due to its representation as a double.
   When absolute timestamps are needed for the actual simulation,
   it is recommended that the <b><i>SIM_cycle_count</i></b> function
   is used instead on the picosecond clock.
   </div><div class="note">
<b>Note:</b>
Using <b><i>SIM_time</i></b> on the picosecond clock will currently
   give the same result as <b><i>SIM_time</i></b> on the default clock.
   That is, the precision of this API function is limited
   by the frequency of the default clock.
   </div></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
     </a><b><i>SIM_picosecond_clock</i></b>
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_time</i></b> returns the current time in seconds as
   a floating point value.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" name="Version-and-Copyrights">Version and Copyrights</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" name="SIM_register_copyright">SIM_register_copyright()</a></h3>
<p>

<a name="SIM_register_copyright2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_register_copyright"></a><b>SIM_register_copyright</b> — register copyright information</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_copyright(const char *NOTNULL str);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This registers specific copyright information related to an extension
   module or similar component of Simics. The Simics front-end command
   "copyright" will list, in addition to Simics copyright notices, any
   registered notices from libraries or plug-ins that have added a string
   using this function.
<p>
   The string should contain only standard ASCII characters, be pre-formatted
   for at most 80-character width terminal, be non-indented, and have
   no spurious new-line characters before or after the last line (except
   for the new-line that marks the end of the last line).
</p><p>
   The string will not be copied so needs to be either static or
   a copy generated by the callee (preferably static).</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" name="SIM_version">SIM_version()</a></h3>
<p>

<a name="SIM_version2"></a><a name="SIM_version_base"></a><a name="SIM_version_major"></a><a name="SIM_license"></a><a name="SIM_license_file"></a><a name="SIM_copyright"></a><a name="SIM_vmxmon_version"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_SIM_version"></a><b>SIM_version</b><b>, SIM_version_base</b><b>, SIM_version_major</b><b>, SIM_license</b><b>, SIM_license_file</b><b>, SIM_copyright</b><b>, SIM_vmxmon_version</b> — get Simics version and license/copyright information</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_version(void);
</pre><p></p><pre class="jdocu_small">const char *
SIM_version_base(void);
</pre><p></p><pre class="jdocu_small">const char *
SIM_version_major(void);
</pre><p></p><pre class="jdocu_small">void
SIM_license(void);
</pre><p></p><pre class="jdocu_small">char *
SIM_license_file(const char *format);
</pre><p></p><pre class="jdocu_small">char *
SIM_copyright(void);
</pre><p></p><pre class="jdocu_small">char *
SIM_vmxmon_version(void);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<dl><dt id="dt:sim_version"><b><b><i>SIM_version</i></b></b></dt><dd>returns the version of all installed
   Simics products.</dd><dt id="dt:sim_version_base"><b><b><i>SIM_version_base</i></b></b></dt><dd>returns the version of the Simics
   base package only.</dd><dt id="dt:sim_version_major"><b><b><i>SIM_version_major</i></b></b></dt><dd>returns the current major
   version of Simics.</dd><dt id="dt:sim_vmxmon_version"><b><b><i>SIM_vmxmon_version</i></b></b></dt><dd>returns the version of the VMP
   kernel module loaded on the host machine. <code>NULL</code> is returned
   if the module is not loaded.</dd><dt id="dt:sim_license_file"><b><b><i>SIM_license_file</i></b></b></dt><dd>returns the filename of the
   currently applying License Agreement (SLA/EULA), if any is found. The
   <i>format</i> parameter can be either an empty string (text version)
   or "rtf" (RTF version).</dd><dt id="dt:sim_copyright"><b><b><i>SIM_copyright</i></b></b></dt><dd>returns the copyright notice
   for Simics.</dd><dt id="dt:sim_license"><b><b><i>SIM_license</i></b></b></dt><dd>doesn't return anything but
   prints out a short text describing licensing conditions.</dd></dl><p><b><i>SIM_version</i></b>, <b><i>SIM_version_base</i></b>,
   <b><i>SIM_version_major</i></b> return a string
   owned by Simics. These strings must not be deallocated or modified by the
   caller.
</p><p>
   <b><i>SIM_vmxmon_version</i></b>, <b><i>SIM_license_file</i></b>,
   and <b><i>SIM_copyright</i></b> return
   a newly allocated string which is owned by the caller. This means that
   when the function is called from C its return value should be later freed
   with the use of the MM_FREE macro.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_register_copyright</i></b></dd>
</dl><p>

    </p><h2 class="jdocu"><a name="frags_t">3.3.1 frags_t</a></h2>
<p>
    
</p><p>
    The <code>frags_t</code> data type is part of the Simics API. It is used to
    manipulate and modify network packets inside models efficiently. It is
    meant to replace DBuffer in network device models wherever appropriate.
    See the <em>Model Builder User's Guide</em> for an introduction to
    programming with <code>frags_t</code>.
</p><p>
    </p><h3 class="jdocu"><a class="not-numbered" name="Function-List">Function List</a></h3>
<p></p><h4 class="jdocu"><a class="not-numbered" name="frags_add">frags_add()</a></h4>
<p>

<a name="frags_add2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_add"></a><b>frags_add</b> — add data to a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
frags_add(frags_t *buf, const void *data, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Append the new data <i>data</i> of size <i>len</i> to
     <i>buf</i>.
     A <code>frags_t</code> can hold up to 8 data fragments.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 new_data[2] = { 7, 8 };
frags_add(&amp;foo, new_data, sizeof(new_data));
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_init_add</i></b>, <b><i>frags_init_add_from_frags</i></b>, 
       <b><i>frags_add_from_frags</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_add_from_frags">frags_add_from_frags()</a></h4>
<p>

<a name="frags_add_from_frags2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_add_from_frags"></a><b>frags_add_from_frags</b> — append an existing <code>frags_t</code> to another</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
frags_add_from_frags(frags_t *dst, const frags_t *src,
                     size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Append <i>len</i> bytes of the data at offset
     <i>offset</i> in <i>src</i> to <i>dst</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">frags_add_from_frags(&amp;foo, &amp;bar, 4, frags_len(&amp;bar) - 4);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_init_add</i></b>, <b><i>frags_add</i></b>,
       <b><i>frags_init_add_from_frags</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_extract">frags_extract()</a></h4>
<p>

<a name="frags_extract2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_extract"></a><b>frags_extract</b> — extract the contents of a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void frags_extract(const frags_t *buf, void *vdst);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Copy the whole contents of <i>buf</i> to <i>vdst</i>. The
     destination buffer <i>vdst</i> should be large enough to contain
     all data in <i>buf</i>.
<p>
     This function is completely equivalent to <b><i>frags_extract_slice()</i></b>
     with an <i>offset</i> and a <i>length</i> covering the
     whole contents of the <code>frags_t</code>, and is provided for
     convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 all_data[frags_len(&amp;foo)];
frags_extract(&amp;foo, all_data);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_extract_8</i></b>, <b><i>frags_extract_slice</i></b>,
       <b><i>frags_extract_alloc</i></b>, <b><i>frags_extract_slice_alloc</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_extract_8">frags_extract_8()</a></h4>
<p>

<a name="frags_extract_82"></a><a name="frags_extract_be16"></a><a name="frags_extract_le16"></a><a name="frags_extract_be32"></a><a name="frags_extract_le32"></a><a name="frags_extract_be64"></a><a name="frags_extract_le64"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_extract_8"></a><b>frags_extract_8</b><b>, frags_extract_be16</b><b>, frags_extract_le16</b><b>, frags_extract_be32</b><b>, frags_extract_le32</b><b>, frags_extract_be64</b><b>, frags_extract_le64</b> — extract a value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint8 frags_extract_8(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint16 frags_extract_be16(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint16 frags_extract_le16(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint32 frags_extract_be32(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint32 frags_extract_le32(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint64 frags_extract_be64(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint64 frags_extract_le64(const frags_t *buf, size_t offset);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Extract a 8, 16, 32 or 64 bits value in either big-endian (<b><i>_be</i></b>)
     or little-endian (<b><i>_le</i></b>) format from the contents of the
     <code>frags_t</code> <i>buf</i> at offset <i>offset</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Extracted value</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8  val8  = frags_extract_8(&amp;frame, 1);
uint16 val16 = frags_extract_be16(&amp;frame, 2);
uint32 val32 = frags_extract_le32(&amp;frame, 4);
uint32 val64 = frags_extract_be64(&amp;frame, 8);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_extract</i></b>, <b><i>frags_extract_slice</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_extract_alloc">frags_extract_alloc()</a></h4>
<p>

<a name="frags_extract_alloc2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_extract_alloc"></a><b>frags_extract_alloc</b> — return a copy of the contents of a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void *frags_extract_alloc(const frags_t *buf);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an allocated copy of the contents of <i>buf</i>. The buffer
     returned is allocated with <b><i>MM_MALLOC()</i></b>, and its ownership is
     passed to the caller, which should free it when appropriate.
<p>
     This function is equivalent to allocating a buffer of the correct size
     with <b><i>MM_MALLOC()</i></b> followed by a call to
     <b><i>frags_extract()</i></b>, and is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A newly allocated copy of the contents</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 *all = frags_extract_alloc(&amp;foo);
/* ... */
MM_FREE(all);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_extract</i></b>, <b><i>frags_extract_slice</i></b>,
       <b><i>frags_extract_slice_alloc</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_extract_slice">frags_extract_slice()</a></h4>
<p>

<a name="frags_extract_slice2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_extract_slice"></a><b>frags_extract_slice</b> — extract a slice of a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void frags_extract_slice(const frags_t *buf, void *vdst, size_t offset, 
                         size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Copy a slice of size <i>len</i>, starting at offset
     <i>offset</i>, of the contents of <i>buf</i>, to
     <i>vdst</i>. The destination buffer <i>vdst</i> should be
     able to contain at least <i>len</i> bytes.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 some_data[16];
frags_extract_slice(&amp;foo, some_data, 4, 16);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_extract_8</i></b>, <b><i>frags_extract</i></b>,
       <b><i>frags_extract_alloc</i></b>, <b><i>frags_extract_slice_alloc</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_extract_slice_alloc">frags_extract_slice_alloc()</a></h4>
<p>

<a name="frags_extract_slice_alloc2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_extract_slice_alloc"></a><b>frags_extract_slice_alloc</b> — return a partial copy of the contents of a
     <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void *frags_extract_slice_alloc(const frags_t *buf, size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an allocated copy of a slice of size <i>len</i>, starting
     at offset <i>offset</i>, of the contents of
     <i>buf</i>. The return value is allocated with
     <b><i>MM_MALLOC()</i></b>, and its ownership is passed to the caller, which
     should free it when appropriate.
<p>
     This function is equivalent to allocating a buffer of the correct size
     with <b><i>MM_MALLOC()</i></b> followed by a call to
     <b><i>frags_extract_slice()</i></b>, and is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A newly allocated, partial copy of the data</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 *slice = frags_extract_slice_alloc(&amp;foo, 4, 16);
/* ... */
MM_FREE(slice);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_extract</i></b>, <b><i>frags_extract_slice</i></b>,
       <b><i>frags_extract_alloc</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_init">frags_init()</a></h4>
<p>

<a name="frags_init2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_init"></a><b>frags_init</b> — initialize a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void frags_init(frags_t *buf);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize the <code>frags_t</code> <i>buf</i>. An alternative is
     to use the <code>FRAGS_INIT</code> constant value.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">/* Initialization with frags_init() */
frags_t bar;
frags_init(&amp;bar);
</pre><p>

       </p><pre class="jdocu_small">/* Initialization with FRAGS_INIT */
frags_t foo = FRAGS_INIT;
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>frags_init_add</i></b></dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_init_add">frags_init_add()</a></h4>
<p>

<a name="frags_init_add2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_init_add"></a><b>frags_init_add</b> — initialize a <code>frags_t</code> with an initial value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
frags_init_add(frags_t *buf, const void *data, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize the <code>frags_t</code> <i>buf</i> and set it to
     represent the initial data <i>data</i> of size
     <i>len</i>. 
<p>
     This function is exactly equivalent to using <b><i>frags_init()</i></b>,
     followed by <b><i>frags_add()</i></b>, and is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">frags_t baz;
uint8 data[5] = { 0, 1, 2, 3, 4 };
frags_init_add(&amp;baz, data, sizeof(data));
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_init</i></b>, <b><i>frags_add</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_init_add_from_frags">frags_init_add_from_frags()</a></h4>
<p>

<a name="frags_init_add_from_frags2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_init_add_from_frags"></a><b>frags_init_add_from_frags</b> — initialize a <code>frags_t</code> from another</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
frags_init_add_from_frags(frags_t *dst, const frags_t *src,
                          size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize <i>dst</i> and set its initial value to the data of
     size <i>len</i> starting at offset <i>offset</i> in
     <i>src</i>.
<p>
     This function is exactly equivalent to using <b><i>frags_init()</i></b>,
     followed by <b><i>frags_add_from_frags()</i></b>, and is provided for
     convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">frags_t bat;
ASSERT(frags_len(&amp;foo) &gt; 16);
frags_init_add_from_frags(&amp;bat, &amp;foo, 16, frags_len(&amp;foo) - 16);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_init_add</i></b>, <b><i>frags_add</i></b>,
       <b><i>frags_add_from_frags</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_it">frags_it()</a></h4>
<p>

<a name="frags_it2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_it"></a><b>frags_it</b> — return an iterator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE frags_it_t
frags_it(const frags_t *buf, size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an iterator on the fragments that compose the data in
     <i>buf</i>, starting from offset <i>offset</i> and up to a
     length of <i>len</i>. To iterate on all the data in
     <i>buf</i>, <i>offset</i> should be set to 0 and
     <i>len</i> to the value returned by <b><i>frags_len()</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
An iterator on the fragments covering the desired
     data range</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_it_end</i></b>, <b><i>frags_it_next</i></b>,
       <b><i>frags_it_len</i></b>, <b><i>frags_it_data</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_it_data">frags_it_data()</a></h4>
<p>

<a name="frags_it_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_it_data"></a><b>frags_it_data</b> — return the data of the current fragment</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE const uint8 *
frags_it_data(frags_it_t it);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a pointer to the data of the current fragment pointed by the
     iterator <i>it</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The data of the current fragment</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_it</i></b>, <b><i>frags_it_end</i></b>,
       <b><i>frags_it_next</i></b>, <b><i>frags_it_len</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_it_end">frags_it_end()</a></h4>
<p>

<a name="frags_it_end2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_it_end"></a><b>frags_it_end</b> — return whether an iterator is finished</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool 
frags_it_end(frags_it_t it);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return <code>true</code> when the iterator <i>it</i> does not
     have any next fragment to return at the next call of
     <b><i>frags_it_next()</i></b>, and <code>false</code> otherwise.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<code>true</code> if the iterator is finished,
     <code>false</code> otherwise.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_it</i></b>, <b><i>frags_it_next</i></b>,
       <b><i>frags_it_len</i></b>, <b><i>frags_it_data</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_it_len">frags_it_len()</a></h4>
<p>

<a name="frags_it_len2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_it_len"></a><b>frags_it_len</b> — return the length of the current fragment</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE size_t
frags_it_len(frags_it_t it);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the length of the current fragment pointed by the iterator
     <i>it</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The length of the current fragment</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_it</i></b>, <b><i>frags_it_end</i></b>,
       <b><i>frags_it_next</i></b>, <b><i>frags_it_data</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_it_next">frags_it_next()</a></h4>
<p>

<a name="frags_it_next2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_it_next"></a><b>frags_it_next</b> — return the next fragment's iterator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE frags_it_t
frags_it_next(frags_it_t it);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an iterator pointing at the next data fragment. This function
     should only be called if <b><i>frags_end(it)</i></b> returns
     <code>false</code>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
An iterator on the next fragment</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_it</i></b>, <b><i>frags_it_end</i></b>,
       <b><i>frags_it_len</i></b>, <b><i>frags_it_data</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_len">frags_len()</a></h4>
<p>

<a name="frags_len2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_len"></a><b>frags_len</b> — return the total data length</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE size_t frags_len(const frags_t *buf);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the total length of the data represented by <i>buf</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The total data length</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned len = frags_len(&amp;foo);
</pre><p>

     </p></dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_prefix">frags_prefix()</a></h4>
<p>

<a name="frags_prefix2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_prefix"></a><b>frags_prefix</b> — prefix a <code>frags_t</code> with a header</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE frags_t
frags_prefix(const void *header, size_t header_len, const frags_t *body);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create a <code>frags_t</code> composed of the header <i>header</i>
     of size <i>header_len</i>, followed by the contents of the
     <code>frags_t</code> <i>body</i>.
<p>
     This function is equivalent to a sequence of <b><i>frags_init()</i></b>,
     <b><i>frags_add()</i></b>, <b><i>frags_add_from_frags()</i></b> to build a new
     fragment containing the prefix. It is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A new <code>frags_t</code> including
     <i>header</i> and <i>body</i></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 eth_header[14] = { 0 };
frags_t packet = frags_prefix(eth_header, sizeof(eth_header), &amp;foo);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_suffix</i></b>, <b><i>frags_add_from_frags</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="frags_suffix">frags_suffix()</a></h4>
<p>

<a name="frags_suffix2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_frags_suffix"></a><b>frags_suffix</b> — append a suffix to a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE frags_t
frags_suffix(const frags_t *body, void *header, size_t header_len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create a <code>frags_t</code> composed of the contents of the
     <code>frags_t</code> <i>body</i>, followed by the data
     <i>header</i> of size <i>header_len</i>.
<p>
     This function is equivalent to a sequence of <b><i>frags_init()</i></b>,
     <b><i>frags_add_from_frags()</i></b>, <b><i>frags_add()</i></b> to build a new
     fragment containing the suffix. It is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A new <code>frags_t</code> including
     <i>body</i> and <i>header</i></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 eth_checksum[4] = { 0 };
frags_t frame = frags_suffix(&amp;foo, eth_checksum, sizeof(eth_checksum));
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="device-api-data-types.html#__jdocu_seealso_4">
       </a><b><i>frags_prefix</i></b>, <b><i>frags_add_from_frags</i></b>
     </dd>
</dl><p>


    </p><h2 class="jdocu"><a name="Dynamic-Memory-Management">3.3.2 Dynamic Memory Management</a></h2>
<p>
</p><p>
   
</p><p>
   These are routines for manual dynamic memory allocation providing
   some memory leak detection. They replace the standard C <b><i>malloc</i></b>
   facility in Simics APIs.
</p><p>
   Example: to allocate an array of 13 elements of type <code>device_t</code>,
   use
</p><p>
</p><pre class="jdocu_small">    device_t *d = MM_MALLOC(13, device_t);
</pre><p>
</p><p>
   It must be possible to get a pointer to the type by appending an asterisk to
   the type name; so <code>struct foo *</code> is acceptable, but
   <code>int (*)(void)</code> is not. Use a typedef in these cases.
</p><p>
   It is not possible to mix these calls with the <b><i>malloc</i></b>
   facility for the same allocations.
</p><p>
   </p><h3 class="jdocu"><a class="not-numbered" name="Macro-List">Macro List</a></h3>
<p></p><h4 class="jdocu"><a class="not-numbered" name="MM_FREE">MM_FREE()</a></h4>
<p>

<a name="MM_FREE2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_MM_FREE"></a><b>MM_FREE</b> — free allocation</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">MM_FREE(p);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_FREE</i></b> frees an allocation previously made with
  <b><i>MM_MALLOC</i></b>, <b><i>MM_MALLOC_SZ</i></b>, <b><i>MM_ZALLOC</i></b>,
  <b><i>MM_ZALLOC_SZ</i></b>, <b><i>MM_REALLOC</i></b>, <b><i>MM_REALLOC_SZ</i></b>
  or <b><i>MM_STRDUP</i></b>.
<p>
  A null pointer argument is legal, in which case nothing happens.</p></dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="MM_MALLOC">MM_MALLOC()</a></h4>
<p>

<a name="MM_MALLOC2"></a><a name="MM_MALLOC_SZ"></a><a name="MM_ZALLOC"></a><a name="MM_ZALLOC_SZ"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_MM_MALLOC"></a><b>MM_MALLOC</b><b>, MM_MALLOC_SZ</b><b>, MM_ZALLOC</b><b>, MM_ZALLOC_SZ</b> — allocate memory</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">MM_MALLOC(nelems, type);
</pre><p></p><pre class="jdocu_small">MM_MALLOC_SZ(size, type);
</pre><p></p><pre class="jdocu_small">MM_ZALLOC(nelems, type);
</pre><p></p><pre class="jdocu_small">MM_ZALLOC_SZ(size, type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_MALLOC</i></b> allocates <i>nelems</i> objects of type
  <i>type</i>. <b><i>MM_MALLOC_SZ</i></b> specifies the total allocation size
  in bytes.
<p>
  <b><i>MM_ZALLOC</i></b> and <b><i>MM_ZALLOC_SZ</i></b> do the same thing as
  <b><i>MM_MALLOC</i></b> and <b><i>MM_ZALLOC</i></b> respectively but in addition
  fill the allocated memory with null bytes.
</p><p>
  If <i>nelems</i> or <i>size</i> are zero, either a null pointer
  or a pointer to a zero-sized allocation is returned.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the allocated object(s).</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)</dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="MM_REALLOC">MM_REALLOC()</a></h4>
<p>

<a name="MM_REALLOC2"></a><a name="MM_REALLOC_SZ"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_MM_REALLOC"></a><b>MM_REALLOC</b><b>, MM_REALLOC_SZ</b> — reallocate memory</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">MM_REALLOC(p, nelems, type);
</pre><p></p><pre class="jdocu_small">MM_REALLOC_SZ(p, size, type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_REALLOC</i></b> changes the size of an allocated memory block to
  <i>nelems</i> elements. <b><i>MM_REALLOC_SZ</i></b> specifies the new size
  in bytes.
<p>
  The allocation must originally have been made by a call to
  <b><i>MM_MALLOC</i></b>, <b><i>MM_MALLOC_SZ</i></b>, <b><i>MM_ZALLOC</i></b>,
  <b><i>MM_ZALLOC_SZ</i></b>, <b><i>MM_REALLOC</i></b>, <b><i>MM_REALLOC_SZ</i></b>
  or <b><i>MM_STRDUP</i></b>.
</p><p>
  If the passed pointer is null, then these macros are equivalent to an
  allocation of the desired amount. If <i>nelems</i> or <i>size</i> is
  zero, either a null pointer or a pointer to a zero-sized allocation is
  returned, and the original allocation is freed.
</p><p>
  The allocation must be freed using <b><i>MM_FREE</i></b>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the reallocated object(s).
  </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)</dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" name="MM_STRDUP">MM_STRDUP()</a></h4>
<p>

<a name="MM_STRDUP2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="__jdocu_seealso_MM_STRDUP"></a><b>MM_STRDUP</b> — duplicate a string</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">MM_STRDUP(str);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Allocates and initializes a copy of the null-terminated string
  <i>str</i>. The allocation must be freed with <b><i>MM_FREE</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the newly allocated
  string.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)</dd>
</dl><p>

    
</p>
<div class="chain">
<a href="device-api-data-types.html">3.2 Device API Data Types</a>
<a href="obsolete-device-api-types-and-functions.html">3.4 Obsolete Device API Types and Functions</a>
</div>