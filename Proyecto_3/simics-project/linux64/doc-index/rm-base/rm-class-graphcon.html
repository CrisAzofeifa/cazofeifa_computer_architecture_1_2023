<!doctype html>
<head>
<meta charset="utf-8">
<title>graphcon</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="rm-class-gml_link_impl.html">gml_link_impl</a>
<a href="rm-class-gui.html">gui</a>
</div>
<div class="path">
<a href="index.html">Simics Reference Manual</a>
&nbsp;/&nbsp;
<a href="rm-classes.html">5 Classes</a>
&nbsp;/&nbsp;</div>
<h1 id="graphcon"><a href="#graphcon">graphcon</a></h1>
<section class="doc-item not-numbered not-in-toc">
<h3 id="description">
<a href="#description">Description</a>
</h3>
The <tt>graphcon</tt> class implements a graphical console, representing a computer screen. Several consoles may be present at any time. It also supports input of keyboard and mouse events. The objects of the <tt>graphcon</tt> class should be connected to a graphics card device and a keyboard/mouse device.
<h3 id="interfaces-implemented">
<a href="#interfaces-implemented">Interfaces Implemented</a>
</h3>conf_object, log_object, keyboard_console, gfx_console_backend, abs_pointer_activate, recorded, con_input_code, checkpoint, gfx_con, gfx_console, screenshot, extended_serial, gfx_break, vga_text_update, vnc_server, vnc_server_v2, external_connection_events, break_strings, break_strings_v2, con_input
<h3 id="port-objects">
<a href="#port-objects">Port Objects</a>
</h3>
<dl>
<dt id="dt:tcp">tcp</dt>
<dd>
<a href="rm-class-tcp-server.html#tcp-server">tcp-server</a>
 – VNC TCP server</dd>
<dt id="dt:unix_socket">unix_socket</dt>
<dd>
<a href="rm-class-unix-socket-server.html#unix-socket-server">unix-socket-server</a>
 – VNC Unix domain socket server</dd>
</dl>
<h3 id="commands-for-this-class">
<a href="#commands-for-this-class">Commands for this class</a>
</h3>
<ul>
<li>
<a href="rm-cmd-graphcon.break.html">break</a>
 – <i>deprecated</i> set a string to break on</li>
<li>
<a href="rm-cmd-graphcon.break-gfx.html">break-gfx</a>
 – <i>deprecated</i> break on a graphics event</li>
<li>
<a href="rm-cmd-graphcon.capture-start.html">capture-start</a>
 – capture output to file</li>
<li>
<a href="rm-cmd-graphcon.capture-stop.html">capture-stop</a>
 – stop output capture to file</li>
<li>
<a href="rm-cmd-graphcon.dimming.html">dimming</a>
 – get/set dimming status</li>
<li>
<a href="rm-cmd-graphcon.get-pixel.html">get-pixel</a>
 – read pixel value</li>
<li>
<a href="rm-cmd-graphcon.gfx-break-info.html">gfx-break-info</a>
 – return information about a graphical breakpoint</li>
<li>
<a href="rm-cmd-graphcon.gfx-break-match.html">gfx-break-match</a>
 – determine if graphical breakpoint currently matches</li>
<li>
<a href="rm-cmd-graphcon.gfx-break-png.html">gfx-break-png</a>
 – export graphical breakpoint data to a PNG file</li>
<li>
<a href="rm-cmd-graphcon.grab-setup.html">grab-setup</a>
 – set grab button and modifier</li>
<li>
<a href="rm-cmd-graphcon.hide.html">hide</a>
 – hide the console window</li>
<li>
<a href="rm-cmd-graphcon.info.html">info</a>
 – print information about the object</li>
<li>
<a href="rm-cmd-graphcon.input.html">input</a>
 – send string to a console</li>
<li>
<a href="rm-cmd-graphcon.input-file.html">input-file</a>
 – input a file into a console</li>
<li>
<a href="rm-cmd-graphcon.list-break-strings.html">list-break-strings</a>
 – <i>deprecated</i> list all active string breakpoints</li>
<li>
<a href="rm-cmd-graphcon.list-gfx-breaks.html">list-gfx-breaks</a>
 – <i>deprecated</i> list all active graphical breakpoints</li>
<li>
<a href="rm-cmd-graphcon.save-break-xy.html">save-break-xy</a>
 – specify and save a graphical breakpoint</li>
<li>
<a href="rm-cmd-graphcon.screenshot.html">screenshot</a>
 – save screen as PNG or BMP</li>
<li>
<a href="rm-cmd-graphcon.set-pixel.html">set-pixel</a>
 – write pixel value</li>
<li>
<a href="rm-cmd-graphcon.show.html">show</a>
 – display the console window</li>
<li>
<a href="rm-cmd-graphcon.status.html">status</a>
 – print status of the object</li>
<li>
<a href="rm-cmd-graphcon.unbreak.html">unbreak</a>
 – <i>deprecated</i> stop breaking on string</li>
<li>
<a href="rm-cmd-graphcon.unbreak-gfx.html">unbreak-gfx</a>
 – <i>deprecated</i> delete graphical breakpoint</li>
<li>
<a href="rm-cmd-graphcon.vnc-setup.html">vnc-setup</a>
 – setup VNC connection</li>
<li>
<a href="rm-cmd-graphcon.vnc-status.html">vnc-status</a>
 – return VNC connection data</li>
<li>
<a href="rm-cmd-graphcon.wait-for-gfx-break.html">wait-for-gfx-break</a>
 – <i>deprecated</i> wait for a graphical breakpoint in a script branch</li>
<li>
<a href="rm-cmd-graphcon.wait-for-pixel-value.html">wait-for-pixel-value</a>
 – real pixel value</li>
<li>
<a href="rm-cmd-graphcon.wait-for-string.html">wait-for-string</a>
 – <i>deprecated</i> wait for a string in a script branch</li>
<li>
<a href="rm-cmd-graphcon.wait-then-write.html">wait-then-write</a>
 – <i>deprecated</i> wait for a string, then write an input string</li>
</ul>
<h3 id="commands-for-interface-gfx_break">
<a href="#commands-for-interface-gfx_break">Commands for interface gfx_break</a>
</h3>
<ul>
<li>
<a href="rm-cmd-gfx_break.bp-break-gfx.html">bp-break-gfx</a>
 – set graphical breakpoint</li>
<li>
<a href="rm-cmd-gfx_break.bp-run-until-gfx.html">bp-run-until-gfx</a>
 – run until graphical break matches</li>
<li>
<a href="rm-cmd-gfx_break.bp-trace-gfx.html">bp-trace-gfx</a>
 – enable tracing of graphical matches</li>
<li>
<a href="rm-cmd-gfx_break.bp-wait-for-gfx.html">bp-wait-for-gfx</a>
 – wait for graphical match</li>
</ul>
<h3 id="commands-for-interface-break_strings_v2">
<a href="#commands-for-interface-break_strings_v2">Commands for interface break_strings_v2</a>
</h3>
<ul>
<li>
<a href="rm-cmd-break_strings_v2.bp-break-console-string.html">bp-break-console-string</a>
 – set string breakpoint</li>
<li>
<a href="rm-cmd-break_strings_v2.bp-run-until-console-string.html">bp-run-until-console-string</a>
 – run until string appears</li>
<li>
<a href="rm-cmd-break_strings_v2.bp-trace-console-string.html">bp-trace-console-string</a>
 – enable tracing of string appearances</li>
<li>
<a href="rm-cmd-break_strings_v2.bp-wait-for-console-string.html">bp-wait-for-console-string</a>
 – wait for specified string</li>
</ul>
<h3 id="attributes">
<a href="#attributes">Attributes</a>
</h3>
<dl>
<dt id="dt:keyboard">
<i>keyboard</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>o|n</code>
<br>Keyboard device the console is connected to.</dd>
<dt id="dt:mouse">
<i>mouse</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>o|n</code>
<br>Mouse device the console is connected to.</dd>
<dt id="dt:abs_mouse">
<i>abs_mouse</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>o|n</code>
<br>Absolute positioning pointer device connected to the console. Must implement the abs_pointer interface</dd>
<dt id="dt:abs_pointer_enabled">
<i>abs_pointer_enabled</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>b</code>
<br>Absolute positioning pointer enabled.</dd>
<dt id="dt:pending_kbd_input">
<i>pending_kbd_input</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>[[ib]*]</code>
<br>Queued keyboard input waiting to be sent to the attached keyboard device. Each element is a key code and a make/break flag (TRUE on make).</dd>
<dt id="dt:mouse_state">
<i>mouse_state</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>[iibb]</code>
<br>Mouse state, only used when not using an absolute positioning pointer.</dd>
<dt id="dt:microm_per_pixel">
<i>microm_per_pixel</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read/write</b> access; type: 
<code>[ii]</code>
<br>Micrometers per (horizontal, vertical) pixel for converting mouse movements. only used when not using an absolute positioning pointer.</dd>
<dt id="dt:grab_modifier">
<i>grab_modifier</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>s</code>
<br>A string in (control, alt, shift), specifying the modifier key used for grabbing and ungrabbing input from the console. Currently only the left side modifier are interpreted.</dd>
<dt id="dt:grab_button">
<i>grab_button</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>s</code>
<br>One of left, middle and right The grab button specifies which mouse button that is used to grab and ungrab input for the console.</dd>
<dt id="dt:visible">
<i>visible</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>b|n</code>
<br>Show/hide console GUI window. Setting to NIL only has effect before instantiation, in which case it leads to the default visibility behaviour of showing the console window if it is the unique console in the configuration.</dd>
<dt id="dt:recorder">
<i>recorder</i>
</dt>
<dd>
<b>Required</b> attribute; 
<b>read/write</b> access; type: 
<code>o</code>
<br>Recorder object</dd>
<dt id="dt:max_screen_size">
<i>max_screen_size</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>[ii]</code>
<br>Console window maximum allowed screen size, in pixels (width, height).</dd>
<dt id="dt:window_title">
<i>window_title</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>s</code>
<br>Console GUI window title.</dd>
<dt id="dt:screen_size">
<i>screen_size</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>[ii]</code>
<br>Console window size in pixels (width, height).</dd>
<dt id="dt:screen_data">
<i>screen_data</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>d</code>
<br>Console screen data.</dd>
<dt id="dt:palette">
<i>palette</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>[[iii]{256}]</code>
<br><tt>((<i>r</i>, <i>g</i>, <i>b</i>), ...)</tt> Palette used in 8-bit mode. 256 colors, 8 bits/channel.</dd>
<dt id="dt:output_file">
<i>output_file</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read/write</b> access; type: 
<code>s</code>
<br>If set to a non-empty string, output will be directed to and appended to this file. Set to an empty string to stop file output.</dd>
<dt id="dt:keyboard_leds">
<i>keyboard_leds</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read-only</b> access; type: 
<code>[bbb]</code>
<br>State of keyboard leds (Caps lock, Num lock, Scroll lock).</dd>
<dt id="dt:cmd_line_output">
<i>cmd_line_output</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>b|n</code>
<br>If set to TRUE, the Simics command line will receive console text output, which will also be logged at level 3. If set to NIL, command line and log output will happen automatically when the console GUI is invisible. If set to FALSE, no command line or log output will happen.</dd>
<dt id="dt:output_line">
<i>output_line</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>d</code>
<br>The current output line of printable characters from the attached VGA device.</dd>
<dt id="dt:device">
<i>device</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>o|n</code>
<br>Video device the console is connected to.</dd>
<dt id="dt:refresh_rate">
<i>refresh_rate</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>i</code>
<br>Refresh rate (in hertz). Set to 0 to disable screen refresh</dd>
<dt id="dt:gfx_breaks">
<i>gfx_breaks</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read-only</b> access; type: 
<code>[[isbbfiiiid]*]</code>
<br>List of console graphical breakpoints. Each entry is (hap id, name, active, oneshot, update interval, minx, miny, maxx, maxy, image data)</dd>
<dt id="dt:next_gfx_break_id">
<i>next_gfx_break_id</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read-only</b> access; type: 
<code>i</code>
<br>Hap ID for next added breakpoint.</dd>
<dt id="dt:vga_text_data">
<i>vga_text_data</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read-only</b> access; type: 
<code>[iiii[i*]d]|n</code>
<br>VGA text screen contents: (rows, columns, font width, font height, line lengths, text data). NIL if not currently in VGA text mode.</dd>
<dt id="dt:refresh_in_virtual_time">
<i>refresh_in_virtual_time</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>b</code>
<br>If TRUE, then the refresh rate will refresh the screen based on virtual time, instead of real time. Default is FALSE.</dd>
<dt id="dt:vnc_port">
<i>vnc_port</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read/write</b> access; type: 
<code>i|n</code>
<br>VNC listening port or NIL if no port should be opened. The port must not be privileged, i.e. the allowed range is [1024, 65535]. A value of 0 means that a random free port will be used.</dd>
<dt id="dt:vnc_unix_socket">
<i>vnc_unix_socket</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read/write</b> access; type: 
<code>s|n</code>
<br>VNC UNIX socket. The file must not exist.</dd>
<dt id="dt:new_vnc_port_if_busy">
<i>new_vnc_port_if_busy</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read/write</b> access; type: 
<code>b</code>
<br>Determines if a new TCP port may be used when restoring from a checkpoint and the saved port is already busy. The default value is TRUE. It may be set to FALSE for setups that rely on the same port being used all the time.</dd>
<dt id="dt:vnc_clients">
<i>vnc_clients</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read-only</b> access; type: 
<code>[[di]*]</code>
<br>List of (remote ip, remote port) for each VNC client.</dd>
<dt id="dt:vnc_allow_compression">
<i>vnc_allow_compression</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>b</code>
<br>If TRUE, then compressed encodings are used if the VNC client requests it, otherwise only raw encoding is used. Default is TRUE. Supported encodings are ZRLE and Tight.</dd>
<dt id="dt:vnc_zlib_level">
<i>vnc_zlib_level</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>i</code>
<br>VNC zlib compression level, in range 0..9, default 6.</dd>
<dt id="dt:vnc_keymap">
<i>vnc_keymap</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>[[ii]*]</code>
<br>VNC keyboard mapping for special keys: a list of pairs, keysym -&gt; sim_key_t.</dd>
<dt id="dt:vnc_password">
<i>vnc_password</i>
</dt>
<dd>
<b>Optional</b> attribute; 
<b>read/write</b> access; type: 
<code>s|n</code>
<br>VNC server password. If this is set to a string, which must be non-empty, then the server will use the VNC authentication mechanism and require clients to provide the password on connect.</dd>
<dt id="dt:break_strings">
<i>break_strings</i>
</dt>
<dd>
<b>Pseudo</b> attribute; 
<b>read-only</b> access; type: 
<code>[[sbbiib]*]</code>
<br>List of console break strings (string, active, oneshot, hap ID, unused, regexp)</dd>
</dl>
<h3 id="provided-by">
<a href="#provided-by">Provided By</a>
</h3>
<a href="mod.graphcon.html">graphcon</a>
</section>
<div class="chain">
<a href="rm-class-gml_link_impl.html">gml_link_impl</a>
<a href="rm-class-gui.html">gui</a>
</div>